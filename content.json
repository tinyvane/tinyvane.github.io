{"pages":[{"title":"无聊小博","text":"没什么好说的，想要交换链接请留言，谢谢。","link":"/about/index.html"},{"title":"友链","text":"一群志同道合的朋友，无关顺序。 山上【七月上，直播小王子】 JerrySher’s blog【安卓，群主，有钱人，焦虑ing】 Handa【逗比青年】 美丽应用【好APP发现和传播】 水番林【有志青年】 交换链接请留言，谢谢。","link":"/links/index.html"}],"posts":[{"title":"如何往chrome浏览器里面，拖入crx或者图片进行上传？","text":"其实这个问题，google了很久，并不是很麻烦，只是很多时候，自己都没有注意到区别，下面我就要公布解决方法啦！ 很简单！ “不要用管理员模式运行”CHROME！ 下面缺少一个截图，但是如何截取右键菜单呢？这又是一个新问题！","link":"/2015/12/07/how_to_drag_crx_plugins_into_chrome/"},{"title":"日常工具的各种快捷键总结","text":"文章更新 20151208-初次成文 20160902-修改了格式 20160905-添加各种日常软件的常用快捷键，目的是不再使用鼠标，因为蜷着腿坐在沙发上，也没地方使用鼠标了。 为什么会有这篇文章因为我自己的键盘是FILCO MINILAR AIRCHERRY的哪款来着？，反正大爱青轴，所以敲字那叫一个爽快！其实不论是使用MBP还是PC，快捷键对工作效率的提高还是很明显的，所以就顺手总结一下，这样边看边用，也可以熟记于心。 VIMIUM+CHROME常用快捷键最常用快捷键中，首先来看看针对当前一个已经打开的页面，有哪些快捷键 j/k 向下/上慢速移动页面。 d/u 向下/上快速移动页面。 f 打开页面上所有链接，并按照字母和组合来给每个链接贴标签 gi 将焦点集中到第一个输入框（输入gNi则焦点集中到第N个输入框），这个最常见应用就是你打开了google或者某个页面，gi一般会带你到搜过框内。 / 查找模式,找到匹配项后，按回车，若有多个匹配，使用n/N则可以在匹配结果之中，向下或者向上移动。 偶尔当Vimium失效的时候，有一些快捷键还是需要用Chrome自身的快捷键来代替，比如，上面的查找操作，Chrome默认可以使用Command+F(Windows下为Ctrl+F)，+ 向下匹配直接按Enter，向上匹配则按Shift+Enter。 好了，掌握了上面的快捷键，那么基本操作就可以了，我们再来温习一下不那么常用的快捷键。 gs 查看页面源代码 yy 拷贝当前页面的URL到剪贴板，这个和Vim中相同，一般在Vim就是4yy，然后p ：)。 r 重新载入该页（相当于F5刷新页面），或者Command+R x 关闭当前的标签页，如果用不了就用Command+W(或者CTRL+W) X 恢复刚刚关闭的标签页，如果用不了就用Command+Shift+T(或者CTRL+Shift+T) G/gg 跳转到页面的底部/顶部。 如果向往前翻呢？在Windows下直接用Backspace或者用Ctrl加上左右箭头？在Vim下则使用 H/L 页面向前/后翻。(历史记录向前/后，Chrome是Command+[和Command+]) 好了，假设你对当前页面没啥想法了，则可以打开一个新的TAB或者在不同的TAB之间来回移动。 J/K 下/上一个标签 t 打开新标签，如果用不了就用Command+T(或者CTRL+T) 不常用快捷键 gt 跳转到右边的一个标签页 gT 跳转到左边的一个标签页 zH 一直移动到左部。 zL 一直移动到右部。 yf 拷贝某一个URL到剪贴板（实际上是相当于输入了f，然后出现很多编码的URL，选择某个之后，相当于拷贝了某个，因为一个页面中可能有很多超链接） gu 跳转到父页面（比如http://www.douban.com/group/vim/，输入后跳转到父页面即http://www.douban.com/group/，所以不同于H的快捷键是回到上个历史页面） i 这个是所谓的插入模式(insert mode)，不过看了下网上普遍的说法，这个模式是用来关闭vimium的快捷键，以便使用网页的原生快捷键，所以更可以理解为’i mode’，即”我的模式”。 书签中搜索 B 在新的标签页打开一个书签 Sublime快捷键 Ctrl+L 选中整行 Visual Studio Code常用快捷键 ctrl+-（shift+ctrl+-）：移动光标到上次位置或相反，比如定位一个函数，转到函数定义后想回到函数使用处，则用ctrl+-，若又想回到函数定义处则可以按shift+ctrl+- F12：Go to Definition，到变量或函数定义的地方，如变量声明处，函数实现处。与ctrl+-配合使用非常方便 Ctrl+]：匹配选中的括号（大括号、小括号都行），在多层循环+判断语句时非常方便 ctrl+Space：代码补全 ctrl+tab：在VS中切换打开的窗口，即切换各个文件 ctrl+I：递增搜索，与ctrl+F不同的是搜索期间不显示搜索对话框，且ctrl+F搜索下一个直接按Enter即可，而ctrl+I搜索下一个按ctrl+I或F3，Escape退出，连续按两次ctrl+I重复上次搜索 Ctrl+Shift+F：旧式的文件搜索对话框（与记事本中的搜索替换框差不多，可以替换） Ctrl+F3：为当前选中的部分进行搜索（不需要再输入要搜索的内容） Shift+Alt+Enter：最大化代码编写区域（代码全屏模式），即去掉所有其它辅助窗口只留下代码编写窗口，再按一次返回到原来界面 ctrl+K，Ctrl+C：注释一段代码块（先要选中一段代码） ctrl+K，Ctrl+U：取消注释一段代码块 ctrl+K，Ctrl+D：代码自动格式化（整个文档） ctrl+K，Ctrl+F：只格式化你选中的部分 Ctrl+K，Ctrl+K：在当前行创建一个书签 Ctrl+K, Ctrl+N：去下一个书签处 Ctrl+C, Ctrl+V：在当前行的下一行复制当前行内容（不用选中当前行），即复制当前行并粘贴到下一行，在两行内容差不多时很有用，可以先复制再改 Ctrl+L：删除当前行 Ctrl+M, Ctrl+M：展开或关闭当前的代码 Ctrl+Shift+P ，调出命令列表，从这里可以看到所有的快捷键 Shift+Alt+F , 相当于format作用，使代码段自动对齐 Ctrl+/ 注释代码，只要把光标移动到要注释的地方就行 xxx+Tab，快速联想标签，感觉很智能，敲代码时可以省不少事 ，但要注意文件扩展名必须为html；（比如按一下a，再按一下tab，就会发现惊喜！） alt+up，alt+down，将光标所在行的代码上移或下移一行 说了这么多，不得不说，不知道为什么VSCODE没有打开文件夹的快捷键，但是有一个命令可以实现打开当前文件夹的操作，就是code .，看了一下，调用的是一个叫code的cmd文件，所以还是很方便的，我在cygwin下貌似会出错，所以可以直接把code作为一个zsh的alias。 Mac下常用的快捷键在苹果系统中，有几个在Windows下常用的键在MBP或者类似笔记本的键位上没有，如Delete、PageDown键等。 Macbook的键盘布局中没有独立的 Home/End/PageUp/PageDown 四个键，用Fn+方向键替代。 Fn + Left Home Fn + Right End Fn+Up PageUp Fn + Down PageDown Macbook的键盘布局中也只有Delete，而没有独立的Del键，需要结合 Fn + delete 来实现。 我觉得MAC有个很贴心的快捷键，就是使用 Command + 左/右方向键，来移动到行首或者行尾 应用程序通用快捷键（在几乎所有程序中，这些快捷键都是相同的功能，所以，花点时间记忆它们对将来提高效率非常重要） 关闭标签页：Command + w 关闭当前窗口（在多标签程序中，比如safari浏览器，相当于关闭当前标签） 文字编辑时：fn + delete 删除光标后的字符，这就是Windows上常用的DEL键的功能 Macbook的F1~F12都被定义成各种功能键了，比如调节屏幕亮度、音量大小等等。如果要使用 F1键，可以按FN+F1，或者在Boot Camp控制面板中，把”将F1、F2等键用作标准功能键” command + q 关闭当前程序（quit） command + a 全部选择（select all） command + c 拷贝选中内容（copy） command + x 剪切选中内容（cut） command + v 粘贴到选中位置（paste） command + z 撤销操作 shift + command + z 恢复操作 command + o 打开 command + n 新建 command + s 保存 shift + command + s 另存为（save as） command + p 打印（Print） shift + command + p 页面设置（Page Setup） 先把要剪切的文件按command+c复制，然后，到目的位置，按下 command+alt+v 粘粘，就会发现复制的源文件已经被剪切过来了。 和上面这条对应，我的键盘左下角从左到右依次是 command, alt, control 三个键，所以黏贴就是 按住左下角两个键+v，而按住2 3号键+空格，就是打开一个新的finder，相当于window的ctrl+e，很好用，也很好记 Mac下的截图我只记下两个，一个是 command+control+4，截图不保存，这种主要是接完图直接就黏贴到QQ聊天窗口这种地方（command+v黏贴）另外一种就是保存到桌面，使用command+shift+4，其他的方法还有几个，记不住，也用得不多。 Windwos快捷键这部分被我转移到了新帖子如何不用鼠标使用WINDOWS 10中。 Visual Studio Code F1或Ctrl+Shift+P 打开的命令面板了，在这个命令框里可以执行VSCode的任何一条命令，可以查看每条命令对应的快捷键，甚至可以关闭这个编辑器。 Shift+Alt+F, 相当于format作用，使代码段自动对齐 Ctrl+/ 注释代码，只要把光标移动到要注释的地方就行 xxx+Tab，快速联想标签，感觉很智能，敲代码时可以省不少事，但要注意文件扩展名必须为html；（比如按一下a，再按一下tab，就会发现惊喜！） Alt+up，Alt+down，将光标所在行的代码上移或下移一行 微软官方的说明文档，因为VSCode更新很快，导致很多快捷键目前功能不是很固定，所以可以打印官方pdf为准。官方说明文档 酷我音乐的快捷键 CTRL+SHIFT+左右方向键 上一首，下一首歌曲 CTRL+SHIFT+上下方向键 音量大，音量小 QQ音乐的快捷键和酷我音乐盒差不多，唯一的不同，就是SHIFT换成了ALT，个人觉得不是很方便，但是有时候两个播放器同时开，觉得还是不要修改成一样的为好，毕竟是默认快捷键。 微信电脑板 CTRL+ALT+W 打开聊天面板 CTRL+上/下 在不同联系人之间移动 QQ电脑版 CTRL+上下，在不同联系人之间移动 CTRL+W 关闭某个对话 参考资料 Mac键盘常用快捷键 VS下常用的快捷键 Vscode中一些方便的快捷键","link":"/2015/12/08/daily_shortcuts_in_vimium_visual_studio_code_and_others/"},{"title":"如何解决WIN10下UAC的权限问题","text":"其实就是解决“在该设置条件下，无法打开XXX程序”的问题 步骤如下: 进入控制面板，选择安全性与维护，在左侧更改Windows SmartScreen筛选器设置，选择不执行任何操作，确定。 进入控制面板，选择用户账户，选择最下面的更改用户账户控制设置，把滑条拉到最下面从不通知。 打开运行，输入gpedit.msc进入策略组，依次选择计算机配置、Windows设置、安全设置、本地策略、安全选项，在右侧下拉选择用户账户控制：以管理员批准模式运行所有管理员，双击它，选择已禁用。 重启后，即可关闭用户账户控制。","link":"/2015/12/08/how_to_solve_uac_authority_in_windows_10/"},{"title":"更新wordpress过程中遇到“无法创建目录”问题如何解决？","text":"这个问题其实困扰我好久了，阿里云用的linux一键安装包，因此没注意使用的是什么ftp程序，只知道默认用户名是www， google了很久，终于找到了一劳永逸的办法 就是 在更新之前 在xshell里面 #chmod -R 777 /alidata/www/wuliaole.com/ 更新之后， #chmod -R 755 /alidata/www/wuliaole.com/ 完美","link":"/2015/12/07/how_to_solve_problem_of_directories_could_not_be_created_when_updating_the_wordpress/"},{"title":"如何截图windows系统右侧菜单？","text":"我这里使用的QQ截图的方法，步骤如下： 先不要点右键，按按住键盘上CTRL+ALT+SHIFT+A，4个键同时按下去 点鼠标右键 松开SHIFT键 然后看到截图窗口了么？ 然后，这里顺便记录一下QQ热键冲突的解决办法 我使用的是Windows Hotkey Explorer这个小软件，它可以显示当前已被占用的快捷键。 Hotkey Commander官网地址，使用介绍。 不过大家安装之后，一定要有一个思想准备，因为软件一打开会把系统现有的快捷键全打开一遍，场面蔚为壮观！ 经常会卡死，所以，做好心理准备！ 一般第二次重新打开的时候，会流畅一些~","link":"/2015/12/07/how_to_capture_right_click_screen_in_windows/"},{"title":"C#模拟键盘操作--SendKey(),SendKeys()","text":"C#实现模拟键盘输入可以使用以下2个语法实现的，分别是：SendKeys.Send(string keys); //模拟汉字(文本)输入SendKeys.SendWait(string keys); //模拟按键输入 先了解一下2个语法的用法吧！ （1）每个按键由一个或多个字符表示。为了指定单一键盘字符，必须按字符本身的键。例如，为了表示字母 A，可以用 “A” 作为 string。为了表示多个字符，就必须在字符后面直接加上另一个字符。例如，要表示 A、B 及 C，可用 “ABC” 作为 string。（2）对 SendKeys 来说，加号 (+)、插入符 (^)、百分比符号 (%)、上划线 (~) 及圆括号 ( ) 都具有特殊意义。为了指定上述任何一个字符，要将它放在大括号 ({}) 当中。例如，要指定正号，可用 {+} 表示。方括号 ([ ]) 对 SendKeys 来说并不具有特殊意义，但必须将它们放在大括号中。在其它应用程序中，方括号有特殊意义，在出现动态数据交换 (DDE) 的时候，它可能具有重要意义。为了指定大括号字符，请使用 {}。（3）为了在按下按键时指定那些不显示的字符，例如 ENTER 或 TAB 以及那些表示动作而非字符的按键，请使用下列代码： 按键 代码 BACKSPACE {BACKSPACE}, {BS}, 或 {BKSP} BREAK {BREAK} CAPS LOCK {CAPSLOCK} DEL or DELETE {DELETE} 或 {DEL} DOWN ARROW {DOWN} END {END} ENTER {ENTER}或 ~ ESC {ESC} HELP {HELP} HOME {HOME} INS or INSERT {INSERT} 或 {INS} LEFT ARROW {LEFT} NUM LOCK {NUMLOCK} PAGE DOWN {PGDN} PAGE UP {PGUP} PRINT SCREEN {PRTSC} RIGHT ARROW {RIGHT} SCROLL LOCK {SCROLLLOCK} TAB {TAB} UP ARROW {UP} F1 {F1} F2 {F2} F3 {F3} F4 {F4} F5 {F5} F6 {F6} F7 {F7} F8 {F8} F9 {F9} F10 {F10} F11 {F1} F12 {F12} F13 {F13} F14 {F14} F15 {F15} F16 {F16} （4）SHIFT、CTRL 及 ALT 等按键结合的组合键，可在这些按键码的前面放置一个或多个代码，这些代码列举如下： 按键 代码 Shift + Ctrl ^ Alt % （5）输入汉字用SendKeys.Send(\"汉字\"); 样例代码： using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Windows.Forms; namespace ApplicationForm { public partial class Form1 : Form { public Form1() { InitializeComponent(); } private void button1_Click(object sender, EventArgs e) { //光标移至richTextBox1 richTextBox1.Focus(); //模拟按下\"ABCDEFG\" SendKeys.SendWait(\"(ABCDEFG)\"); SendKeys.SendWait(\"{left 5}\"); SendKeys.SendWait(\"{h 10}\"); /* 更多举例: SendKeys.SendWait(\"^C\"); //Ctrl+C 组合键 SendKeys.SendWait(\"+C\"); //Shift+C 组合键 SendKeys.SendWait(\"%C\"); //Alt+C 组合键 SendKeys.SendWait(\"+(AX)\"); //Shift+A+X 组合键 SendKeys.SendWait(\"+AX\"); //Shift+A 组合键,之后按X键 SendKeys.SendWait(\"{left 5}\"); //按←键 5次 SendKeys.SendWait(\"{h 10}\"); //按h键 10次 SendKeys.Send(\"汉字\"); //模拟输入\"汉字\"2个字 */ } } } 原文出处：http://www.cnblogs.com/liujie1111/p/4268174.html","link":"/2015/12/10/simulation_of_key_press_in_c_sharp_using_sendkey/"},{"title":"使用TurboTop保持Windows上任意程序保持最前端","text":"有时候你可能需要把某个应用窗口保持在最前端，比如处理表单数据的时候将计算器放在最前面。TurboTop 这款免费PC工具可以让任意正在运行的应用窗口保持在最前端。 运行后点击托盘区图标可以看到正在运行的应用列表，勾选某个应用，此应用就会保持在最前端了，而且你可以勾选多个应用。 软件名称：TurboTop 支援平台：Windows 软件下载：官网 软件截图 转载了其他人的文字，当个软件推荐给大家吧。","link":"/2015/12/18/use_turbotop_to_keep_applications_topmost/"},{"title":"一个微信电脑版或者QQ浏览器的微信聊天辅助工具v0.1b","text":"工具存在的目的，是让你的生活更加省心、省力、省钱 怎么说呢，估计用到这个软件功能的人不是太多，具体环境就是如果你旁边的同事离你的工位很近，不想让他们瞟见你聊天的内容，尤其是好友的最后一句话，那么这个工具适合你。 开发环境：VS2015 语言：C# 下载地址：BlankChat v0.1b [ 最新版本：0.1beta 软件介绍：就是可以在聊天记录之前加上一堆空格，然后自动发出去，快捷键是CTRL+ENTER。 使用方法：首先要修改一下微信桌面版的发送快捷方式，要改成ENTER，否则会和软件的快捷键冲突。","link":"/2015/12/10/wechat_tool/"},{"title":"几款查壳工具.net程序脱壳必备知识","text":"查壳是解密的第一步，介绍几个工具，一个不好用，就换一个试试，其实我只知道PEiD，其他几个我只是看别人有介绍，就先翻译了。不过PEiD确实已经好几年没有更新过了，大家自己看着办吧。 PEiD 这是最著名的查壳工具了吧，至少我觉得挺有名。可以查找超过600种不同壳子的签名，可惜。。不更新了。 软件界面小巧简单，最省事的办法就是直接吧EXE或者DLL文件拖到软件界面里面去，即可完成默认查壳动作，软件界面上可以显示壳子的名称、入口点地址（entry point）、文件偏移量（file offset）、链接信息（linker information）、EP区域（这是什么意思，我目前还不知道）（EP section）、第一个字节（first bytes），以及选定文件的子系统信息（subsystem information）。 PEiD有三种不同的扫描模式： 正常模式（Normal Mode）：通过文档签名扫描PE文件的入口地址。 深度模式（Deep Mode）：通过文档签名扫描入口地址通常存在的区域。 硬汉模式（Hardcore Mode）：通过文档签名遍历遍历文件以找到PE文件的入口地址。软件也支持命令行模式，拖放操作，甚至可以将程序置于桌面顶部。 下载地址: PEiD Exeinfo PE Exeinfo PE相比PEiD来说更加强大，光从维护上这一点来说，就甩PEiD几条街啊，起码人家2015年11月还在维护更新。就算功能上没有前者好，但是。人家也可以改进啊。好了，废话太多了，Exeinfo PE不单可以显示壳子信息，并且可以显示入口点，文件便宜地址，链接信息，文件大小，EP区域，第一个字节位置，子系统，以及EXE文件的覆盖信息（overlay），并且其他选项更为丰富。 同样Exeinfo PE也支持选择文件，或者直接拖进去查壳。在程序的界面中，你可以让Exeinfo PE进行快速查壳，或者忽略EXE执行错误，程序也支持命令融合壳模式（integrate into the shell），和PEiD一样，程序可以置顶，打开登录模式，或者改变皮肤和默认使用的语言。 下载地址: Exeinfo PE Language 2000 Language 2000是一个比较简单的查壳工具，可以显示编译器的名称，语言，作者，还有作者的地址。这也许有助于你确定壳子的类型，但是也就那样了。 这个程序可以探测 EXE DLL以及OCX类型文件的编译器/加密器/壳子。 下载地址：暂无。 参考资料http://sumtips.com/2012/05/detect-identify-exe-compiler-packer.html","link":"/2015/12/10/the_shell_detection_tools_of_c_sharp_decompling/"},{"title":"使用RSA加密保护你的.net应用程序(winform)","text":"原文地址：http://www.codeproject.com/Articles/203840/RSA-License-Protection 介绍本文的目的是通过使用.net内置的RSA加密组件对winform程序进行签名并校验，以达到有效保护winform程序的目的。 背景所有应用程序开发者，尤其是哪些程序需要销售并且得到付款的开发者，都或多或少的关注程序的未授权的分发问题。因为无论什么时候，程序都存在被破解（或反编译）的可能性，总有人不想花钱去买你的软件。而你需要明白的一个事实是，无论你如何加密软件，软件都存在被破解和反编译的事实，因此，加密的目的，并不是为了防止反编译或者破解，而是加大破解的难度，让大多数人觉得购买你的软件，比寻找破解版更加容易。并且最重要的一点，就是程序员需要花费更多的精力，去完善软件，提升服务，尤其是配套的，售后的服务质量，让顾客觉得心甘情愿购买你的软件，或者更确切的，是购买你的服务！然后，再回头来讨论下这篇文章的最初目的，就是你的程序，应当，也应该校验用户的合法性，毕竟你是需要赚钱的！ The best bit of programming you can do to secure your program is to make the program actually valuable to the user, so they want to buy it. But, the next best thing is a mechanism by which you can use to correctly identify valid users of the program. There is no end to these methods, and they all have varying levels of security, administration overhead, and user-annoyance. Here are some of the common methods: Serial Number ProtectionFound on the back of a CD case, the most common copy-protection you can find often involves a long serial number that is derived from an algorithm, such that only the original key-generator can produce valid keys. Often, the first few characters define a seed entry for a pseudo-random-number generator, and the remaining characters must match the transformed output of that number generator. This has a number of drawbacks: It is a blanket authorization: Usernames and License-end terms, partial licenses cannot be specified All you need is a copy of the serial-number: there are hundreds of websites that list known serial numbers for almost any bit of commercial software. The user has to type in a long annoying and difficult to read serial number in order to install the software. Online ActivationAn extension of serial-number protection: the application contacts a central server to validate that the serial-number is one that has been issued. This allows serial numbers to be blacklisted, tracked, etc. The main drawback is that the application must have internet access in order to validate the serial number. Users will probably not be happy about this (especially if they don’t have constant internet access) and you may find hackers patching your software not to illegally copy it, but just to get it to work offline. The other drawback is the amount of coding and development work that must go into a system like this that could be defeated by a proxy-server that simulates the responses of your own validation server. License Terms FileMany systems use a license file that is supplied to the user with their purchase. The license file specifies the licensee (the user’s name, address, contact details, etc.), the product being licensed, and the start and end dates of that license. The software asks for the license file on first use, copies it into a known location, then validates that the terms of the license are valid (correct software version, within the applicable date-range, etc.). The trick here is to ensure that the license file that is supplied is authentic, if that part is covered, this is an excellent system for licensing: the license terms can be as simple or complex as you like (i.e. blanket authorization, or partial (certain features enabled)), they can have start and end dates, be restricted to particular applications or even restricted to particular users. The user isn’t forced to type in a long and complex serial-number, and having the users name and contact details embedded within the terms makes it less likely that users will voluntarily share the license file. Authenticating the License FileThere is a branch of cryptography that deals with verification (or signing) of data, using Asymmetrical Encryption. A digital signature is produced from the data being verified by generating a hash-code from the source data, and encrypting this hash with a private key.The hash code will be unique to the source data… if even one bit in the source data changes, the resulting hashcode will be quite different. (The “strength” of any hashing algorithm is indicated by how much the hash-code changes with the smallest possible edit of the source data). Verification of the data is achieved by using the public-part of the key to check if the digital signature (the encrypted hash) still matches the data that is being verified. If any part of the data is changed, then the digital signature will not match. This means that you can verify that the license file the system is using definitely came from you, (the sellers of the software) without having to give the application access to the private key. If you were to use symmetrical encryption to encrypt the license-terms (so they could not be seen or changed), then the application itself would need access to the encryption key, in order to decrypt the file. The key could be found within the application EXE and extracted, allowing pirates to generate their own license files. Using asymmetrical encryption still requires that the application have access to the public part of the key, but knowing the public part of the key will not help anyone trying to hack the system. The danger lies in pirates being able to replace or intercept the public key with one of their own making. This would require them to get into the .exe and alter the sequence of bytes that defines the public-key (whether it is a string-literal or a resource within the EXE). This is beyond the scope I have given myself for this article, but just a quick mention:signing the executable itself is one potential way of trying to stop this: modification of the executable will generate a different signature, and the application can be instructed not to open. (This is how the click-once manifests work, in fact, using click-once to deploy your application makes it (almost) impossible to modify that application without regenerating the click-once manifest file.) 如何使用代码The logic for the licensing system is contained within the General.Securitynamespace within the example project: this code is non-specific and portable (it doesn’t reference any custom types outside the Generalnamespace) and the two files (Serializer.cs and _RSA.cs_) can be moved to any project without change. The actual implementation of the licensing system (i.e. project specific code) is contained within thevalidateLicenseFile()method of the static Program class. This provides a good example of using the methods defined in the General.Securitynamespace. The Program.validateLicenseFile()method reads the publickey out of the embedded resource (Resources.resx) and locates the license file (asking the user for the location if it can’t find it). It verifies the license file signature is correct, then extracts the license-terms, de-serializes them and checks that the current software and date/time is within the terms on the license. Supplied is an example license file (valid until the year 9999) for user “Test“ (Test.lic) - The public and private key files used to generate this license are also included. This is the validateLicensemethod: /// validate the user-license. internal static bool validateLicenseFile() { try { // reserve a license object: License license = null; // get the public key from internal resource: String publicKey = Properties.Resources.publicKey; // work out the expected license file-name: String licenseFile = Application.LocalUserAppDataPath + \"\\\\\" + Environment.UserName + \"_user.lic\"; // does the license file exist? if (File.Exists(licenseFile)) { // load the license: license = License.Load(licenseFile); } else { // prompt the user for a license file: OpenFileDialog dlg = new OpenFileDialog(); // setup a dialog; dlg.Filter = \"User License Files (*.lic)|*.lic\"; dlg.Title = \"Select License File\"; if (dlg.ShowDialog() == DialogResult.OK) { try { // copy the license file into the local app data directory: File.Copy(dlg.FileName, licenseFile); // if it made it here, load it: if (File.Exists(licenseFile)) { license = License.Load(licenseFile); } } catch { // can't copy the file?.. load the original: license = License.Load(dlg.FileName); } } } if (license != null) { // validate the signature on the license with the message contents, // and the public key: LicenseAuthorization.ValidateLicense(license, publicKey); // if we get here, the license is valid; return true; } else { // no license file... MessageBox.Show(\"License File Not Supplied!\", \"License Check\"); return false; } } catch (SecurityException se) { // display the reason for the license check failure: MessageBox.Show(se.Message, \"License Check\"); } // return false...invalid license. return false; } } Points of InterestSomething I discovered while doing the research for this: You can convert an array of bytes to a printable stringusing Convert.ToBase64String(). The result stringalways contains printable ASCII characters, and it is definitely not human-readable. The LicenseTermsclass for this article, (which contains the start date, end date, product name, user name, etc.) is stored in the license file (which is XML) as a string. The stringis created by serializing the licence-terms class to a byte-array using the binary-formatter. This doesn’t encrypt the license terms by any means, but it makes it much harder to read, and it also makes it easy to deal with (no special serialization is required to save a string). 更新版本 Version 1.0 文章授权 This article, along with any associated source code and files, is licensed under The Code Project Open License (CPOL)","link":"/2015/12/16/how_to_use_rsa_to_protect_your_local_and_remote_communication/"},{"title":".net破解反编译资料汇总","text":"国内网站 唔爱破解，不多说了 17开源，17开源的站长是个挺热心的人，汇总了不少好东西 国外网站 http://www.hackforum.net 著名的HACK论坛，国内IP无法访问，挂代理或者VPN也不行 http://www.tuts.com http://www.nulled.io 现在貌似域名编程nulled.cr了，不知道IO出现什么变故了 查壳工具 PeID 0.95 下载地址：[download id=”115”] 官网：无，已经停止更新 这里要说一下，0.95版本，大小213KB，而网上我下载到的0.96版本，也许并不是原作者的作品，其软件大小就超过1M，并且打开的时候，腾讯管家报毒“进程创建”，各位小心为妙。 Exeinfo PE 0.0.4.1 下载地址：[download id=”150”] 官方网站：http://exeinfo.atwebpages.com/ Dot Net ID 下载地址：[download id=”154”] 官方网站：http://rongchaua.net，网站404 脱壳工具 .NET Generic Unpacker(x86) 官方网站：http://exeinfo.atwebpages.com/ DNGuard HVM Unpacker 3.71 trial support SAE 1.14 下载地址：[download id=”122”] .NET REFLECTOR 8.3.3.115 ILSpy_Master_2.3.1.1855 Telerik Just Decompile 2015.3.1116.1 dnSpy 1.5.0.0","link":"/2016/01/11/the_summary_of_decomplation_of_c_sharp/"},{"title":"Windows下的awesome让所有窗口平铺沾满桌面的工具bug.n","text":"更新日志 20160114-初次成文 20170315-添加内容，放弃了bug.n 为什么会有这篇文章总有一些东西是你自己不知道是否需要，但是在看到的那一刹那，相见恨晚。 2017年3月15日，放弃了bug.n，全面使用Windows 10的自带快捷键。请移步这里，看我的另一篇文章，[http://www.wuliaole.com/post/how_to_use_windows_without_mouse](如何不用鼠标使用WINDOWS 10)。 介绍因为曾经在知乎上，看到玩多屏的人介绍过 Awesome，就一直寻找 Windows 平台下的类似软件，结果找到了这个名叫bug.n的小软件（名字是不是很拗口？）。 软件在GITHUB上的地址 先看一下我自己开启bug.n后桌面的窗口布局： 值得一提的是，窗口顶端还有一个banner，显示的信息包括： 虚拟桌面列表 当前虚拟桌面使用什么布局 活动窗口的标题 日期时间 bug.n支持虚拟桌面。Windows系统只有一个桌面，但通过bug.n可以虚拟出很多桌面。如果你正在一个桌面上玩游戏或看碟，看到老板来了，你可以迅速切换到早就准备好的工作桌面。老板在任务栏上不会发现任何你娱乐过的蛛丝马迹。 通过按Win+ Shift + 加数字n，可以切换到第n个桌面。用鼠标直接点击banner上的虚拟桌面按钮也可以。另外用鼠标右键点击某个虚拟桌面，会把当前的活动窗口送到那个虚拟桌面去。 每个桌面支持三种布局模式： 平铺模式(tiling): 所有窗口平铺，左边是主窗口，右边是窗口队列。按 Win+ Shift + t 可以切换到tiling模式。 浮动模式(floating): 所有窗口浮动，可以互相遮盖，就是我们平常用的模式。按 win+ Shift + f可以切换到floating模式。 全屏模式(monocle): 所有窗口最大化，一次只显示一个。按 Win+ Shift + m 可以切换到 monocle 模式。用鼠标右键点击banner上的布局按钮可以在这三种布局间切换。 通过窗口键加方向键可以调整主窗口大小和改变窗口队列，自己试试就知道。如果你觉得受不了了，按 Win + Shift + Ctrl + Shift + q，可以退出bug.n。 我在Win10上用bug.n，自己的配置写在 C:\\Users\\Administrator\\AppData\\Roaming\\bug.n\\Config.ini 中。 重点介绍一些常用的快捷键 Win + Shift + 左右方向键，是调整分割比例，这个很好用，左侧可以调整为正好一个网页的宽度。 Win + Shift + 上下，可以调整活动窗口。 Win + Shift + Shift+ Shift + 上下键，可以让活动窗口在不同位置之间跳转。 Win + Shift + Shift+ Shift + Enter，让当前窗口和左侧活动主窗口对调位置很方便。 Win + Shift + Ctrl+ Shift + q，退出bug.n。 Win + Shift + c，关闭当前窗口。 下面是官方文档中的推荐用法 Win + Down ::View_activateWindow(0, + Shift + 1) Activate the next window in the active view. Win + Up::View_activateWindow(0, -1) Activate the previous window in the active view. Win + Shift + Down::View_shuffleWindow(0, + Shift + 1) Move the active window to the next position in the window list of the view. Win + Shift + Up::View_shuffleWindow(0, -1) Move the active window to the previous position in the window list of the view. Win + Shift + Enter::View_shuffleWindow(1) Move the active window to the first position in the window list of the view. You may also move the active window to any other absolute position in the window list by using the first parameter. Win + c::Manager_closeWindow() Close the active window. Win + Shift + d::Window_toggleDecor() Show / Hide the title bar of the active window. Win + Shift + f::View_toggleFloatingWindow() Toggle the floating status of the active window. The floating status effects the tiling of the active window (i. e. dis- / regard it). Win + Ctrl + m::Manager_minimizeWindow() Minimize the active window. This implicitly sets the window to be floating. Win + Shift + m::Manager_moveWindow()Move the active window by key. This implicitly sets the window to be floating. Win + Shift + s::Manager_sizeWindow()Resize the active window by key. This implicitly sets the window to be floating. Win + Shift + x::Manager_maximizeWindow()Move and resize the active window to the size of the work area. This implicitly sets the window to be floating. Win + i::Manager_getWindowInfo()Get information for the active window. The information being id, title, class, process name, style, geometry, tags and floating state. Win + Shift + i::Manager_getWindowList()Get a window list for the active view. The list contains information about the window id, title and class. Alt + Down::View_moveWindow(0, + Shift + 1)Manually move the active window to the next area in the layout. This has only an effect, if dynamic tiling is disabled (Config_dynamicTiling=0). Alt + Up::View_moveWindow(0, -1)Manually move the active window to the previous area in the layout. This has only an effect, if dynamic tiling is disabled (Config_dynamicTiling=0). Alt + Shift + Enter::Manager_maximizeWindow()Move and resize the active window to the size of the work area. This implicitly sets the window to be floating. Alt + &lt;n&gt;::View_moveWindow()Manually move the active window to the nth area in the layout. 配合Chrome的Vimium，可以提高不少效率。 目前我正在研究的是Config.ini的一条规则， Config_rule=WebChat*;.*;;1;0;0;0;0;0; 就是比如像微信电脑版这样的程序，其窗口的最小是一个固定值，如果让他按照普通窗口那样排列，基本什么也看不到，目前代替的方法就是Win+ Shift + c，然后看到新信息，Ctrl+ Shift + Alt+ Shift + w取消息，回复完了，再关闭微信（注：Ctrl+ Shift + Alt+ Shift + w是微信默认快捷键，非bug.n）。 参考资料 平铺式窗口管理器 Official bug.n manual","link":"/2016/01/14/how_to_tile_all_windows_on_windows_10_pc/"},{"title":"如何在GitHub挂上HEXO博客","text":"喜欢追求完美，是FOOLMAN骨子里的倔强 有用的资料http://yanliu.org/2015/08/07/Hexo搭建个人博客/ 在GITHUB上添加SSH Keyhttps://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/ 这里有个坑，不知道是不是因为版本的问题，我看网上很多地方说的地方，实际上位置不对，估计是因为GITHUB改版的原因。 推送到GitHub上http://daimarushi.com/2015/11/29/%E4%BD%BF%E7%94%A8Hexo%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/http://ibruce.info/2013/11/22/hexo-your-blog/ 为GitHub Pages绑定独立域名http://iread.io/2015/09/hexo-guide-4/ 扩展阅读如何迁移原博客程序的数据到HEXO https://hexo.io/zh-cn/docs/migration.html","link":"/2016/03/11/use_hexo_on_github/"},{"title":"从WordPress迁移到Hexo","text":"FOOLMAN喜欢简单的东西，有时候为了达到一个简单目标，却需要经历复杂无比的过程 文章更新 20160310-初次成文 20160704-已经过去了4个月，更新了MAC下的Hexo安装方法 20160808-修改完善mac下的安装办法和步骤 20160902-增加了错误排查以及如何更换HEXO模板的内容 为什么会有这篇文章WordPress确实是个优秀的博客系统，但是却越来越臃肿，平心而论，如果身在墙外，肯定会一直用下去，谁想天天没事瞎折腾呢。然而，WP却变得越来越臃肿，插件总需要升级，功能还要和PHP以及LINUX不停的大叫道，经常的头大。 这两天自己的WordPress博客再次无缘无故打不开了，即便装了Disable Google Font插件也是没有改善，用Chrome的开发者工具也没发现什么不妥，虽然有处女[座]情节的我应该一究到底，但是还是觉得KEEP THINGS SIMPLE比较重要，陷在复杂的事情里面，自己也变得复杂了。 在网上逛久了额，不经意间总会看到一些博客下面写着一句话“由Hexo强力驱动”！当时就心想，这是什么鬼？？不过也没多想。 然而，当这两天WordPress再次无法打开之后，还是决定换个博客系统吧，经过gogole，大概知道Hexo是什么，纯静态博客，一番了解之后，简约不简单，如此概括。 今天在上班的路上我还在想，也许过不了多久，Hexo也会同样变得臃肿，也许就有另外一种更加简单的博客框架出现，不过管他呢，折腾一下没坏处。 先说这个HEXO，其实建立博客的并不是唯一的方案，其他还有Ghost和其一些方案。Hexo只是因为他的简单，简洁，比较流行，大家可以自由选择其他方式搭建自己的静态博客，静态有什么好的？速度飞快！还有呢？这个理由还不够么？ 我喜欢写流水账似的记录，因为我觉得只有自己消化了的东西，写出来的心得，才能是精华，才值得记录。 可能自己写作习惯不好，经常偷懒，很多东西就算记下来了，也是随手扔在印象笔记中，懒得整理了。不过既然有了这个契机，可以适当将笔记中的资料整理一下写成博客。 如何在Windows系统上安装HexoHexo本身就是一个由 Node.js 驱动的框架，N多包（至少我这样认为），可以识别 Markdown 格式，并且转换为HTML页面，这样，就可以借助GitHub或者Coding.ne的Pages服务，来展示站点内容，不但安全性一流，还能利用Github或者Coding.net这些大站的速度，还有一点，免费不操心。 在电脑上要装的，主要是 Git 和 Node.js 这两个工具。 安装GIT去Git for Windows官网下载并安装。 安装Node.js去Node.js官网下载并安装。 注意：初次折腾，尽量使用默认路径，并且避免路径中出现中文字。 安装Hexo上面两个都是软件，下载了即可，我下载的Git版本是2.7.2 64位，Node.js是5.8.0 稳定版，也是64位版本的。 安装好了这两个软件之后，在你的硬盘上，新建一个目录，作为你Hexo博客的仓库，我这里是f:\\Hexo，然后进去这个目录，点右键，选择Git Bash Here 如果你熟悉Windows的CMD工具，那么你对GitBahsh的界面一定不会陌生，这其实是个linux下的命令行工具，因为linux下默认就是这样，可能你会兴奋，也许你会感觉郁闷，不过没办法，硬着头皮，跟着我一步一步做下去吧。 然后，在这个窗口输入下面的命令 1npm install -g hexo-cli #-g表示全局安装 先不解释什么时候npm，先说这句命令，可能会运行很长时间，如果你觉得出错了，可以用CTRL+C来结束，不过更靠谱的，是加一个--verbose参数，变成这样，这样你就可以看到整个安装过程了，这命令对于其他命令也适用。 1npm install -g hexo-cli --verbose 这里分享一个小插曲，我在WIN10系统上安装的，所以遇到了两个WARN信息： 12npm WARN optional Skipping failed optional dependency /browser-sync/chokidar/fsevents: npm WARN notsup Not compatible with your operating system or architecture: fsevents@1.0.8 解释：fsevent是mac osx系统的，所以在windows系统下会遇到这个警告，忽略即可（更新：我后来在MAC上安装的过程中，也看到过类似的WARN，所以。。。谣言不靠谱）。 好了，Hexo安装完成后，使用mkdir folder命令建立一个用来存放hexo的目录，进入该目录，并且输入下面的命令 1Hexo init 注意，如果你不是第一次安装，而是要在其他PC或者MAC上同步之前的环境，跳过上面这句。 然后进入你创建的目录，输入 npm install，让npm安装Hexo依赖环境，就是只装必要的文件，其他Hexo的完整包，还在npm的全局那呢，记得么？这点比较重要哦。 好了，如果你输入Hexo -v查看Hexo版本可以看到结果，说明Hexo安装完毕。 启动Hexo服务器一句话 1Hexo server 或者缩写成Hexo s也一样。然后，你的界面会变成下面这样 这个界面不会再出现提示符$了，因为服务一直运行着，除非你按了CTRL+C。 现在服务已经好了，准备开始写你的一篇博客吧。 第一篇博客继续上面的说，当你的Hexo服务运行之后，那个窗口不要关闭，因为你关闭了，也就等同于CTRL+C关闭了Hexo服务。 如果关闭了Hexo服务，请重新在Hexo目录右键选择Git Hash Here，重新开一个Git窗口。 输入下面的命令 1Hexo new \"你的第一篇博客\" 后面括号里是你的日志的名字，可以是中文或者英文，如果有空格，也没问题。输入这个命令之后，去Hexo目录下，找source目录，里面有一个_post目录，打开就能看到你的日志了，就是一个文本文件。 你可以用任何编辑器编辑这个文件，比如记事本、Notepad++、Sublime Text等等，我之前喜欢用Notepad++，现在转用了Sublime Text 3，因为后者好像作为Markdown标记的编辑器更为方便一些。 这时候，如果你打开浏览器，输入 http://localhost:4000，就可以看到你的博客了。 说起来用Markdown标记写博客，还是有很多需要学习的地方，我刚开始的时候，很简单粗暴，打开这个作业部落的在线Markdown编辑器放在一边，一边参考，一边学习他的标记符号。 Hexo常用命令12345678Hexo help #查看帮助Hexo init #初始化一个目录Hexo new \"postName\" #新建文章，可以缩写为hexo nHexo new page \"pageName\" #新建页面Hexo generate #生成网页，可以在 public 目录查看整个网站的文件，可以缩写为hexo gHexo server #本地预览，'Ctrl+C'关闭，可以缩写为hexo sHexo deploy #部署.deploy目录，可以缩写为hexo dHexo clean #清除缓存，**建议每次执行命令前先清理缓存，每次部署前先删除 `.deploy` 文件夹** 同时Hexo支持命令的组合： 12Hexo d -g #先重新生成博客内容，再部署推送到静态空间Hexo s -g #先重新生成博客内容，再在本地生成服务器，可以进行预览 在OSX下安装Hexo其实，再回头看这个帖子，时间已经过去4个月了，真是有点惭愧了，不过也可以说明，我用Hexo写博客，不知不觉已经这么长时间了。 好了，废话不多说，直接进入正题。 使用Homebrew安装nodeMAC下的使用，绕了很多弯路，从最开始用Node.js的安装包安装Node，到现在使用Homebrew来安装，变化很大。也让我对linux系统越来越有好感。 好了，废话不多说，先从homebrew安装Node.js开始，Node.js自带npm。 1brew install node.js 如果上面的命令错误，说明你还没有在mac下安装过Homebrew，如何安装Homebrew以及常用brew命令，请移步这里 需要注意的是，Hexo的安装位置我是装在了/usr/local/lib/node_modules下，才安装成功的。其实这个位置，我现在还是有点疑惑，因为对那些Link产生的文件，连接的对象还不是很明白。 cd /usr/local/lib/node_modulesnpm install Hexo -no-option 安装Hexo-clinpm安装好之后，那些warn不用理会，直接安装Hexo，命令也是一句话。 1npm install Hexo-cli -g 然后通过命令，Hexo -v，如果看到了hexo的版本号，说明安装成功。 Hexo主题、插件以及其他内容Hexo的安装并不麻烦，基本就是需要Node.js、NPM、GIT这几样东西，在Mac因为是原生linux系统，所以问题不大，而Windows 10也自带bash了，虽然对中文目前支持非常稀烂，但是未来应该有所期待。并且其实Windows下的linux shell也非常多，比如babun，cygwin等，而且上文介绍安装过程中，涉及的Node.js官网安装后，也带了一个bash shell。好了，废话不多说了，继续说hexo使用过程中的一些其他需要注意的问题。 先建立一个目录，然后进去，这里有一点需要说明的是，如果你是第一次使用Hexo写博客，使用命令 1Hexo init foldername #建立的Hexo文件夹名字 然而如果你是为了同步其他电脑上的Hexo博客内容，直接建立一个空目录，并且不要执行 hexo init 操作，否则Hexo会将其初始化，并且无法继续同步其他内容了。 Hexo安装主题上面步骤二选一，然后继续 1234567891011121314git clone https://git.coding.net/tinyvane/Hexo.git foldername #这里更改成你远程hexo仓库的名字cd foldername#让npm安装必要的Hexo组件npm install#安装Hexo-deployer-git ，部署Hexo用npm install Hexo-deployer-git #（可选）安装 Hexo-asset-image 和模板，确认 _config.yml 中 `post_asset_folder:true` 。npm install hexo-asset-image --save#使用submodule的方式添加next主题git submodule add https://github.com/iissnan/Hexo-theme-next themes/next#或者其他主题git submodule add https://github.com/tinyvane2/hexo-theme-hueman.git themes/hueman #https方式git submodule add git@github.com:tinyvane2/hexo-theme-hueman.git themes/hueman #ssh方式，二选一 如果遇到了错误Receiving “fatal: Not a git repository” when attempting to remote add a Git repo，说明当前目录还不是一个由GIT管理的项目，请先使用命令git init .对当前项目进行初始化。 如果要了解更多关于多终端同步Hexo更新博客，请参考我的另外一个帖子，地址在这里。 Hexo 更换主题hexo默认带的主题是landscape，像极了WordPress的默认主题，因此，我非常有冲动要换一个。 有哪些主题可以让你选择？知乎上有一个帖子，统计了很多的高星Hexo主题，详情戳这里 我之前使用的是iissnan的Next主题，目前使用的ppoffice的hueman主题。 安装主题 Next主题 1git clone https://github.com/iissnan/hexo-theme-next themes/next 或者 Hueman主题 1git clone https://github.com/ppoffice/hexo-theme-hueman.git themes/hueman 然后修改站点配置（hexo主目录下的config.yml文件），将theme: landscape修改为theme: hueman或者theme: next 主题生效12hexo clean &amp;&amp; hexo g #清理文件并且生成文件hexo s #本地运行 几个插件1234npm install Hexo-deployer-git #Hexo-deployer-git ，部署Hexo用npm install hexo-asset-image --save #Hexo-asset-image 和模板，确保主题配置文件中`post_asset_folder`选项为`true`npm install hexo-generator-json-content -S #Hueman主题中的insight search（站内搜索）功能必备插件npm install hexo-baidu-url-submit --save #百度链接生产插件 PS: 需要注意的是，hexo-baidu-url-submit和hexo-generator-json-content两个插件如果直接安装，而没有安装相应的主题，会导致hexo错误，而无法正常执行，请注意。 然后浏览器中输入地址localhost:4000就可以看到新主题已经使用上了。 说简单不简单，这里有个坑，如果执行了上面的语句，访问localhost发现主题还是默认的，关掉服务器的那个shell，再重新打开，输入hexo -s debug，然后再次访问localhost:4000，应该就可以看到新主题已经换上了。 好了，装好了基本的hexo文件了，下面的操作，是我自己的个性设置，大家可以不用理会。因为Hexo的主题配置文件(也是_config.yml)，如果操作用submodule的方式，你是没有办法push到原作者的github库的，所以我将其保存在了主项目的 git 库中，方便保存主题配置 12345cp &lt;Hexo folder&gt;/themes/next/_config.yml &lt;Hexo folder&gt;/_config_theme.ymlcd themes/nextgit add .git commit -m 'overwrite the _config.yml files from Hexo repo'cd ../.. 如果要了解更多关于多终端同步Hexo更新博客，请参考我的另外一个帖子，地址在这里。 Hexo 更换主题hexo默认带的主题是landscape，像极了WordPress的默认主题，因此，我非常有冲动要换一个。 有哪些主题可以让你选择？我还是在知乎上看到了帖子，详情请戳这里 我这里演示的iissnan的hexo-theme-next主题。至于其他的，自己选吧。 将主题从远程下载到本地开Git，在命令行的地方，输入 1git clone https://github.com/iissnan/hexo-theme-next themes/next 后面是你存放主题的默认目录，themes是默认的主题文件夹。 修改配置你的默认hexo目录下面，有一个文件叫_config.yml，打开后，会看到一行theme: landscape，注释掉，加上一句 theme: next，这个next要和你themes目录下新下的主题保存的目录名称一致。 然后，执行下面的语句 hexo clean &amp;&amp; hexo g clean是清理，g是重新生成，然后就可以看到新主题已经使用上了。 说简单不简单，这里有个坑，如果执行了上面的语句，访问localhost发现主题还是默认的，关掉服务器的那个git，重开git，输入hexo -s debug，然后再次访问localhost:4000，应该就可以看到新主题已经换上了。 参考资料 Sublime Text 3的使用 如何使用GitHub Pages免费上传你的Hexo博客 代码高亮使用说法 叶阳栩宁的博客","link":"/2016/03/10/from_wordpress_to_Hexo/"},{"title":"网络通信加密算法介绍及C#实现","text":"本文主要在说什么？最近在做Winform程序和PHP的交互，中间接触了不少加密解密的问题，简单做个总结。 #几个概念 散列加密，MD5DES数据加密标准（DES）是美国的一种由来已久的加密标准，它使用对称密钥加密法，并于1981年被ANSI组织规范为ANSI X.3.92。DES使用56位密钥和密码块的方法，而在密码块的方法中，文本被分成64位大小的文本块然后再进行加密。 3DES3DES（或称为Triple DES）是三重数据加密算法（TDEA，Triple Data Encryption Algorithm）块密码的通称。它相当于是对每个数据块应用三次DES加密算法。由于计算机运算能力的增强，原版DES密码的密钥长度变得容易被暴力破解；3DES即是设计用来提供一种相对简单的方法，即通过增加DES的密钥长度来避免类似的攻击，而不是设计一种全新的块密码算法。 3DES是DES加密算法的一种模式，它使用3条56位的密钥对 3DES 3DES 数据进行三次加密。比起前文提到的DES，3DES更为安全。","link":"/2016/03/10/the_encryption_algorithms_and_implementation/"},{"title":"如何在OSX上编译C#程序","text":"FOOLMAN，“生活在童话世界中的理想主义者”–在一切开始之前 文章更新20160311-初次成文20170328-更新了C# .net core 1.1版本，有一些流程改变了 为什么会有这篇文章因为确实喜欢MAC电脑的跨平台特性，而因为自己是一名c#业余爱好者，所以发现自己除了Windows平台，到了mac这边好像就没啥事情可以做了，因此对.net core的跨平台粉开心。 参考资料 http://www.cnblogs.com/n-pei/p/4263148.html","link":"/2016/03/11/how_to_comple_c_sharp_code_on_osx/"},{"title":"Win10 64位操作系统无法开启BONJOR服务","text":"FOOLMAN一直不知道自己想要的是什么，无意中才发现，自己想要的，却又无法与人说 起因最近看了微软BUILD 2016, 第二天微软宣布微软之前收购的款平台开发工具xamarin社区版免费了，这无疑对之前使用C#.NET的程序员来说是一个非常重大的利好，虽然xamarin使用的WRAPPER技术，封装了安卓和IOS底层的API而已，但是对于我这种程序员爱好者来说，使用C#无疑大幅度降低了跨平台开发的难度。因此，第二天就赶紧去下载了VS2015 UPDATE2。 xamarin这东西好像并不是像开发个WINFORM那样直接建立一个项目就搞定那么简单，而是作为一个单独的插件形式，不过微软说过要开发者不离开VS就能跨平台写程序，想想应该也不会差太多。废话不多说了，继续。 探索过程UPDATE2的安装包已经到了7G的大小，而且直接下载UPDATE2的安装程序会卡死在启动界面，无奈只好先卸载了UPDATE1，然后再安装。 不过这样折腾下来，发现自己的C盘确实大小有点吃紧，本来想用ADDS（Acronis Disk Director Suite）把C盘空间腾出来一些，但是发现11版和12版的安装和破解好像非常的麻烦，找出来了以前用过的10，但是安装之后，在第一次重启的时候就会出现一个Abnormal的错误，估计ADDS 10对WIN10的兼容性并不好，毕竟ADDS10出来的时候，还没WIN10呢，只好就此作罢，等到下一次安装11或者12的时候，再来写帖子了。 安装好了UPDATE2之后，从xamarin的官方网站下载了安装包，一看才2M多，明显只是个引导程序，启动安装之后，发现不成功，而是弹出了下面的界面 程序要求单独下载JAVA SDK, ANDROID SDK以及xamarin，没办法一个一个装吧。 前两个的安装还算顺利，但是到了xamarin的时候，遇到了一个很麻烦的问题。 GOOGLE了一下，发现有人反应在WINDOWS 10 64位操作系统下面，BONJOUR服务不被支持？WTF!什么鬼，这都什么年代了，APPLE连这种问题都搞不定，那么让人们如何在WIN10+8G内存下安装xamarin？不是开玩笑吧。 去SERVICES.MSC里，发现并没有看到熟悉的BONJOR服务项目，发现网上有人说，通过安装ITOOLS的录屏大师功能，会自动安装BONJOUR服务，但是我要说的是：然并卵！！！录屏大师确实说我系统缺少必备组件，也下载并且安装了，但是重启会后，依然没有BONJOUR的影子，WTF!AGAIN! 解决办法淘宝上找了个修电脑的大神，远程指导我搞定了。卸载掉所有apple相关的程序，并且从apple.com重新下载itunes就好了，哈哈，真是费尽周折。","link":"/2016/04/04/how_to_solve_bonjor_service_on_windows_10_64bit/"},{"title":"让Markdown的书写更加顺畅的技巧","text":"喜欢键盘的敲击声，每一下都掷地有声，正中了那句话，念念不忘，必有回响。 Sublime Text 3安装Sublime Text 3我这里使用的绿色版本，已经默认被破解了，不需要输入序列号。至于为什么选择绿色版，主要是因为携带方便，我自己使用一块SSD移动硬盘来同步自己的工作，使用FreeFileSync来做具体的同步工作，坚持了一年多了，效果还不错。 绿色版下载地址大家自己GOOGLE就好。 安装MARKDOWN支持插件默认Sublime Text是不支持Markdown语法高亮和预览的，对于万能的Sublime Text，这点事情一定有插件能解决。 Sublime Text 3 安装Package Control，挺不能理解为什么不默认含在app里快捷键ctrl+`或者 View &gt; Show Console 菜单打开控制台 12345import urllib.request,os;pf='Package Control.sublime-package';ipp=sublime.installed_packages_path();urllib.request.install_opener(urllib.request.build_opener(urllib.request.ProxyHandler()));open(os.path.join(ipp,pf),'wb').write(urllib.request.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read()) 上面这几行是需要在控制台里一行一行输入的，Sublime官方提供过了一个一行的命令行方式，地址见这里，里面对版本3和2有不同的命令，再次不多说了。因为官方建议这条命令可能会随时更新，所以不建议其他网站转载这条命令。 安装完成自后，会看到下面的图 如果网络条件不好，安装失败的话，只能采取下载安装包的方式 点击 Preferences，然后选择 Browse Packages…。 进入上一级目录，然后进入 Installed Packages 目录。 在这里下载 Package Control.sublime-package，然后复制到该目录下。 重启 Sublime Text。 安好重启后，用万能快捷键Ctrl+Shift+P，调出菜单，输入pcip， 选择Package Control: Install Package，会出现下面这样一个界面 在这里输入omnimark就能看到omnimarkdown插件，回车安装，重启Sublime即可。 OmniMarkdown插件，可以通过在浏览器中实时预览输入的MARKDOWN文档效果。 快捷键（MAC）Command + Option + O: 在浏览器中预览Command + Option + X: 导出HTML快捷键（PC）Ctrl + Alt + O: 在浏览器中预览Ctrl + Alt + X: 导出HTML 如何舒适的插入图片如果你用了一段时间，你会发现用![]()的方式插入的图片，和生成之后的网页总是很多别扭。在这里推荐一个hexo-asset-image库 hexo-asset-image的安装首先确认 _config.yml 中有 post_asset_folder:true 。 在 hexo 目录，执行 1npm install https://github.com/xcodebuild/hexo-asset-image --save hexo-asset-image的使用假设在 MacGesture2-Publish├── apppicker.jpg├── logo.jpg└── rules.jpgMacGesture2-Publish.md这样的目录结构（目录名和文章名一致），只要使用 ![logo](logo.jpg) 就可以插入图片。生成的结构为 public/2015/10/18/MacGesture2-Publish├── apppicker.jpg├── index.html├── logo.jpg└── rules.jpg同时，生成的 html 是 1&lt;img src=\"/2015/10/18/MacGesture2-Publish/logo.jpg\" alt=\"logo\"&gt; 而不是愚蠢的 1&lt;img src=\"MacGesture2-Publish/logo.jpg\" alt=\"logo\"&gt; 通过这个改动，图片就可以直接保存在和MD文件同一个目录下， 并且，在MD编辑中，可以依然使用之前的格式来插入图片 不过这个库有一个唯一的问题，就是在http://localhost:4000预览的时候是正常的，但是使用Sublime配合OmniMarkdown插件的实时预览，图片就不正常了。没办法，暂时只能这样了。 其他工具离线书写Markdown文档Cmd Markdown 还不错的一个Windows平台下的Mark Down 语言编辑器，支持同步文章到GITHUB或者CODING等托管空间 在线Markdown工具 https://stackedit.io https://www.zybuluo.com/mdeditor 比较推荐，有时候忘记语法了，打开这个网页就能很直观的参考一下。 在iTerm里使用sublime一句话 1alias subl='open -a \"Sublime Text\"' 这样，在iTerm中就可以使用subl，愉快的调用sublime来进行编辑文件了。 参考资料 http://blog.sunnyxx.com/2014/03/16/sublime_text_markdown/ https://github.com/CodeFalling/hexo-asset-image","link":"/2016/03/11/the_tips_makes_markdown_writing_happier/"},{"title":"安装HEXO遇到的各种错误","text":"文章更新 20160406-初稿 20160517-加入hexo s生成错误 Hexo is running at http://0.0.0.0:4000/最近几次在自己的PC上，运行hexo s后一切正常，但是进入浏览器里面输入localhost:4000一片空白。 搜索了一下，排在搜索引擎前面的答案没啥用。正确的原因是因为4000端口被占用了，一般谁会占用呢，目前来看是被Foxit福昕浏览器占用了。 解决办法很简单，Windows平台下CTRL+R，运行cmd，然后通过命令netstat -ano |findstr 4000查看端口的占用情况。 红色框中的数字，是占用了4000端口的线程PID，通过tasklist命令，就可以查找出来，到底这个PID对应的是哪个程序了。在cmd中输入命令tasklist | findstr 2956，(这里用2956举例，查找其他PID方法一样)。 可以看到EXE对应的程序名字是FoxitProtect.exe，一眼就能知道是福昕浏览器的保护进程。 关闭CMD窗口，再次运行CTRL+R，输入Services.msc进入服务（通过控制面板进入服务是一样的）。 把它关掉，不自动启动。 这样，再次cmd执行netstat -ano | findstr 4000的时候，就会发现没有进程占用了，可以正大光明的hexo s了。 PS: 如果在服务或者任务管理器中都找不到该程序，手动杀死即可。 命令如下： 1taskkill -PID &lt;进程号&gt; -F //强制关闭某个进程 Hexo g的时候遇到Warn: No layout 因为缺少模板，进入Hexo目录，执行 1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 即可，不过要看看_config.yml文件里模板指定和下载的主题是否一致。 ERROR Deployer not found: git这个问题也是最近折腾的时候才发现的，我就不说具体怎么弄明白了，直接上方法 确定你的_config.yml下deploy : 后面，有一个半角空格 1234deploy: #这个空格，就是需要在前面这句话后的冒号的后面，yml语法问题，变态 type: git repo: git@github.com:&lt;your github username&gt;/&lt;your github username&gt;.github.io.git branch: master 如果还报错，应该就是没有装hexo-deployer-git。怎么安装： 1$ npm install hexo-deployer-git --save 然后再： 1$ hexo deploy 好了 Permission denied (publickey).在部署HEXO到GITHUB的时候，才会出现这个提示，我的博客是GITHUB和CODING.NET两个网站一起部署的，CODING.NET并不会提示这个错误，而是直接弹出对话框让你输入用户名和密码。 遇到这个错误，是因为GITHUB只允许添加本电脑的SSH KEY到GITHUB的网站管理设置，让它记住，你才能这样部署博客。 解决步骤 配置SSh key:首先我们需要检查你电脑上现有的ssh key： $ cd ~/.ssh如果提示：“No such file or directory” 说明你是第一次使用git。如果没有提示，也不一定说明你有key了，打开这个目录看看，比如我当时曾经部署过，后来不知道为什么自己又把key文件删掉了。对于windows pc用户，这个.ssh目录，一般在c:\\users\\你的用户名目录下面。 生成新的SSH Key：$ ssh-keygen -t rsa -C “you@youremail.com“注意：Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):（回车就好），Enter passphrase (empty for no passphrase):（回车，不需要输入密码）Enter same passphrase again:（回车不需要输入密码）因为Hexo的自动部署如果有密码的话会部署失败 当出现如图所示的时候就是成功了注：忽略我在Enter file in which to save the key(/Users/your_user_directory/.ssh/id_rsa):的 ~ 直接回车保存在默认路径。 添加SSH Key到GitHub在本机设置SSH Key之后，需要添加到GitHub上，以完成SSH链接的设置。 $ cd ~/.ssh/ &amp;&amp; lscat可以看到此目录下的文件：id_rsa id_rsa.pub $ cat id_rsa.pub如图所示：将文件内容全部复制下来 登陆GitHub官网: https://github.com/settings/ssh 进行添加 SSH Keys导航: Account Settings —&gt; SSH keys —&gt; Add SSH keys如图所示： 测试是否成功$ ssh -vT git@github.com如果是以下提示：“Hi tinyvane! You’ve successfully authenticated, but GitHub does not provide shell access.”证明你配置成功了。 设置用户信息$ git config –global user.name “tinyvane” #GitHub用户名$ git config –global user.email “tinyvane@gmail.com“ #填写自己的邮箱 至此配置GitHub就已经完成了 hexo s 的时候遇到Unhandled rejection Error遇到这个错误的时候比较奇怪，因为好像是莫名就出现的，google了一下，方法好像是因为主题更新了，但是npm也同样需要更新，或者反过来？我自己也没有特别明白，方法在这里 反正我是先通过rm -rf themes/next，然后重新 git submodule add https://github.com/iissnan/hexo-theme-next themes/next，解决的。 再次hexo s，顺利解决。 git add fatal: Pathspec is in submodule当使用了上面的方式添加主题的时候，第一次总是需要修改一下主题下面的_config.yml文件的，但是当用git status查看的时候，发现themes/next被修改了，通过git add themes/next/_config.yml会遇到错误：git add fatal: Pathspec is in submodule 如下图所示： 这个错误是因为 _config.yml 是位于 submodule 下的，不能在当前仓库下，提交 submodule 的文件更新，解决办法的出处在这里。 其实办法很简单，就是进入到 submodule，然后 git add . 就可以了 12345cd themes/nextgit add _config.ymlgit commit -m 'update theme config'cd ..cd .. 两个cd就退回到了主体目录下，然后再次用git status查看的时候，会发现依然错误依旧，但是不要担心，再次执行git add themes/next，就可以顺利通过了。O YEAH~ 具体过程截图见下方： 有一篇文章（文章地址），讨论了submodule的坑的问题，看了一下，还不是很深入，放在这里，下次再继续学习。 参考资料","link":"/2016/04/06/the_error_met_during_the_installation_of_hexo/"},{"title":"北京联通光纤宽带提速100m脚本","text":"文章更新20160412-文章第一次发布20160509-修改一些小错误 这个东西能干什么？这个脚本是用来吧北京联通光纤宽带20m或者50m宽带变成100m用的。不过使用的门槛还是有一点的，普通的家用路由器是不行的，需要OpenWRT路由器才可以，并且需要有一定的动手能力。 脚本来源这个是参考了某运维大神的脚本（运维大神见文章末尾链接），我在自己的路由器上，发现经常会卡在开始的地方，经过了一个多月的郁闷，终于发现是采用cat /dev/urandom的时候，会卡住。所以采用了新的方式来生成随机的MAC和字符串，详细可以看脚本的相关语句。 那么如何使用呢 使用ssh登入你的OpenWRT路由器 将这个wk.sh放在/root目录下 给脚本添加可执行权限 #chmod +x /root/wk.sh crontab -e，在任务里添加一句0,7,13,19,26,30,34,37,47,57 * * * * source /root/wk.sh 重启crontab #/etc/init.d/crontab restart （可选）脚本里很多地方都有&gt;&gt; /tmp/out2.txt，这是我为了方便查看脚本运行状态自己写的一个输出文件，要不要影响不大。如果需要，就再创建个out2.txt就可以了 #touch /tmp/out2.txt。 实现原理北京联通宽带每个月给一般用户10个小时提速到100m的体验时常，如果用WireShark分析一下数据，就能知道，其实就是利用本机向北京联通的某ip地址提交一次提速申请，抓包分析一下，其中包括的参数主要有几个，分别是本机的mac地址、ip地址、加速round数、还有一些其他的参数，具体详见脚本，下载地址在文章末尾。 但是10个小时实在是不太够，所以利用本机模拟提交并且循环起来，就可以实现提速了，mac地址和ip地址可以自己随便写，每次都不一样就可以了。 再次声明，本研究的初衷并不是逃避缴费，而是出于学习和交流的目的！ 按照这样分析，用户如果直接浏览器里，输入模拟构造出来的参数，应该也可以实现？我没有试验，如果哪位用户试验了，希望留言给我。 脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#!/bin/shset -xrefr() { while : do cdt=`date \"+%Y-%m-%d %H:%M:%S\"` echo \"${cdt} refr!\" &gt;&gt; /tmp/out2.txt acc=100000000000 mac=$(dd bs=1 count=6 if=/dev/random 2&gt;/dev/null |hexdump -v -e '/1 \"%02X-\"' | head -c17) reqsn=00TF$(date '+%Y%m%d%H%M')009262 comp=BFEBFBFF$(dd bs=1 count=9 if=/dev/random 2&gt;/dev/null |hexdump -v -e '/1 \"%1X\"') inf=$(/usr/bin/wget -t3 --timeout=30 -O - \"http://bj.wokuan.cn/web/startenrequest.php?ComputerMac=${mac}&amp;ADSLTxt=${acc}&amp;Type=3&amp;reqsn=${reqsn}&amp;oem=00&amp;ComputerId=${comp}\" 2&gt;&gt;/dev/null | grep 'id=\"webcode\"') cdt=`date \"+%Y-%m-%d %H:%M:%S\"` echo \"${cdt} ${inf}\" &gt;&gt; /tmp/out2.txt if [ -n \"$inf\" ] then _acc=$(echo -n \"$inf\" | sed 's#.*&amp;cn=\\([^&amp;]\\+\\)&amp;.*#\\1#g') _rnd=$(echo -n \"$inf\" | sed 's#.*&amp;random=\\([^&amp;&lt;]\\+\\)[&amp;&lt;].*#\\1#g') _gus=$(echo -n \"$inf\" | sed 's#.*&amp;gus=\\([^&amp;]\\+\\)&amp;.*#\\1#g') _old=$(echo -n \"$inf\" | sed 's#.*&amp;old=\\([^&amp;]\\+\\)&amp;.*#\\1#g') _stu=$(echo -n \"$inf\" | sed 's#.*&amp;stu=\\([^&amp;]\\+\\)&amp;.*#\\1#g') cdt=`date \"+%Y-%m-%d %H:%M:%S\"` echo \"${cdt} good, got status\" &gt;&gt; /tmp/out2.txt break fi cdt=`date \"+%Y-%m-%d %H:%M:%S\"` echo \"${cdt} not get status! Again!\" &gt;&gt; /tmp/out2.txt sleep 10 done} prt() { echo \"prt\" &gt;&gt; /tmp/out2.txt echo \"_acc: $_acc\" echo \"_rnd: $_rnd\" echo \"_gus: $_gus\" echo \"_old: $_old\" echo \"_stu: $_stu\"} stop() { echo \"stop\" &gt;&gt; /tmp/out2.txt wget -O - \"http://bj.wokuan.cn/web/lowerspeed.php?ContractNo=${_acc}&amp;round=${_rnd}\" &gt; /dev/null 2&gt;&amp;1 cdt=`date \"+%Y-%m-%d %H:%M:%S\"` echo \"${cdt} speed is 20m now!\" &gt;&gt; /tmp/out2.txt} boo() { echo \"boo\" &gt;&gt; /tmp/out2.txt wget -O - \"http://bj.wokuan.cn/web/improvespeed.php?ContractNo=${_acc}&amp;up=${_gus}&amp;old=${_old}&amp;round=${_rnd}\" &gt; /dev/null 2&gt;&amp;1}refrprtif [ \"$_stu\" = 0 ]then breakelif [ \"$_stu\" = 1 ]then echo \"100m now, good but we need to slow to 20m and then boo!\" &gt;&gt; /tmp/out2.txt stop breakelse breakfirefrprtwhile :doif [ \"$_stu\" = 1 ]then cdt=`date \"+%Y-%m-%d %H:%M:%S\"` echo \"${cdt} speed is 100m! all good!\" &gt;&gt; /tmp/out2.txt echo \"${cdt} Game End!\" &gt;&gt; /tmp/out2.txt breakelif [ \"$_stu\" = 0 ]then cdt=`date \"+%Y-%m-%d %H:%M:%S\"` echo \"${cdt} is still 20m, try again!\" &gt;&gt; /tmp/out2.txt refr prt boo refr prt sleep 18else cdt=`date \"+%Y-%m-%d %H:%M:%S\"` echo \"${cdt} not sure how fast is now. Acquiring...\" &gt;&gt; /tmp/out2.txt refr prt sleep 19fidone 脚本下载加速脚本wk.sh 最新消息北京联通联合优酷土豆最近开展了30元即可得到优酷土豆路由器的活动，我自己也申请了一个，还能免费从20M宽带免费升级到40M，小伙伴们可以去试试哦，感觉还不错。 参考资料运维大神的地址","link":"/2016/04/08/the_script_used_to_speed_up_beijing_unicom_fibre_internet_to_100m/"},{"title":"Coding.net和Github两地部署Hexo博客","text":"文章更新 20160408-初次成文 20161201-文章内容调整，把hexo d卡住的具体内容，改而增加了到其他文章的链接 为什么会有这篇文章github在墙外，虽然目前速度不错，但是不好说哪天就访问不了了，那国内用户咋办呢，所以就想把hexo同时推到github和国内的托管平台，目前选了码市（coding.net），因为博客的Markdown源文件都存在了coding.net的私有仓库中，所以觉得顺手就不想折腾了。 实现过程修改_config.yml这个地方的修改较为简单，如果你之前已经部署在了github，加一行部署到coding.net的就可以了，但是要注意格式，因为yml语法要求非常严格。 12345deploy: type: git repo: git@codingnet:wuliaole/wuliaole.git branch: master message: \"Coding.net with wuliaole pushlished succeed! Congrats!\" 具体修改见下图。 在coding.net建立公开项目用来存储静态文件 在coding.net建立公开项目用来存储静态文件 在Source目录下生成Staticfile文件12cd sourcetouch Staticfile 注意文件名的大小写不要错。 开启coding.net的pages服务 因为开启演示，还需要web hook并且每天收费0.01元？并且演示方式无法绑定域名，只能使用项目名称.coding.net的方式，因为我采用了pages的方式。 找到Coding.net左侧的代码-PAGES服务，右侧选择分支(一般是MASTER)，点击开启，等几秒钟就好了。 几个错误github上传时出现error: src refspec master does not match any这是因为当前仓库下没有文件，git add .添加一些文件再commit再push就好了。 public key denied使用ssh -vT git@github.com以及ssh -vT git@coding.net 测试是否可以正确连上远程仓库，如果不行，参考下面的解决办法 hexo d卡住这个问题我搜索了一下，好像没有人遇到，我等了几分钟，ctrl+c（mac下用control+c）结束了，然后又一次depoly了之后去撸了一盘，发现错误还是权限的问题。 这个地方当时挺奇怪的，因为之前往coding.net远程仓库单独push的时候，都是手动输入账号和密码的，没有把ssh key添加到coding的设置里去，只单独添加到了github中，然后，这里就遇到问题了，只能以为是当推送多个git的时候，不能一个输入账号密码，一个用ssh key认证，必须要把本机的ssh key填写到多个git的设置中才可以。 所以，这里要再次将本地生成的sshkey添加到两个托管仓库中去（分别是coding.ent和github.com）。 下面用一张图片解释如何生成sshkey。 然后，在c盘（windows环境）下的用户目录下，这里是c:\\users\\tinyv\\.ssh(tinyv是我的账户名，这里要换成你的账户名)，会看到有了known_hosts，以及id_rsa、id_rsa.pub等三个文件，将id_rsa.pub公钥的内容，复制黏贴到coding.net和github中去即可。 参考资料","link":"/2016/04/08/how_to_deploy_hexo_on_both_coding_and_github/"},{"title":"我的第一个electon程序","text":"FOOLMAN的爸爸曾经说过读书要先读厚了，然后再读薄了，这么多年来，虽然记得爸爸只说过一两次，但是却久久不能忘记。 为什么要弄这个东西这是偶尔一次在v2ex上看到有人提问，用什么技术可以实现最快的全平台覆盖，回复里有人说道用react+electon覆盖mac/pc和unix，用啥啥啥来覆盖Ios和安卓，因为天天效率特别低，代码敲得实在没啥动力，所以就想多接触接触新玩具。 准备工作这里主要是参考网上的一些前辈写过的资料，按照自己的实践汇总了一下，算不上什么分享，顶多算个记录。 1$git clone https;//github.com/xxx 参考资料 test","link":"/2016/04/08/my_first_electon_program/"},{"title":"Easy Watermark使用说明","text":"我们不能防止别人抄袭帖子，只能留一点优雅的标记，增加下别人抄袭的成本，但是，从另外一个方面，本来知识是抄不来的，如果你的图片是你的原创，加上个水印，也是顺理成章的事情。这里我介绍我的博客使用的水印程序，给wordpress图片加水印的3款插件，这是国内一个博主的介绍帖子，无奈我去搜索这几个插件的时候，安装量太少了，因为我是懒人，担心开发者维护一段时间不管了，所以就选了Easy Watermark这款插件，安装量很大了，而且看评论里说已经用了3-4年了，决定，就是他了。 首先是在WORDPRESS的插件市场里，搜索Easy Watermark，安装。 然后，激活插件之后，进入设置 *» Easy Watermark *进行配置。 注意的是，Easy watermark的设置有3个选项卡（Tab），在General选项卡里，第一项 Add watermark when uploading images是必须选的项目，就是说上传图片后，自动添加水印。但是别着急，没有水印图片加什么呢？ 所以，需要进入第二个选项卡Image，去添加一张PNG或者GIF的图片（背景透明，不透明的水印，总觉得效果不是特别好）。然后可以选择图片的透明度，位置，以及是否缩放你的水印图片。 回来说第一个General选项卡，在Image Sizes里，默认选了几项应该满足你的要求，但是有一点，如果你希望把文章里的Featured image也加上水印，就要勾选post-thumbnail这一项。 恩，然后还有比较重要的一点，插件可以保存你上传的原始图片，所以那个Backup选项，如果你服务器空间比较富裕，最好也一起勾上。 If you don’t want to add an image, but would rather add a text as watermark, then you need to click on the Text tab. You can enter the text you want to be displayed as watermark, choose font, font-size, opacity, and positioning of the watermark text. 也许制作一个水印图片对你比较麻烦，或者你压根不想用图片水印，那么就选择文字水印也是一个不错的选择。在第三个选项卡Text里面，你可以设置文字的字体，字号，透明度，以及位置等。 下面要说的就是这个插件比较牛X的地方了，批量去除或者添加水印！ 如何批量添加水印Adding Watermark to Your Old Images in WordPress如果你希望给安装插件之前的所有图片批量添加水印图片的话，进入 媒体 *» Easy Watermark *然后选择 Add watermark to all image 按钮。 提醒，这个批量添加水印的过程不可逆，所以，最好先备份好了整个网站的图片，然后再做这一步的操作。 如何手动添加水印首先进入 设置 » Easy Watermark，确定没有勾选 Automatically add watermark to images &nbsp; 然后进入 多媒体 » 媒体库 ，记得勾选左上角的图片显示方式，需要用列表的方式，否则是看不到如图上面的单独添加水印的选项的。 参考资料http://www.wpbeginner.com/plugins/how-to-automatically-add-watermark-to-images-in-wordpress/ &nbsp;","link":"/2015/12/09/the_introduction_of_easy_watermark/"},{"title":"日本购买的mac电脑改键成习惯的英文键位","text":"为什么会有这个文章之前去日本旅游，跑到商场里，看到苹果店里的mbp价格比国内要便宜1000多，直接就付款买了一台，回国后拆机就傻眼了，我靠，键盘上这都是啥玩意！ 键盘上英文字母的位置变化不大，主要是键盘上的数字键上方的符号和其他符号键，这些和国内习惯用的键盘区别很大。听朋友说，日本键位输入日文很方便，可惜我虽然想学日文，但是一直没有开始，所以好用归好用，和我无关啊。用了小半年，虽然已经习惯了直接输入@(日文键盘上直接使用p键右侧的按键直接输入@符号)，但是发现在写代码或者快速输入文字的时候，比如最近开始用MD写HEXO的博客，基本没有啥排版的纠结，全部时间都在码字，差别还是挺大的。比如，我在pc和mac电脑上使用git同步博客，电脑切换之后，输入的键位完全变成了另外一个世界。ORZ… 通过这两张图片，就可以看到主要是标点符号的位置差别比较大，我之前看了很多前人的文章，但是效果都不是很理想，目前主要想实现的，就是基本键位和国际键盘想同，为了实现这个目标，我在自己的日语键盘上，贴下了一些sticker来挡住后面的字，先上效果图。 这是初步的理想图，CAPS COMMAND 和 CONTROL 三个键可以通过系统偏好进行修改，但是其他键，就只能通过第三方软件的方式了。 失败方案：修改键盘为英国键盘在系统偏好设置-输入源里面，可以添加“英国键盘”来实现改键盘成为熟悉的国际键盘。 这里有点奇怪，为啥美国的键盘，和日本键盘的”输入源”键位一样呢？ 这个方案本来挺好的，但是发现，一旦切换到搜狗的输入法，键位就又变回来了。 网上的一个帖子“MAC日文键盘绮丽丽改键”里面说QQ输入法作为第三方输入法可以实现“输入源”的选择，可是在点选了QQ拼音输入法后，右侧是空的，和搜狗一样样子。所以这个方法也不可行了。 下面就开始上本文的重头软件了，Karbiner。 KarabinerKarabiner在改名之前叫KeyboardRemap4Mac（好像是，这会没去百度），就是用来更改键盘映射的专用软件，并且是免费的良心软件。 在网上搜索改键的时候，发现了这个软件，确实功能强大，强大到我看着这个软件的设置都发憷！这个软件，结合系统设置，可以实现更改键位，如果你可以盲打符号和数字键上的符号，那么这个软件的效果比较理想，然而，由于我在mac也安装了搜狗输入法，而在搜狗输入法是没有办法更改”输入源“的，因此，就算在英文输入输入状态下实现了键位更改，但是一旦切换到了搜狗中文输入法之下，又变成了日文键位，简直是让人操碎了心，有一种蛋疼的感觉。 安装Karabiner安装过后，Karabiner会自动常驻内存并在MAC上方的任务栏中多出一个图标，点开之后，会发现里面有Preferences 、Default Profiles以及Launch EverntViewer等选项，其他都能看得出来，这里重点要说一下EventViewer，这个是最重要的功能之一，可以查看所有按键对应的“键盘码”，这样软件才知道你要把某个按键修改成其他的哪个按键。 在软件里，每按下一个键，表格里都会出现相应的键的信息，注意我们这里需要的KeyCode不在『code』栏中，而是『misc』栏中显示的内容。如上图显示，左ctrl的代码就是CONTROL_L。我按个键按了一遍，然后把上面那个日本键盘位打印了出来，直接在每个键位上标记了KeyCode。 怎么样？是不是看着毫无违和感？经过挨个测试发现，F11和F12直接引起了系统时间，在EVENTVIEWER里没有捕捉到，其他按键都成功捕捉到了KEYCODE，在日文键盘上，有几个KEYCODE是JIS_开头的，都是日文键盘才特有的按键，这些按键，正好给自己订制快捷键留下了很大的余地。这几个键分别是 JIS_EISUU（空格键左侧）、JIS_KANA（空格键右侧）、JIS_YEN（删除键旁边）、JIS_UNDERSCORE（右SHIFT旁边）。 Karabiner private.xml设置方法先列出一个简单的private代码。 123456789101112&lt;?xml version=\"1.0\"?&gt;&lt;root&gt; &lt;item&gt; &lt;name&gt;Name of Setting&lt;/name&gt; &lt;appendix&gt;Optional Description of Setting&lt;/appendix&gt; &lt;identifier&gt;Unique Identifier of Setting&lt;/identifier&gt; &lt;autogen&gt;Behavior Definition&lt;/autogen&gt; &lt;autogen&gt;Behavior Definition&lt;/autogen&gt; &lt;/item&gt; &lt;item&gt;...&lt;/item&gt; &lt;item&gt;...&lt;/item&gt;&lt;/root&gt; 这是基本的格式，如果想增加一个新的项目，直接增加新的&lt;item&gt;...&lt;/item&gt;即可。 其中的name是必须的，appendix不是必须的，identifier貌似需要用private.开头，后面接一个变量名。autogen用来描述定义的行动。 比较复杂的是autogen部分，其中需要定义原功能按键以及新按键的功能，比较详细的配置，大家可以看Karabiner的官方教程，地址在这里 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165&lt;?xml version=\"1.0\"?&gt;&lt;root&gt; &lt;item&gt; &lt;name&gt;* to \"&lt;/name&gt; &lt;identifier&gt;private.TIMEStoQUOTE&lt;/identifier&gt; &lt;autogen&gt; __KeyToKey__ KeyCode::QUOTE, MODIFIERFLAG_EITHER_LEFT_OR_RIGHT_SHIFT, KeyCode::2, MODIFIERFLAG_EITHER_LEFT_OR_RIGHT_SHIFT &lt;/autogen&gt; &lt;/item&gt; &lt;item&gt; &lt;name&gt;SHIFT+2 to @&lt;/name&gt; &lt;identifier&gt;private.shift22at&lt;/identifier&gt; &lt;autogen&gt; __KeyToKey__ KeyCode::2, MODIFIERFLAG_EITHER_LEFT_OR_RIGHT_SHIFT, KeyCode::BRACKET_LEFT &lt;/autogen&gt; &lt;/item&gt; &lt;item&gt; &lt;name&gt;SHIFT+6 to ^&lt;/name&gt; &lt;identifier&gt;private.shift6toJIECHENG&lt;/identifier&gt; &lt;autogen&gt; __KeyToKey__ KeyCode::6, MODIFIERFLAG_EITHER_LEFT_OR_RIGHT_SHIFT, KeyCode::EQUAL &lt;/autogen&gt; &lt;/item&gt; &lt;item&gt; &lt;name&gt;SHIFT+7 to &amp;&lt;/name&gt; &lt;identifier&gt;private.shift7toand&lt;/identifier&gt; &lt;autogen&gt; __KeyToKey__ KeyCode::7, MODIFIERFLAG_EITHER_LEFT_OR_RIGHT_SHIFT, KeyCode::6, MODIFIERFLAG_EITHER_LEFT_OR_RIGHT_SHIFT &lt;/autogen&gt; &lt;/item&gt; &lt;item&gt; &lt;name&gt;SHIFT+8 to *&lt;/name&gt; &lt;identifier&gt;private.shift8totimes&lt;/identifier&gt; &lt;autogen&gt; __KeyToKey__ KeyCode::8, MODIFIERFLAG_EITHER_LEFT_OR_RIGHT_SHIFT, KeyCode::QUOTE, MODIFIERFLAG_EITHER_LEFT_OR_RIGHT_SHIFT &lt;/autogen&gt; &lt;/item&gt; &lt;item&gt; &lt;name&gt;SHIFT+9 to (&lt;/name&gt; &lt;identifier&gt;private.shift9tobraceletleft&lt;/identifier&gt; &lt;autogen&gt; __KeyToKey__ KeyCode::9, MODIFIERFLAG_EITHER_LEFT_OR_RIGHT_SHIFT, KeyCode::8, MODIFIERFLAG_EITHER_LEFT_OR_RIGHT_SHIFT &lt;/autogen&gt; &lt;/item&gt; &lt;item&gt; &lt;name&gt;SHIFT+0 to )&lt;/name&gt; &lt;identifier&gt;private.shift0tobraceletright&lt;/identifier&gt; &lt;autogen&gt; __KeyToKey__ KeyCode::0, MODIFIERFLAG_EITHER_LEFT_OR_RIGHT_SHIFT, KeyCode::9, MODIFIERFLAG_EITHER_LEFT_OR_RIGHT_SHIFT &lt;/autogen&gt; &lt;/item&gt; &lt;item&gt; &lt;name&gt;= to _&lt;/name&gt; &lt;identifier&gt;private.equaltoUNDERSCORE&lt;/identifier&gt; &lt;autogen&gt; __KeyToKey__ KeyCode::MINUS, MODIFIERFLAG_EITHER_LEFT_OR_RIGHT_SHIFT, KeyCode::JIS_UNDERSCORE &lt;/autogen&gt; &lt;/item&gt; &lt;item&gt; &lt;name&gt;~ to +&lt;/name&gt; &lt;identifier&gt;private.PIAOFUHAOtoADD&lt;/identifier&gt; &lt;autogen&gt; __KeyToKey__ KeyCode::EQUAL, MODIFIERFLAG_EITHER_LEFT_OR_RIGHT_SHIFT, KeyCode::SEMICOLON, MODIFIERFLAG_EITHER_LEFT_OR_RIGHT_SHIFT &lt;/autogen&gt; &lt;/item&gt; &lt;item&gt; &lt;name&gt;^ to =&lt;/name&gt; &lt;identifier&gt;private.SHANGJIANtoEQUALS&lt;/identifier&gt; &lt;autogen&gt; __KeyToKey__ KeyCode::EQUAL, KeyCode::MINUS, MODIFIERFLAG_EITHER_LEFT_OR_RIGHT_SHIFT &lt;/autogen&gt; &lt;/item&gt; &lt;item&gt; &lt;name&gt;@ to [&lt;/name&gt; &lt;identifier&gt;private.ATtoBRACKETLEFT&lt;/identifier&gt; &lt;autogen&gt; __KeyToKey__ KeyCode::BRACKET_LEFT, KeyCode::BRACKET_RIGHT &lt;/autogen&gt; &lt;/item&gt; &lt;item&gt; &lt;name&gt;` to {&lt;/name&gt; &lt;identifier&gt;private.DIANDIANDIANtoDAKUOHAOLEFT&lt;/identifier&gt; &lt;autogen&gt; __KeyToKey__ KeyCode::BRACKET_LEFT, MODIFIERFLAG_EITHER_LEFT_OR_RIGHT_SHIFT, KeyCode::BRACKET_RIGHT, MODIFIERFLAG_EITHER_LEFT_OR_RIGHT_SHIFT &lt;/autogen&gt; &lt;/item&gt; &lt;item&gt; &lt;name&gt;[ to ]&lt;/name&gt; &lt;identifier&gt;private.ZHONGKUOHAOLEFTtoZHONGKUOHAORIGHT&lt;/identifier&gt; &lt;autogen&gt; __KeyToKey__ KeyCode::BRACKET_RIGHT, KeyCode::BACKSLASH &lt;/autogen&gt; &lt;/item&gt; &lt;item&gt; &lt;name&gt;{ to }&lt;/name&gt; &lt;identifier&gt;private.DAKUOHAOLEFTtoDAKUOHAORIGHT&lt;/identifier&gt; &lt;autogen&gt; __KeyToKey__ KeyCode::BRACKET_RIGHT, MODIFIERFLAG_EITHER_LEFT_OR_RIGHT_SHIFT, KeyCode::BACKSLASH, MODIFIERFLAG_EITHER_LEFT_OR_RIGHT_SHIFT &lt;/autogen&gt; &lt;/item&gt; &lt;item&gt; &lt;name&gt;+ to :&lt;/name&gt; &lt;identifier&gt;private.ADDtoCOLON&lt;/identifier&gt; &lt;autogen&gt; __KeyToKey__ KeyCode::SEMICOLON, MODIFIERFLAG_EITHER_LEFT_OR_RIGHT_SHIFT, KeyCode::QUOTE &lt;/autogen&gt; &lt;/item&gt; &lt;item&gt; &lt;name&gt;: to '&lt;/name&gt; &lt;identifier&gt;private.COLONtoSINGLEQUOTE&lt;/identifier&gt; &lt;autogen&gt; __KeyToKey__ KeyCode::QUOTE, KeyCode::7, MODIFIERFLAG_EITHER_LEFT_OR_RIGHT_SHIFT &lt;/autogen&gt; &lt;/item&gt; &lt;item&gt; &lt;name&gt;] to \\&lt;/name&gt; &lt;identifier&gt;private.ZHONGKUOHAOtoBACKSLASH&lt;/identifier&gt; &lt;autogen&gt; __KeyToKey__ KeyCode::BACKSLASH, KeyCode::JIS_YEN, ModifierFlag::OPTION_L &lt;/autogen&gt; &lt;/item&gt; &lt;item&gt; &lt;name&gt;} to |&lt;/name&gt; &lt;identifier&gt;private.DAKUOHAORIGHTtoSEPARATOR&lt;/identifier&gt; &lt;autogen&gt; __KeyToKey__ KeyCode::BACKSLASH, MODIFIERFLAG_EITHER_LEFT_OR_RIGHT_SHIFT, KeyCode::JIS_YEN, MODIFIERFLAG_EITHER_LEFT_OR_RIGHT_SHIFT &lt;/autogen&gt; &lt;/item&gt;&lt;/root&gt; 上面这份代码让我整整花了1个多小时，眼睛都快花了。然后有花了2个小时填坑，这里有2个大坑。 一是比如想把左右SHIFT+2都改成其他的键位，语法上，并不是 KeyCode::BACKSLASH, ModifierFlag::SHIFT_L | ModifierFlag::SHIFT_R 而是 KeyCode::BACKSLASH, MODIFIERFLAG_EITHER_LEFT_OR_RIGHT_SHIFT 二是设置的顺序问题，直接上图 这两个item如果设置的顺序搞反了，是不能成功定义前一个的，这个大家千万注意。原则比较好记，就是如果你要同时修改一个键以及上档键按下的两个MAPPING，请先定义上档的MAPPING，否则上档键的修改就失效了。 其他键位的修改mbp键盘的日本版相比国际键盘，在数字1左侧少了 漂浮号，在enter键上方，少了反斜杠，目前我用enter左下角的那个键当了 反斜杠和分隔符，用空格右侧的KANA当了 飘符号，同时，把右侧shift键左边的改成了，shift为home，单独按为end，因为写代码的时候，或者码字的时候，总需要在一行之中快速定位。 代码在下面，有需要可以直接拿走 ‘英数’一键切换输入法 123456789101112&lt;?xml version=\"1.0\"?&gt;&lt;root&gt; &lt;item&gt; &lt;name&gt;JIS_EISUU to INPUT CHANGE&lt;/name&gt; &lt;identifier&gt;private.EISUU2INPUTCHANGE&lt;/identifier&gt; &lt;autogen&gt; __KeyToKey__ KeyCode::JIS_EISUU, KeyCode::SPACE, MODIFIERFLAG_EITHER_LEFT_OR_RIGHT_COMMAND &lt;/autogen&gt; &lt;/item&gt;&lt;/root&gt; KANA改为飘符号 123456789101112131415161718192021&lt;?xml version=\"1.0\"?&gt;&lt;root&gt; &lt;item&gt; &lt;name&gt;JIS_KANA up to PIAOFUHAO&lt;/name&gt; &lt;identifier&gt;private.KANA2PIAOFUHAO&lt;/identifier&gt; &lt;autogen&gt; __KeyToKey__ KeyCode::JIS_KANA, MODIFIERFLAG_EITHER_LEFT_OR_RIGHT_SHIFT, KeyCode::EQUAL, MODIFIERFLAG_EITHER_LEFT_OR_RIGHT_SHIFT &lt;/autogen&gt; &lt;/item&gt; &lt;item&gt; &lt;name&gt;JIS_KANA down to DIANDIANDIAN&lt;/name&gt; &lt;identifier&gt;private.KANA2DIANDIANDIAN&lt;/identifier&gt; &lt;autogen&gt; __KeyToKey__ KeyCode::JIS_KANA, KeyCode::BRACKET_LEFT, MODIFIERFLAG_EITHER_LEFT_OR_RIGHT_SHIFT &lt;/autogen&gt; &lt;/item&gt;&lt;/root&gt; ps:特别说明，这段代码中来源于网络并且修改，原本的ModifierFlag::COMMAND被我修改成了MODIFIERFLAG_EITHER_LEFT_OR_RIGHT_COMMAND，同时我看了一下我的karabiner的版本，10.18.0，大家请注意这个版本的问题。 参考资料知乎上关于KANA和英数的修改让你加速让你飞 Mac键盘玩法 第二季：键位改造","link":"/2016/04/10/change_bizarra_japanese_pattern_keyboard_to_command_international_layout/"},{"title":"MAC PC Linux多平台移动硬盘加密方案","text":"文章更新 20160520-添加了我的解决方法 为什么会有这篇文章本来我一直在Windows下用NTFS格式，然后配合使用系统自带的Bitlocker进行加密挺方便的，无奈，这一切在入手第一台MBP之后彻底改变了。MAC下默认的是HFS+格式，而Windows下则是NTFS格式（这里就暂时不说FAT和FAT32了，年代太久远了，个人觉得用的人不会太多）。 三个平台下的文件系统格式Windows文件系统Windows操作系统经过这么多年的发展，文件系统一直在不断进化和演变。比如，Windows 98操作系统以及更早的微软操作系统使用的文件系统是FAT(或FAT16)，Windows 2000以后的版本使用NTFS文件系统，而Linux系统下的”正统文件”系统则为Ext2(Linux second extended file system, Ext2fs)。在默认的情况下，Windows操作系统是不会识别 Linux 的 Ext2 文件系统。 Linux文件系统Ext2这里先来说说这个比较陌生的Ext2文件系统，其特点是高效稳定。但是，随着Linux系统在关键业务中的应用逐步加深，应用场景大为扩展，Linux文件系统的弱点也逐渐显露：其中系统缺省使用的Ext2文件系统是非日志文件系统。这在关键行业的应用是一个致命的弱点。因此，就有了Ext3日志文件系统应用。 Ext3Ext3文件系统是直接从Ext2文件系统发展而来，目前Ext3文件系统已经非常稳定可靠。它完全兼容Ext2文件系统。用户可以平滑地过渡到一个日志功能健全的文件系统中来。这实际上了也是Ext3日志文件系统初始设计的初衷。 Ext4Linux kernel(内核)自版本 2.6.28 开始正式支持新的文件系统Ext4。Ext4是Ext3的改进版，修改了Ext3中部分重要的数据结构，而不仅仅像Ext3对Ext2那样，只是增加了一个日志功能而已。Ext4可以提供更佳的性能和可靠性，还有更为丰富的功能。（具体请参见文末的参考资料） MAC文件系统HFS文件系统HFS全称是分层文件系统（Hierarchical File System，HFS）,是一种由苹果公司开发，并使用在Mac OS上的文件系统。最初被设计用于软盘和硬盘，同时也可以在只读媒体(如CD-ROM)上见到。 HFS首次出现在1985年9月17日，作为Macintosh电脑上新的文件系统。HFS用于替换只用于早期Mac型号所使用的平面文件系统Macintosh File System（MFS）。因为Macintosh电脑所产生的数据，比其它通常的文件系统，如DOS使用的FAT或原始Unix文件系统所允许存储的数据更多。苹果公司开发了一种新式更适用的文件系统，而不是采用现有的规格。例如，HFS允许文件名最多有31个字符的长度，支持metadata和双分支（每个文件的数据和资源支分开存储）文件。 尽管HFS像其它大多数文件系统一样被视为苹果电脑系统的专有的格式，但是HFS却为大多数最新的操作系统提供了很好的通用解决方法，以访问HFS格式的磁盘数据。 HFS+文件系统在1998年，苹果公司发布了HFS Plus(HFS+)，HFS+改善了HFS对磁盘空间的地址定位效率低下的缺陷，并在后者的基础上加入了其它改进。当前版本的Mac OS仍旧支持HFS，但从Mac OS X开始，HFS卷不能作为启动卷用。 HFS Plus，或HFS+是苹果公司为替代他们的HFS而开发的文件系统。它被用在Macintosh电脑（或者其他运行Mac OS的电脑）上。它也是iPod上使用的其中一种格式。HFS+也被称为OS X Extended（或误称为HFS Extended）。在开发过程中，苹果公司也把这个文件系统的代号命名为Sequoia。 HFS+是对HFS系统的改进，前者支持更大的文件，并用Unicode来命名文件或文件夹，代替了Mac OS Roman或其他一些字符集。和HFS一样，HFS+也使用B树来存储大部分分卷元数据。 HFSX文件系统如果是区别，那么可以认为HFS+为是MacOS X系统使用，而HFSX是为苹果的移动设备而使用。两者的区别在于HFSX文件系统支持大小写，HFS+不支持。 在维基百科上，我没有找到HFSX的词条，看来可能区别并没有大到开一个词条的地步。 另外，MAC OS X下格式化磁盘分区有三种分区表的选择，分别是GUID，APM和MBR。 另外在苹果系统中，HFS+的叫法是Mac OS Extended (Journaled)， HFSX的叫法是MAC OS Extended (Case-sensitive, Journaled) 三种分区表的区别 GUID分区表：使用启动基于Intel的MAC，或将磁盘当做非启动盘用于任何装有MAC OS X V10.4 或更高版本的MAC。 APM：使用该磁盘启动基于PowerPC的MAC 电脑，或将该磁盘当做非启动盘用于任何MAC电脑。 MBR：使用该磁盘启动DOS和Windows电脑，或者将磁盘配合需要DOS兼容分区或Windows兼容分区的设备来使用。 Windows文件系统既然上面提到了MAC OS下可以使用MBR分区表，那么接下来，就要说说Windows的文件系统和兼容性的问题了。（未完待续） 加密方式的选择MAC下可以使用FILEVAULT来做整盘加密，Windows 7或者后续版本下当然是使用Windows原生的BitLocker加密功能了。至于跨平台的数据加密方案，在写这篇文章之前，我查阅的资料中提到的比较有名的跨平台方案是TrueCrypt，但是后来这款软件在官方网站上曝出漏洞，劝大家不要再使用TRUECRYPT进行数据加密(PS：有人说是NAS美国国安局掌握这种数据加密方式的漏洞，因此数据加密几乎没有意义，抿嘴笑:D)。 我的加密方法如果你的资料相对有一些私密性，或者有商业性质的资料在保存在移动硬盘中，并且工作环境又跨越Windows平台、MAC平台和Linux平台，那么我推荐你将移动硬盘至少划分为三个分区：一个分区使用MAC的FILEVAULT进行数据加密，第二个分区使用BIT LOCKER进行数据加密，另外一个分区，则被用于在PC和MAC以及Linux系统下复制、交换文件资料，这个分区划分至少100G(个人建议而已)，并且使用exFAT格式进行格式化 MAC和PC同时识别的文件系统主要有ExFAT和FAT32，但是FAT32格式不支持单个文件大于4G。然而，网上有人消息说ExFAT格式在PC和MAC跨平台数据交换中存在数据丢失的问题，这个我后面会提到。 如何实现我的硬盘主要在Windows 10以及OSX系统下使用，为了照顾MAC的兼容性，移动硬盘在MAC下进行分区。 使用MAC下的“磁盘工具”如下图所示，使用CONTROL+SPACE 搜索 磁盘工具即可。 我这里的截图，已经和初次连接移动硬盘有所不同了，先大概说一下流程，我是1T的外置移动硬盘，分了3个区，需要注意的是，在分区的时候，一定要点开“分区布局”下面的“选项”按钮，在这里选择GUID分区表方式，因为如果选择了MBR方式的话，这个磁盘在Windows 10下好像是无法识别出来的（有点记不清楚了，下次如果有机会重新分区，再来更新这个地方，不好意思了各位）。 选择好了GUID分区表，再来说一下，3个分区每一个具体如何选择格式。 三个分区格式的具体选择第一个分区给WINDWOS 10使用，因为需要让WINDWOS可以识别这个分区，我选择了MS-FAT格式来格式化，你也可以选择EXFAT，这种格式在WINDWOS 10也可以识别。 这里顺便就把后面的两个分区格式一起说了，第二分区给MAC使用，所以采用了HFS格式，我没有使用区分大小写，这种方式如果你看了前面的介绍，是给APPLE的移动系统使用的，具体我也没有深入研究。 第三个分区，我使用了EXFAT分区格式，这个格式虽然网上说的存在丢失数据的问题，但是因为本身就属于交换数据的分区，文件拷贝到这个盘上，在很短时间内就会归档到其他电脑上，并且这个格式支持文件大小超过4G，还是比较理想的，并且最重要的是，第三个分区作为PC和MAC交换数据使用，需要两个系统都能识别。 数据如何加密分区之后，把移动移动插到Windows 10系统下，因为我没有使用HFS+ FOR WINDWOS 10那个软件，所以系统默认只能识别到第一个，和第三个分区，第一个分区，我重新使用NTFS进行了格式化，并且开启了BITLOCKER。这样PC下的数据安全，暂时得到了保障。 然后，把移动硬盘插回MAC系统下，系统只能识别第二个和第三个分区，然后，在桌面上右键第二个分区，选择启动FILEVAULT，这样MAC下的数据安全暂时得到了保证。 有朋友会说了，如果在Windows系统下安装Paragon HFS+ for Windows® 10的话，也可以识别HFS+分区不是么？其实我之前有意购买那个软件的，单个正版序列号，在淘宝上也就是65元左右，但是后来考虑到使用BITLOCKER和FILEVAULT，就没啥必要了，因为这俩加密方式，并不能通过第三方软件进行存储（有一个M3软件，支持在MAC系统下“读取”BITLOCKER加密的数据，但是仅仅限于读取，无法写入，所以对我来说，意义不大，而且还可以省下一笔银子，并且更重要的是，感觉自己都会乱的）。因此，BitLocker加密，和FileVault加密工作，仿佛分别变成了WINDWOS和OSX系统各自的“福利”。 最后的最后其实，这个跨平台的加密方法，目前用着还是相对安全，至少数据在各自不同的分区下，都使用了可靠的加密方式，代价就是过程稍微复杂，并且会浪费一些时间。 我个人因为养成了在不同系统之间及时备份数据的习惯，因此移动硬盘上第三个分区上的数据，并不会长时间（不超过24小时）保存。我个人有整理数据的习惯，很快就会把三个分区上的数据尽快转义到各自的文件系统中去。因此，安全性就是最重要的，所以本文中没有使用第三方加密工具，而是分别使用了各自平台上最为成熟和稳妥的加密方式。 好了，这个话题终于告一段落了，折腾了我3个礼拜，终于可以暂时收笔了。 因为比较懒，文章中有一些概念还没有及时学习清楚，先这样吧。 参考资料 Ext2、Ext3和Ext4之间的区别 什么是文件系统？ 分层文件系统HFS HFS+介绍 HFSX和HFX+的区别","link":"/2016/05/06/portable_harddisk_encryption_method_on_mac_pc_and_Linux/"},{"title":"OSX日常使用技巧(附PDF打印版)","text":"快捷键文件日常操作Command + [ 或者 Command + ↑ : 文件夹向上一层Command + O 或者 Command + ↓ : 打开文件/文件夹Command + C : 复制Command + V : 复制文件（文件操作）Command + V : 黏贴（仅限于文本）Command + Option + V : 剪切（文件剪切）Command + X : 注意这里Windows习惯的剪切，在OSX上只能针对文本进行操作，据说是因为怕用户剪切走了文件，如果没有年且就会导致文件丢失。好吧，我承认我想不明白，你为啥就不能先默认不删除，必须等用户黏贴之后才删掉文件呢。Command + DEL : 删除Command + Z : 撤销Command + Shift + Z : 重做SPACE : 预览RETURN : 修改文件名字SHIFT + RETURN(ENTER) : 没有这个用法 程序内操作Command + W : 关闭一个TABCommand + Q : 关闭某个APP 截图Command + Shift + 3 : 全屏截图，并保存文件到桌面Command + Shift + 4 : 窗口截图，并保存文件到桌面Command + Shift + Control + 3 : 全屏截图，保存到剪切板Command + Shift + Control + 4 : 窗口截图，保存到剪切板 如果大家希望打印出来，贴在自己的办公桌上看着方便，我这里也制作了一份打印版，欢迎大家下载打印，下载地址 一些小技巧 按住SHIFT键，在选择文件的时候很好用，比如配合触摸板/鼠标，可以添加或减选文件，更神奇的是SHIFT+方向键，可以实现多个方向的文件选择。 之前一直想不明白三个手指左右滑动到底是在什么地方切换，现在终于明白了。只要你把某个APP最大化，那么就可以把这个APP加入到三指滑动的列表中了。这种最大化，对于专心做一个事情很有帮助。 最大化你需要专注的任务，然后通过三个手指在该任务和其他桌面之间进行切换，是很方便的提升注意力的方式。 几段关于键盘的小故事ENTER和RETURNQ: OS X 为何将 Return 键（Enter 键）的功能设计成修改文件名而非打开该文件？ A: 来自知乎 首先，Mac OS 中修改文件名不是用 Enter 键，而是用 Return 键。Return 最早出现的目的就是为了输入一个换行符（Carriage Return），并无「执行」的含义。 在早期的 Mac 上 Return 键和 Enter 键是两个独立的键（小键盘上的那个才是 Enter），在某些软件中这两个键执行的功能也不相同。比如在 Adobe Photoshop 中，Return 是换行，而 Enter 则是退出编辑模式。 而 Enter 键，从名字上看，则带有了执行的意思。因此在 Windows 的设计中用 Enter 键来打开文件。 另外，从刚才考据的结果来看，Apple 至少在 90 年代初的 System 7 中就开始用 Return 键来重命名文件了。因为年代久远的关系，尽管现在 Return / Enter 在交互中处于很重要的地位，Apple 也不大可能将 Return 键改成「打开文件」了。 return键上面标的enter怎么用？看到我的日本键位上的return键，发现仔细看上面写着enter键，一般第一反应是这个键如果配合FN一起按，就是实现enter功能，但是有人试过么？这里先卖个关子，等回来我继续写这个话题。 MAC下常用的命令 top top 是另一个长期为 Linux/Unix 社区使用的经典工具，使用它只需打开终端输入「top」。眨眼之间，你就会看见一个满是文字的窗口——每一个正在你的 Mac 上运行的进程都会被列出。如果我的 Mac 速度变慢，top 是让我知道什麽正在发生的首选。点击 这裡，查看 top 的完整概述。 lsbom 如果你偶然在某个 Mac 站点（比如 OS X Daily）发现一件够酷够新的软件，忍不住想安装，而你又犹豫不决，那麽 lsbom 对你大有好处。通过它，你可以测试 Mac OS X 安装包（.pkg）的内容，并且清楚瞭解究竟会有什麽被塞进你心爱的文件系统。要使用 lsbom，你需要启动终端，并进入 .pkg 文件所在的目录。如果你的安装包形式是 .dmg，可能需要把其中的 .pkg 文件拷贝到桌面上，然后进入 Desktop 目录。一旦确认 .pkg 文件的位置，输入「lsbom .pkg/Contents/Archive.bom&gt; | more」。哇！你所看见的就是新程序将会安装的完整文件列表。 say 这个命令是 Mac OS X 独一无二的，比其他任何一个都更有趣。打开终端输入「say hello」试试吧！ softwareupdate 命令提供了一种安装 Apple 软件更新方便快捷的方法。打开终端，输入「softwareupdate -i -a」，你的 Mac 就会安装所有可以获得的更新项。如果你只想安装「推荐」更新项，那麽就输入「softwareupdate -i -r」。 6、ipconfig 要说获取你 Mac IP 地址最快、最简单的方法，绝对是「ipconfig」，只需打开终端输入「ipconfig」。你能看到许多信息，包括你网卡的 MAC 地址。我喜欢输入「ipconfig | grep inet」仅回馈我计算机的 IP 信息。你也可以通过输入「ifconfig en0 down」来禁止一个网络连接（这裡举了「en0」的例子）；如果希望恢复，那麽就输入「ipconfig en0 up」。这比使用系统预置要快上不少哦！ 7、lipo lipo 是一个在 Mac OS X 中处理通用程序（Universal Binaries）的工具。现在发售或者提供下载的许多（几乎所有）程序都打上了「Universal」标志，意味着它们同时具有 PowerPC 和 Intel 芯片能够处理的代码。不过既然你可能不在意其中的一个，你就能够使用 lipo 来给你的程序「瘦身」。比如你想让「便笺」应用程序只包含 Intel（i386）的代码：cd /Applicationslipo Stickies.app/Contents/MacOS/Stickies -thin i386 -output Stickies.app/Contents/MacOS/Stickies.i386cd Stickies.app/Contents/MacOS/rm Stickiesmv Stickies.i386 Stickies 8、screencapture screencapture 提供了较 command-shift-3 更高级的抓屏手段。要使用它，打开终端，试着输入「screencapture -iW ~/Desktop/screen.jpg」，鼠标会变成等待点击的相机图标，点击后就在你的桌面上创建一个名为「screen.jpg」的文件，内容就 是你点击的任何窗口的抓屏。当然你也能够通过输入「screencapture -S ~/Desktop/screen.jpg」来抓取整个屏幕。如果你还想与众不同，你还可以输入「screencapture -ic」来抓取屏幕的一部分。 9 &amp; 10、Fink 和 DarwinPorts 如果你已经习惯于 OS X 命令行工具的基本应用，现在就是让你的终端接触更大开源世界的时候了。借助于 DarwinPorts 或者 Fink，你能够在你的计算机上下载、安装成百上千的免费开源软件。我发现 Darwinports 开始注意到一些较少见的开源计划，而 Fink 似乎更为坚实。你可以同时安装两者，只要你的确知道你在干什麽，但是一般我会建议你只选择其中一个。初学者应该试试 Fink，因为它会附带一个名为「Fink Commander」的程序，你只需从中选择一个程序来下载。看看它们各自的官方网站吧：DarwinPorts （已更名为 MacPorts）官方网站；Fink 的官方网站。 参考资料 OS X 为何将 Return 键（Enter 键）的功能设计成修改文件名而非打开该文件？ 使用Mac OS X系統必須瞭解的10條命令","link":"/2016/04/27/daily_tips_and_shortkeys_for_osx_system/"},{"title":"安装CENTOS7遇到启动问题","text":"文章更新 20160427-初次成文 为什么会有这篇文章首先，是因为想给自己的东芝笔记本换个系统，黑苹果以前折腾过，太麻烦，显卡驱动装不好很不爽，现在也不大想重新再回顾一遍，尤其是自己已经有了MBP的情况下。因此，选择了LINUX系统，看来看去，想找个深度LINUX作为入门，据说界面和XP很像，但是无奈，刻录的U盘，在第一次安装的时候，就不知道出了啥问题，在安装界面就出了问题。因此，看了下其他的带UI的系统，有人推荐UBUNTU，但是无意中发现CENTOS也有UI，因为自己使用过阿里云的服务器，对CENTOS搭建PHP环境相对熟悉，就选择了CENTOS 7来安装。 其次，就要说到一个非常蛋疼的原因了。我的本本是东芝U800，应该是一年之前，不知道我脑子犯了什么病，给BIOS设置了一个密码，然后还把系统的启动顺序设置成了硬盘优先，然而让我几乎蛋碎的是，我把密码忘！记！了！（千万只草泥马奔腾而过！）我要给笔记本装系统，不能用U盘启动，因为硬盘先启动，然后如果我拔掉硬盘，可以从U盘启动，但是启动了，系统往哪里装呢？之前的解决办法非常麻烦，就是直接把笔记本拆了，拿出来硬盘，直接在另外一台电脑给这个硬盘分好区，激活第一个分区，然后GHOST把系统GHO文件直接恢复到第一个分区上，然后把硬盘装回去，再启动，就可以开始装系统了。这样的经历有2次，非常费劲，因为每次都要小心翼翼的拆螺丝装螺丝，而且之前，这个本本因为是超极本，非常薄，显示器的连接轴断了一次，去中关村150找人修好了，然后就更加不想拆装这个本本了。 最后，就回到了这篇文章的主题，因为如果没有前面两个问题，我这本本估计装CENTOS不会这么费劲。但是这次的经历，也让我想到了一个相对容易的解决办法，具体文章最后会说。 U盘安装遇到/dev/root does not existU盘安装CENTOS 7，遇到这个错误 1Warning: /dev/root does not exist, could not boot 网上的解决方案一般是因为刻录出来的U盘卷标无法被CENTOS的安装程序识别，所以可以通过在WINDOWS系统下，修改U盘卷标为一个非常简单的名字，比如CENTOS，然后再进入U盘的EFI/BOOT目录，修改一个cfg文件来搞定。 但是这个方法没有解决我的问题，我做了第一步，就是修改了U盘的卷标为CENTOS，然后在U盘安装CENTOS7启动的时候，按TAB键，修改CENTOS\\x207\\x20x86_64为CENTOS，这样就可以顺利安装了。我这里发现了一个小问题，就是CENTOS系统对大小写敏感，因此，那个CENTOS\\x207\\x20x86_64的卷标，一定要写成CENTOS（全部大写），而不要只是删掉了CentOS后面的字符，这样同样不能继续安装。有人说了，那我把U盘的卷标也写成CentOS不就好了？那可不行，因为U盘的卷标，不支持小写字符… 删掉分区，重装时出现grub rescue第一次装CENTOS7的时候，忘记装UI了，开机直接进入了提示符，对我这个菜鸟来说可有点郁闷，虽然我在阿里云上还算熟悉，但是起码有教程一步一步教我怎么配置环境，但是这新电脑你就直接给我一个提示符，啥UI没有，还是有点抬举我了，二话不说，重装！ 然后，问题来了…开机就遇到了这个错误 1partition not found 我是把硬盘从本本上拆下来，然后安装到台式机上去删掉了分区，然后打算重新接回本本上重新安装一次系统的。想法很好，因为觉得这硬盘都干净了，应该会想第一次一样顺利，谁知道，当我接回去的时候，开机之后遇到了partation not found的错误，我当时就纳闷了，硬盘上怎么还有东西没删干净么？然后就算插上U盘启动，错误依旧，这时候我就知道了，这个硬盘虽然没有分区了，但是应该还有一些CENTOS的启动信息存在，这个信息应该存在了MBR或者分区表之类的地方（这个地方先这样说吧，因为我没深入研究，这里主要说的是解决办法）。 怎么解决呢？在网上搜索的时候，一般建议是用WINDOWS PE启动盘启动，然后进行MBR重建修复，但是这个办法对我来说太麻烦了。于是我就想找一种在WINDOWS 10下可以做的修复办法，还真被我找到了，就是DiskPart命令。 步骤如下，把那个看似干净的硬盘接到Windows电脑上，然后开启CMD环境，一次下面的命令。 12345678DISKPART #进入DISKPART环境DISKPART&gt; LIST DISK #列出所有硬盘DISKPART&gt; SELECT DISK 3 #3修改为你想操作的硬盘DISKPART&gt; CLEAN #从选中的磁盘中删除所有分区或卷格式DISKPART&gt; CREATE PARTITION PRIMARY #在当前基本磁盘上创建主要分区DISKPART&gt; ACTIVE #在基本磁盘上，将选中的分区标记为活动的DISKPART&gt; EXIT #退出DISKPARTDISKPART&gt; EXIT #退出CMD 然后也不需要格式化，这个盘上的信息就彻底干净了，这时候把盘从WINDOWS系统接回要安装CENTOS的电脑，就可以重新安装了。 参考资料DiskPart 命令介绍","link":"/2016/04/27/the_startup_problem_when_installing_centos7/"},{"title":"多终端同步HEXO写博客","text":"文章更新 20160517-修改了关于在本地hexo目录下安装主题的方法 20160518-放弃fetch方式，改用了pull方式 20160613-修改了一下新环境下创建HEXO并且pull文章的方式 第一次同步文章MARKDOWN源文件选用的是 GITHUB 和 CODING.NET 分别作为静态文件在墙外和墙内的两个服务器，coding.net私有库来存放原始posts文件。 以下文章中的电脑A是一台pc，电脑B是一台macos系统的苹果电脑，仅做举例用，多台pc或者mac也是可以的。 电脑A写HEXO推送到仓库首先，假如自己在电脑A上已经建立好了HEXO，写了一些文章，如何推送到coding.net上呢？ 先要去coding.net上建立一个私有库，这里名字默认使用了hexo名字。然后 12345git init #这句话很重要哦git remote add [alias] [url] #将本地文件和云端仓库映射起来，这步很重要，这里[url]应该写类如https://git.coding.net/tinyvane/hexo.git这样的远程仓库地址git add * #将本地修改添加到缓存区git commit -m '写了几个新帖子'git push origin master #如果遇到错误，采用git push -f参数，强制上传 好了，电脑A上的工作就完成了。 电脑B进行hexo内容同步然后切换到电脑B，视这台电脑是否已经事先安装了node.js、cygwin(Windows环境）以及hexo-cli 然后打开bash，执行命令 1npm install -g hexo-cli #全局安装 继续，选一个地方执行下述命令 123git clone https://git.coding.net/tinyvane/hexo.git hexo #路径和目录自设设定cd hexo npm install #根据package.json安装缺少的npm组件 说明：如果执行 git submodule 遇到 already exists in the index 错误，请先执行 git rm --cached themes/next 然后再执行 git submodule add。 上面的步骤可能有一点问题，通过网上的一个帖子《Using Git Submodules to Manage Your Custom Hexo Theme》，如果在另外一台电脑要CLONE一个带SUBMODULE的REPO，需要三条命令 123git clone git@git.coding.net:tinyvane/hexo.gitgit submodule initgit submodule update 并且，这些操作之前，需要在电脑A上，先使用git add themes/next来把作为HEXO的主题文件夹作为子模块纳入GIT管理，这样themes/next下的文件，也会上传到你的远程仓库中，同时呢，这个子模块还可以借助 submodule update来获得更新，一举两得。 然后开始写文章，更新的时候，执行下面命令 123git add .git commit -m '写了几个新帖子'git push origin master 这里说一个题外话，这样Push的时候，会问账号和密码，是因为clone repo的时候采用了https而不是ssh方式，详细说明看这里。 需要进入.git目录，修改config文件， 将 url = http://git.coding.net/tinyvane/hexo.git， 修改为 url = git@git.coding.net:tinyvane/hexo.git 即可。 电脑B下载安装主题和其他必备插件安装hexo-asset-image和模板 首先确认 _config.yml 中有 post_asset_folder:true 。 然后执行 1npm install https://github.com/CodeFalling/hexo-asset-image --save #图片插件使用-S 等同于 --save 2016年5月17日更改 修改了之前用#git clone https://github.com/iissnan/hexo-theme-next themes/next的方式 之后每次同步的步骤如果上面的步骤运行了一次，之后就不用这么费劲了。加入你在两边的电脑上，都同步完了，下次到A电脑上，开始写文章，然后需要做的事情： 123git add .git commit -m 'the articles updates on this machine this time'git push origin master 更新完成 然后B电脑上写帖子之前，先拉去远程仓库中的文章更新 1git pull --all #后来还是使用了这种方式 更新帖子 123git add .git commit -m 'the articles updates on this machine this time'git push origin master 20160518 修改了之前用git fetch --all + git reset --hard的方式 我因为学git时间不长，很多概念还在慢慢理解中，一直都知道git reset --hard不好，但是具体怎么不好，也说不清楚。 直到看到了stackoverflow上的一个帖子，地址在这里 文章说的情况，就是一般本地代码都是git pull来操作的，安全可靠，但是发生了本地代码和远程仓库有所不同，然后本地的程序员就把自己的代码发给了仓库管理者（暂且这么说吧），让后者来更新，后者更新了远程仓库代码，但是本地程序员，发现Pull就不好用了。所以，提问者的人，想知道否是可以force pull，就是强制用远程代码覆盖本地代码。 答案就是上面说的fetch --all这种方式了，但是这种方式需要配合reset --hard，这样本地所有未提交的commit就会丢失，那么当时这种情况非常适合我这种一个人用git管理hexo博客的情况，但是如果两边同事有人在写代码，那么就不合适了。 所以，在那个帖子的高票答案中，提出了git checkout master分支到另外分支，然后再使用git clone远程仓库的master分支到本地，然后采用合并的方式，这样既可以跟踪最新的远程仓库源代码，同时也不会丢失本地的commit。 这种情况，也让我学习了git checkout的用法。顺便总结一下。 如何更新本地的HEXO1npm update 如何更新主题目前还是采用在站点目录下，复制个主题下的配置文件，然后全部删掉next主题，然后clone或者submoudle的方式，这种方式很笨，并且还不能自动更新，更详细的，可以学习这个帖子，但是目前精力不够，还无法深入理解，先放着吧。 参考文章 利用git解决hexo博客多PC间同步问题 白话GIT","link":"/2016/04/06/sync_hexo_among_different_clients/"},{"title":"那些写代码时候听的音乐","text":"题记不知道别人怎么样，反正自己是个拖延症重度患者，所以，一切觉得可以对自己学习有帮助的东西，我都想尝试一下。比如番茄工作法啊，写代码的时候听音乐啊，地铁里看程序员头条啊，但是最后分别变成了番茄种了3个，就放弃了；写代码时听音乐听得头大；地铁里改玩植物大战僵尸了。。。 不过，我是强迫症与拖延症并存，所以，还是要写个帖子总结一下才舒服。 听歌曲阶段最开始的时候，从乱七八糟的听，逐渐过度到听英文歌，这个阶段听得主要是阿姆的Beautiful，Mocking Bird，We Made You，这些比较劲爆的歌曲，随便写几个吧，大家可以试着听听。 Beautiful by Eminem We Made You by Eminem Not Afraid by Eminem Without Me by Eminem Party In The U.S.A. by Miley Cyrus Emprie State Of Mind by Jay feat Alicia Keys Born this way by Lady Gaga Stan by Eminem It’s My Life by Bon Jovi Empire State of Mind，是很早的时候看美剧Glee时候喜欢上的，推荐大家听Glee cast的版本，配上MTV更有感觉。其实Glee里面很多重新演绎的版本，相比原版谁更好见仁见智了，我还比较推荐的同样Glee Cast的其他几首歌曲，比如翻唱的Lady Gaga的Telephone，Mars的 后来发现音乐太乱了，自己思路也跟不上，就听了相对舒缓一些的音乐。 Young and Beautiful by Lana Del Rey Sugar by Maroon 5 See You Again by Wiz Khalifa ft. Charlie Puth What Do You Mean? by Justin Bieber Teenage Dream by Glee cast Firework by by Katy Perry 可能人岁数大了，开始喜欢单曲循环了，最近的单曲循环主要是下面4首 大哥 by 卫兰 你的眼神 by 卫兰 See You Again by Wiz Khalifa ft. Charlie Puth Young and Beautiful by Lana Del Rey 还有一首神曲，Jam的七月上，至于为什么，这里面有一个从单身狗群里挺过来的小故事，不便分享，大家可以听一下歌词感受一下。 背景音有时候在家的时候，天气越来越热，人也容易烦躁，所以除了早晨起来写代码的时候回听听Sugar或者See you again这样的曲子，平时晚上的时候都是《七月上》的单曲循环，但是最近开了空调，空调声音有点吵，让我感觉不容易安静下来，无意中发现了背景音乐这种类型的，下面有3个这样的网站，非常推荐。 Rainy Mood在线播放雨声的网站，也有手机客户端。特别适合酷热的夏天或者干燥的冬天。网站地址：http://www.rainymood.com/ Calm如果说Rainy Mood是自然版的白噪音，那么Calm就是神游版的白噪音。感觉适合冥想和午睡。Calm功能很全，可以选时间，换场景，有向导教程，还有iPhoneAPP。网站地址： http://www.calm.com/ A SOFT MURMUR相比之下这个站就比较简陋了，但有意思的是它可以把多种白噪音混合在一起，你还可以随意调节音量。最后一个声音是人声，下次女朋友问你在哪儿的时候可以开到最大，骗她说你在咖啡厅。当然，首先你要有个女朋友。网站地址：http://asoftmurmur.com/ 我的选择我是用QQ浏览器，开着Calm的图片，然后关掉网页声音，声音用SOFT MURMUR的，一边听着雨声，一边写代码，很有感觉的说。 参考资料 隔窗听雨：那些写代码用得上的白噪音网站","link":"/2016/05/17/the_music_I_listen_during_coding/"},{"title":"我的第一个树莓派","text":"组装与插电先来几张图片，其实很早就知道这个玩意了，但是一直也没有啥需求，最近玩了OpenWRT路由器，觉得这种低功耗的玩意，可玩性还是挺高的，并且对Linux系统也慢慢接受了，所以就从淘宝上入了一个3代的。 制作启动盘需要一个TF卡用来刷系统，这玩意本身啥都不带，就是个硬件，所以我找个8G的TF卡刷了一个Raspbian系统，基于DEBIAN的系统。都是LINUX的，下载地址。 开机插上鼠标，键盘，做好系统后，插入到卡槽中，一通启动，12秒左右，直接进入桌面。 如果用远程链接，用户名是pi，密码是raspberry，记得登录之后，先修改下密码。 1sudo passwd pi #这里记得一定要带上pi，否则你修改的是root的密码 而且这里还有一个步骤，就是运行raspi-config，运行下配置。 1#raspi-config 主要就是选择第一个项目，Expand FileSystem将U盘容量进行拓展，然后重新启动。 然后再次用xshell登录，OK了。 Linux操作系统是一个多用户操作系统，它允许多个用户登录和使用一台计算机。为了保护计算机（和其他用户的隐私），用户都被限制了能做的事情。 大多数用户都允许运行计算机上大部分程序，并且编辑和保存存放在他们自己home目录中的文件。一般用户都不允许编辑其他用户的文件和一些系统文件。然而，在Linux系统上有一个特殊用户叫做超级用户，通常用户名为root。这个超级用户访问计算机没有限制，几乎可以做所有事情。 你通常不以root用户登录计算机，但是可以使用sudo命令来获得超级用户权限。如果你登录树莓派使用的是pi用户，那么你就是以普通用户身份登录。你可以在你想要运行的程序之前添加sudo命令来以root用户身份运行程序。 例如，如果你想要在树莓派上安装额外的软件，你通常需要使用apt-get工具。为了能够更新可使用的软件列表，你需要在agt-get命令之前添加sudo命令前缀：sudo apt-get update。 你同样也可以使用sudo su命令来运行一个超级用户shell终端。一旦以超级用户的身份运行命令，那么就没有什么能够防止造成系统伤害的错误。相当于关闭了机器上的安全防护。虽然这样能够更容易访问系统内部的东西，但是造成损害的风险更大。建议你只在需要超级用户权限的时候以超级用户身份运行命令，在不需要超级用户权限的时候及时退出超级用户shell终端。 WHO CAN USE SUDO？（谁可以使用sudo） 如果任何用户都能够在命令之前添加sudo，安全性就会遭到破坏，因此只有指定的用户才能使用sudo获取计算机管理员的权限。pi用户已经包含在sudoer文件中。允许其他用户使用超级用户权限，你可以将这些用户添加到sudo分组，或者使用visudo添加他们。 如果你是用wifi让树莓派上网的，那么启动树莓派上的命令行，输入ifconfig，就可以看到树莓派获的ip地址了。 显示中文默认系统是不支持中文显示的，所以需要安装中文字体的包。 123sudo apt-get update #获取系统更新sudo apt-get install ttf-wqy-microhei #安装中文字库sudo dpkg-reconfigure locales #更改系统中的菜单界面 用空格键勾选前面带有 “zhCN.UTF-8” 的选项，这些表示是中文字库。（不要选那么多，我自己装了一个zhCN.UTF-8，其他用到的时候再说，而且安装也会慢） 注意第一个界面是安装默认字库，第二个是选择系统显示界面的，最好还是用en来显示，否则连bash提示都是中文，感觉也是没sei了。 中文输入法终端下执行命令： 1sudo apt-get install scim-pinyin 我装的时候遇到点问题，只好先卸载了，很简单，install变成remove即可。 1sudo apt-get -y remove scim-pinyin 我最后用的还是google拼音。 1sudo apt-get install fcitx fcitx-googlepinyin 不知道为啥scim-pinyin死活用不了呢，下次再说吧。 开启VNC远程桌面安装VNC1sudo apt-get install tightvncserver 增加一个桌面1tightvncserver #设置密码，会问你是否只是一个只读链接，我选的N 远程连接桌面下载VncViewer，地址 打开程序后连接地址，注意格式是 IP地址:1 我这里输入的是192.168.10.180:1 然后弹出一个提示，意思是数据没有加密之类的。 以后每次想从PC远程使用VNCSERVER的时候，都需要在π上面先启动tightvncsever？这个我还不确定，再说。 关闭桌面1vncserver -kill :1 加装3.5寸外接触摸屏发现购买的3.5寸触摸屏的厂商，貌似在CSDN上有推广的账号？至少在这个页面，讲解得非常清楚。 这里是一个youku视频，讲解的很清楚了。 下面的步骤，就是根据这个页面的介绍，结合自己的实际情况总结的。 12345678cd /devls #查看是否有sda1,sda2这样的目录，有就说明U盘插上了cd /mnt #进入挂载目录sudo mkdir udisk1sudo mount /dev/sda4 /mnt/udisk1ls #查看是否有udisk1目录，如果有，就说明挂载成功cd udisk1 #进入udisk1目录，等同于进入了u盘根目录cp LCD-LCD-show-160520.tar.gz ~ 这个地方学到了一个TAB技巧，就可以输入文件名的前几个字母，然后按TAB补全文件名。这个步骤是把LCD-show.tar.gz文件复制到主目录。这里我是跟着视频做的，刚开始对这个 ~ 符号有点不理解，视频中说是主目录，我通过输入 1cd ~ 发现这个目录是我用户名的目录，并不是根目录，学习了。 1234567cd ~ #进入主目录tar -zxvf LCD-show-160520.tar.gzsudo umount /mnt/udisk1 #卸载U盘ls #查看目录，看看是否存在LCD-show目录，存在则说明解压缩成功cd LCD-showls #可以看到多个驱动脚本sudo ./LCD35-show #这里注意，一定要有./表示当前目录，又是一个知识点 然后系统就会重启了。这时候，我发现我的电视，依然继续开机画面，但是到了6-7秒之后，就不继续了，触摸屏开始点亮。 参考资料树莓派开发系列教程2——树莓派上手使用","link":"/2016/05/18/my_first_raspberry_pi/"},{"title":"SKETCHUP建模练习","text":"为啥会有这篇文章帮朋友的一个小忙，要实现一个草图，效果如下。 AUTOCAD导出其实这个步骤我并没有处理，CAD的一般来说导入SU会有一些断头之类的，但是SU的插件一般可以处理了。 下面是CAD的图纸。 SU插件我用了MAKE FACES，用来做封面，“拉线成面”，很好用，顾名思义。 直接上图吧。 SU细节图先来张整体图。 这是我花了最长时间的部分。 上面那些木头柱子画的真是想骂人。 贴图其实是最好玩的部分。 尤其是给不同的部分贴上不同的材质，比如草地，比如木头表面。 好了，下面直接上渲染图吧。这个部分倒是不难，主要是vray for su 2016的破解，网上找了几个，都不是很对，最后终于找到了对的。但是已经是2天之后了，还是发给了朋友，能不能顺利过关，就靠他的修为了。 下面是朋友用PS加上了树木和喷泉之后的完整图，感觉好多了。 总结不是专业人士，整个图从CAD导入到最后渲染完成，用了一个晚上，加了一个白天，一个完成完成了建模+贴图，一个白天用来找破解版本的VRAY。所以，好的工具真的是很有用的说。 好了，项目结贴，文件存档，GAME OVER.","link":"/2016/05/25/sketchup_modelling_practise/"},{"title":"MAC下烧录IMG文件","text":"为什么会有这篇文章因为我的树莓派错装了老版本的 微雪 触摸屏驱动，导致树莓派启动不了了，通过在WINDOWS系统下，分析那个60多M的FAT分区，发现是可以看到boot目录和config.txt文件的，但是无奈，折腾了一会，没成功，只能重新刷系统了。 工作电脑是MAC系统，所以对烧录IMG文件不是很熟悉，就顺便一边做一边总结下过程。 下载树莓派系统IMG文件树莓派系统下载地址，版本是4.4的，更新时间2016年5月10日，特此说明。 下载好了，是个ZIP文件，双击ZIP文件就解压出来一个IMG文件。 烧录过程烧录工具准备官方推荐使用 SDcard Formatter 工具。据说支持 Windows 和 MAC 双系统，之前在WINDOWS下使用这个软件，没想到也有MAC系统，涨姿势了。软件下载地址。操作简单点击下就行。 MAC系统下SD卡的准备我将TF装在了SSK的读卡器内，插到MAC系统下，因为这个TF卡之前已经刻录过RASPBIAN系统，所以分区比较乱，在bash下使用 1diskutil list 可以查看到该盘的情况。 该SD卡挂载到了/dev/disk2，并且有两个分区，一个是FAT的，66.1MB大，另外一个是LINUX的分区，15G大。记住磁盘叫/dev/disk2s1。 也可以使用df -lh命令，效果差不多。 卸载磁盘在写入镜像文件之前，要先把这个SD卡的盘卸载了。 1diskutil umount /dev/disk2s1 写入文件输入下面的命令进行写入操作。 1sudo dd bs=1m if=./2015-11-21-raspbian-jessie.img of=/dev/rdisk2 这里特别注意几个问题： 写入文件没有s1且前面多了个r，/dev/disk2s1对应的输出文件是/dev/rdisk2 这句命令需要当前目录下存在2015-11-21-raspbian-jessie.img文件。 输入sudo应该会让你输入密码，密码不显示，别敲错了。 输入密码之后，会在一段时间内没反应，不要以为是出错了，等着就可以了。因为如果你说错密码，系统会告诉你Sorry Try Again，而不会啥都不出。 写入完毕写入时间估计持续几分钟，写入文件成功后，可以在磁盘管理里面看到多了个boot磁盘，说明写入文件成功。 后记虽然烧录成功了，但是放到π上，启动没成功，不知道是不是MAC的兼容性问题还是自己的问题。重新到WIN10下用Win32DiskImager-0.9.5搞定的。 参考资料触摸屏官方WIKI链接MAC下树莓派Raspberry Pi烧录IMG","link":"/2016/05/25/how_to_burn_img_files_in_linux/"},{"title":"树莓派折腾系列","text":"文章更新 20160526-更新BT SYNC和使用静态IP地址 20160613-更新了使用DNSPOD更新域名A记录的方式更新外网域名访问 20160623-更新挂载硬盘、格式化等方法 20160712-BT SYNC独立成文 折腾1：安装BT SYNC文章独立分拆，转移到这里→新入口 折腾2：配置公网IP地址（放弃）配置过程颇费了一番周折，感觉最有价值的参考文章应该还是这篇，所以这里为了尊重作者，链接表示感谢。 自己用的北京联通，虽然拨号会得到公网IP地址，但是每次拨号都会变化，所以需要利用DDNS来将公网域名和内网的IP地址联在一起，看了几个，还是花生壳比较靠谱。 配置DDNS花生壳因为我有了一个OPWENWRT的路由器，所以可以把花生壳安装在路由器上，步骤很简单，关键是免费的树莓派账号需要花6块钱开通一个“内网穿透”的套餐，然后每一个月1G的流量足够了，因为使用来管理的，又不需要通过这个IP地址来发送接收很多的东西。 准确的说，这里说的方法，并不是给树莓派配置花生壳，而是在OP路由器下运行花生壳，让OP路由器拨号的宽带与一个VICP.NET花生壳域名绑定。 首先到花生壳网站上，注册一个免费账号，选一个你喜欢的域名，然后在OP路由器下的-系统-动态DDNS 下开启花生壳，然后应用运行，如果你在其它地方可以ping到你的花生壳域名，并且返回的IP地址，和你在OP路由上获得WAN口IP地址一致，恭喜你，花生壳运行成功了。 我这里因为用了多拨，虚拟出来了多个WAN口，在OP里，需要指定这个花生壳绑定在哪个具体的WAN口上。 然后还有重要的一点，就是需要在多拨的负载均衡设置里面，将树莓派的静态IP地址，指定某个WAN口作为流量出入口（这条是否必须有待验证，因为我之前挂赚钱宝的习惯，所以才有了这条）。 树莓派使用静态IP地址（错误方法）这里的方法是错误的，但是我又不忍心删掉了，大家看到的时候，千万记得，这是错的，这是错的，这是错的，重要的事情说三遍。 123cd /etc/networkcp interfaces interfaces.bak #备份下sudo vim interfaces 奇葩的是，π竟然默认没有安装VIM，用了两下VI，觉得实在是不习惯。 安装VIM： 1sudo apt-get install vim 把 iface eth0 inet dhcp 这句注释掉，然后按照下面的修改： 1234567891011121314iface eth0 inet staticaddress 192.168.10.173 #这是我的IP地址，请按照具体情况修改，下同netmask 255.255.255.0gateway 192.168.10.1``` 然后删除 `iface default inet dhcp` 行否则 ip 是固定的但是无法连外网然后重启系统``` bashsudo reboot 或者重启服务 1sudo service networking restart 如想修改DNS，则需要修改文件 /etc/resolv.conf 12345nameserver 8.8.8.8nameserver 8.8.4.4nameserver 208.67.220.220nameserver 208.67.222.222nameserver 10.10.10.10 同样也是重启系统或者网络生效。 树莓派使用静态IP地址（正确方法）网上看了一些文章，发现上一小节中的设置方法网上很泛滥，但是实际上却不是最新的方法，在 /etc/network/interfaces 文件中有这么一句话 # Please note that this file is written to be used with dhcpcd# For static IP, consult /etc/dhcpcd.conf and ‘man dhcpcd.conf’ 已经告诉大家interfaces中的设置并不是用来设置静态IP的，所以我又默默的把interfaces文件恢复原状了。 这个作者在自己的博客上公布了中文版的方法，地址在这里 我顺便总结一下 在/etc/dhcpcd.conf文件后面增加 12345interface eth0static ip_address=192.168.10.173/24static router=192.168.10.1static gateway=192.168.10.1static domain_name_servers=192.168.10.1 这里eth0代表板子上的RJ45口的地址 这里要注意 ip地址要根据自己的子网掩码改 而且后面的”/24”也别落下(开始我觉得没用去掉了就不行) 然后domain_name_servers后面还可以加dns地址比如 1domain_name_servers=192.168.10.1 8.8.8.8 如果使用无线网卡的 可以再加一套 1234interface wlan0static ip_address=192.168.10.174/24static routers=192.168.10.1static domain_name_servers=192.168.10.1 然后创建 /etc/wpa.conf 文件： 1sudo vim /etc/wpa.conf 如果你的wifi没有密码 1234network={[Tab] ssid=\"你的无线网络名称（ssid）\"[Tab] key_mgmt=NONE} 如果你的wifi使用WEP加密 12345network={[Tab] ssid=\"你的无线网络名称（ssid）\"[Tab] key_mgmt=NONE[Tab] wep_key0=\"你的wifi密码\"} 如果你的wifi使用WPA/WPA2加密 12345network={[Tab] ssid=\"你的无线网络名称（ssid）\"[Tab] key_mgmt=WPA-PSK[Tab] psk=\"你的wifi密码\"} 注1：所有符号都是半角符号（英文状态下的符号），“[Tab]”表示按一次Tab键 注2：如果你不清楚wifi的加密模式，可以在安卓手机上用root explorer打开 /data/misc/wifi/wpa/wpa_supplicant.conf，查看wifi的信息。 比如，我的wpa.conf文件是这样的： 12345network={ ssid=\"NETGEAR\" key_mgmt=WPA-PSK psk=\"PASSWORD\"} 最后输入命令启用无线网卡： 1sudo ifup wlan0 可以连无线网了。 重启网络服务 12sudo systemctl daemon-reloadsudo service networking restart 系统 2016-05-10-raspbian-jessie 最后，你就可以在INTERNET上，通过 ssh pi@yourdomain.vicp.net 来登录树莓派了。 折腾3：SSH访问OPENWRT路由器这个本来不应该写在这里的，不过弄完了π也一起弄得op，所以就先记载在这里吧。 修改SSH服务器Dropbear设置这个步骤不是必须的，详见《OpenWrt SSH远程端口转发》。 在OP路由器中的LuCI中选择 系统 –&gt; 管理，勾选 Allow remote hosts to connect to local SSH forwarded ports 选项，保存并应用。 也可以直接修改 Dropbear 配置文件 /etc/config/dropbear 。 加上一句 1option GatewayPorts 'on' 修改OP防火墙设置在OP路由器的 LuCI 中选择 网络 –&gt; 防火墙 –&gt; Traffic Rules，Name 填 SSH ，Protocol 选 TCP ，External port 选 22，保存并应用。 也可以直接修改防火墙配置文件vim /etc/config/firewall 123456config rule option target 'ACCEPT' option src 'wan' option proto 'tcp' option dest_port '22' option name 'SSH' 最后提醒一点，在修改SSH和防火墙设置之前，请设置一个复杂的密码，切记。 折腾4：使用DNSPOD更新外网域名A记录因为我不小心删掉了OP路由器里面关于ORAY的配置，一时间不知道咋办了，就只能暂时换个办法来设置公网域名访问。 找个便宜域名，让树莓派自己更新某域名的 A RECORD 即可，我在 NAMECHEAP 用0.88美金买了个域名，然后发现无法因为消费太少，而不能使用系统自带的ADVANCED DNS服务。当时想的是，采用API的方式自动更新域名记录，NAMECHEAP不行，就只好找其他DNS服务提供商了，后来发现RAGE4好像是免费的，但是申请了之后，需要等待24小时激活，就没等RAGE4批准。 一直以为DNSPOD的域名解析也需要备案，后来才知道，只有域名指向了国内主机空间A记录才需要域名备案，指向其他国外IP地址是不需要备案的，并且最重要的是，DNSPOD有域名的API SDK，正好符合我的使用条件。 我下面的这段PYTHON代码，是从官方抄来的，地址在这里。循环间隔30秒查询一次π获得IP地址与域名的A记录是否一致，如果不一致，就更新域名的A记录。但是我觉得这个频率有点高，并且DNSPOD的免费套餐，1分钟最多30次更新域名解析记录，我也不想超过这个标准。修改成了采用crontab每2分钟执行一次这个脚本的方式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/usr/bin/env python#-*- coding:utf-8 -*-import httplib, urllibimport socketimport timeparams = dict( login_email=\"dns email address\", # 这里替换成你的DNSPOD登录账号 login_password=\"dns password\", # 这里是密码 format=\"json\", domain_id=39421602, # 替换成你需要更改的域名的 domain_id, 可以通过 API Domain.List 获得 record_id=197443695, # 替换成你需要更改域名的 record_id, 可以通过 API Record.List 获得 sub_domain=\"www\", # 替换成你想修改的子域名 record_line=\"默认\",)current_ip = Nonedef ddns(ip): params.update(dict(value=ip)) headers = {\"Content-type\": \"application/x-www-form-urlencoded\", \"Accept\": \"text/json\"} conn = httplib.HTTPSConnection(\"dnsapi.cn\") conn.request(\"POST\", \"/Record.Ddns\", urllib.urlencode(params), headers) response = conn.getresponse() print response.status, response.reason data = response.read() print data conn.close() return response.status == 200def getip(): sock = socket.create_connection(('ns1.dnspod.net', 6666)) ip = sock.recv(16) sock.close() return ipif __name__ == '__main__': try: ip = getip() print ip if current_ip != ip: if ddns(ip): current_ip = ip except Exception, e: print e pass 替换上面脚本中的内容即可，想说的是， domain id 和 record id 也可以分别通过下面的命令行方式获取，直观一些。 1curl -k https://dnsapi.cn/Domain.List -d \"login_email=xxx&amp;login_password=xxx\" 1curl -k https://dnsapi.cn/Record.List -d \"login_email=xxx&amp;login_password=xxx&amp;domain_id=xxx\" 然后，在树莓派的crontab里加入这样一句话即可 1*/2 0 * * * /usr/bin/python /usr/test2.py 这里需要注意几点： 在crontab命令中的环境变量和命令行方式并不一致，所以，最好加上执行命令的全部路径。 还需要通过 sudo su 的方式，切换到root用户下执行 crontab -e，否则修改的pi用户的crontab，效果就达不到了。 最后通过 /etc/init.d/cron restart 来重启crontab cron有两个位置，一个是系统的cron定时任务，文件在 /etc/crontab ，而每个用户的cron，则位于 /var/spool/cron/crontabs/ 目录下，每个用户（pi ，root）分别有cron定时任务的。 系统cron和crontab的重启命令并不相同 对于系统cron sudo systemctl status cron //查看状态sudo systemctl start cron //启动服务sudo systemctl stop cron //停止服务sudo systemctl restart cron //重启服务 对于每个用户的crontab /sbin/service crond start 启动/sbin/service crond stop 停止/sbin/service crond restart 重启服务/sbin/service crond reload 重新加载配置 如果直接使用 crontab -e 打开的cron定时任务文件并不是 /etc/crontab ，而是在 /var/spool/cron/crontabs/ 目录下的文件：pi ，root 。每个用户（pi ，root）分别有cron定时任务的。 关于这个的具体说明，可以看这个帖子。 上面讨论的东西，可能和这个主题帖关系不大，却很重要，所以单独另外开了一个帖子《关于cron和crontab的那些事》来系统的总结下关于cron和crontab的内容。 折腾5:用树莓派GPIO控制PC电源开关这个先写在这里吧，最近几天的想法，主要是因为我的技嘉主板BM5-HD3的WOL功能貌似不好用，只要电源关机或者休眠，网卡灯也一起跟着灭了，弄得我只要不在电脑旁边，就无法开机。然后发现可以使用键盘鼠标或者电源按钮唤醒，然后就当然有了这个折腾了。正在搞，回来总结一下。 折腾6：硬盘格式化、挂载把U盘或者硬盘接在USB扣上，然后运行df -h, 最后那个200多G的就是接的移动硬盘，这个时候可以通过 12sudo mkdir /mnt/hd250g #建立个目录sudo mount /dev/sda1 /mnt/hd250g #把sda1和hd250g连接起来 如何自动挂载硬盘？使用 sudo vim /etc/fstab，可以看到下面这样的内容： 123456proc /proc proc defaults 0 0/dev/mmcblk0p1 /boot vfat defaults 0 2/dev/mmcblk0p2 / ext4 defaults,noatime 0 1/dev/sda1 /home/pi/samba ext4 defaults 0 0# a swapfile is not a swap partition, no line here# use dphys-swapfile swap[on|off] for that 指定 fdisk -l（或者 sudo blkid 命令） 中看到的硬盘盘符并且指定挂载的位置，树莓派开机之后，就能自动挂载了。 然后就遇到了这个错误， 123Mount is denied because the NTFS volume is already exclusively opened.The volume may be already mounted, or another software may use it whichcould be identified for example by the help of the 'fuser' command. 先卸载了，sudo umount -fl /dev/sda1。 因为我这个外接硬盘之前都是用在windows系统下，用的NTFS分区，而linxu一般用的是ext2 ext3 ext4分区。 还有一个挂载硬盘更为稳妥的方式，使用 sudo blkid 命令查看硬盘的UUID，然后在 vim /etc/fstab 中，直接填写UUID=&quot;XXX&quot;即可，这种方式，可以保证在有多个硬盘的情况下，硬盘加载的顺序不会乱。 至于格式化，一句话 1sudo mkfs -t ext4 /dev/sda1 折腾7：树莓派 samba 共享为了方便的共享树莓派上下载的资源，在树莓派上配置 Samba 服务是很好的选择。 安装 samba：12sudo apt-get updatesudo apt-get install samba 调整设置： 1sudo vim /etc/samba/smb.conf 1234567891011121314151617181920[global] workgroup = WORKGROUP security = user unix password sync = no socket options = TCP_NODELAY[homes] comment = Home Directories browseable = no read only = no create mask = 0600 directory mask = 0700 valid users = %S[media] comment = Raspberry Pi SMB path = /media/PI browseable = yes writeable = yes create mask = 0600 directory mask = 0700 guest ok = yes global 域下的 socket options 设置为 TCP_NODELAY 可以得到更好的性能。homes 域泛解析所有的用户目录，当有连接请求时，所有的域名称都会被检索，如果有和用户名相同的域名称，那么该域下的设置将替代 homes 域被解析，如果没有，那么 homes 域的设置将单独被解析。homes 域未设定 path 时默认为用户的 home 目录，browseable = no 表示 homes 作为共享目录名是被隐藏的，而无论 browseable 设置为 yes 还是 no，每个用户的用户名都是作为共享目录名存在的。 samba 的用户权限要过两关，首先是满足 samba 的设置设定的权限，其次是遵循 Linux 文件系统的权限。media 域设置了包括 guest 用户在内的所有用户都有读写权限，但是实际上只有满足 /media/PI 文件系统权限设定的用户才有真正的写权限，这么设置最终造成：/media/PI 文件系统设定的属主、组等有相应权限，比如写，其余用户只有读权限。 为 samba 共享设置密码： 1sudo smbpasswd -a pi 另外，也可以设置 samba 以 xinetd 的方式按需启动，节省资源: 1sudo vim /etc/xinetd.d/netbios-ssn 12345678910service netbios-ssn{ disable = no socket_type = stream protocol = tcp wait = no user = root server = /usr/sbin/smbd instances = 5} 1sudo vim /etc/xinetd.d/netbios-ns 12345678910service netbios-ns{ disable = no socket_type = dgram protocol = udp wait = yes user = root server = /usr/sbin/nmbd instances = 1} 移除 samba 按 init 的方式启动： 1sudo update-rc.d samba remove 至于在 /etc/init.d/ 的自动启动脚本，我黏贴在这里 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#!/bin/sh### BEGIN INIT INFO# Provides: samba# Required-Start:# Required-Stop:# Default-Start:# Default-Stop:# Short-Description: ensure Samba daemons are started (nmbd and smbd)### END INIT INFOset -e# start nmbd, smbd and samba-ad-dc unconditionally# the init scripts themselves check if they are needed or notcase $1 in start) /etc/init.d/nmbd start /etc/init.d/smbd start /etc/init.d/samba-ad-dc start ;; stop) /etc/init.d/samba-ad-dc stop /etc/init.d/smbd stop /etc/init.d/nmbd stop ;; reload) /etc/init.d/smbd reload ;; restart|force-reload) /etc/init.d/nmbd \"$1\" /etc/init.d/smbd \"$1\" /etc/init.d/samba-ad-dc \"$1\" ;; status) status=0 NMBD_DISABLED=`testparm -s --parameter-name='disable netbios' 2&gt;/dev/null || true` SERVER_ROLE=`samba-tool testparm --parameter-name=\"server role\" 2&gt;/dev/null | tail -1 || true` if [ \"$SERVER_ROLE\" != \"active directory domain controller\" ]; then if [ \"$NMBD_DISABLED\" != \"Yes\" ]; then /etc/init.d/nmbd status || status=$? fi /etc/init.d/smbd status || status=$? else /etc/init.d/samba-ad-dc status || status=$? fi exit $status ;; *) echo \"Usage: /etc/init.d/samba {start|stop|reload|restart|force-reload|status}\" exit 1 ;;esac 大家需要的话，可以去我的 github 里面的 randomfiles 库找，具体文件的地址在这里。 发现就算在路由器上开了445和139端口，外网也是不能访问SAMBA共享，所以，只能先暂时安装个VPN，先拨号进去VPN，然后就可以访问SAMBA资源了。具体见折腾9：为树莓派安装VPN支持。 折腾8：获得正确的系统时间在树莓派上打 date 命令可以查看系统的日期时间。由于树莓派没有电池，关机后彻底断电，无法保存时间。树莓派默认安装了 NTP(Network Time Protocol)服务来获取互联网上ntp服务器提供的时间。如果这个时间不准，可以用这个命令校准一下： 1sudo ntpd -s -d 如果时间还是不准确，就用下面命令强制校准 1sudo date --s=\"2016-06-22 12:22:00\" 如果校准了之后，发现时间还是不对，可以先不用强制校准，毕竟这个方法时间不准确，通过 1sudo raspi-config 修改international设置，来设置下市区，选择 Asia - Shanghai 即可，然后重新校准时间。 如果上面的方法校准后，还不行，说明树莓派没有正确的连接NTP服务器。 打开NTP服务配置文件 1sudo nano /etc/ntp.conf 找到以下两行 12# You do need to talk to an NTP server or two (or three).# server ntp.your-provider.example 然后在下面添加以下内容，是一些亲测可用的 NTP 服务器。第一行最后的perfer表示优先使用此服务器，也就是复旦大学的 NTP 服务器。添加之后按 Ctrl + X 保存退出。 12345server ntp.fudan.edu.cn iburst perferserver time.asia.apple.com iburstserver asia.pool.ntp.org iburstserver ntp.nict.jp iburstserver time.nist.gov iburst 最后，重启 NTP 服务w 1sudo /etc/init.d/ntp restart 参考资料安装samba实现文件共享树莓派教程：配置 Samba 局域网共享 折腾10：ARIA2 远程下载","link":"/2016/05/26/working_on_raspberry_pi/"},{"title":"HEXO的站内链接和永久链接","text":"文章更新 20160616-文章第一稿 为什么会有这篇文章最近写了不少的东西，本来很多文章都是把很多章节连在一起放在一个帖子里，但是还是有一些内容要分开写，所以，当想把这些文章总结起来，放在文章末尾做成一个系列的时候，不免要涉及到HEXO站内链接的问题，所以研究下HEXO的链接方式还是很有必要的。 先上几个参考文章吧。 Front-matter 永久链接 怎么样搭建HEXO站内链接 HEXO CHANGE URL 其实大家不用看了，也没啥难懂的，我就随便说说。 具体步骤主要就是要修改2个地方。 为Front-matter区域添加更多变量Front-matter 区域就是一篇Markdown文章开始的那几行，被 --- 包裹的那3行，比如下面这样的。 可以看到，我这里除了 title， date 以及 tags 外，自己添加了一个新的变量 urlname ，这个新的变量用来保存每个文章的英文名字，这样一来可以有利于SEO，二来可以缩短博客文章URL的层数。 默认情况下，hexo博客部署之后的链接形式是这样的 http://yourwebip.com/year/month/day/文章名字/index.html ，而我希望缩减成 http://www.ip.com/post/urlname。 修改_config.yml在 permalink 参数下，可以修改HEXO博客默认的URL样式，原来默认是 :year/:month/:day/:title/ ，我修改为 post/:urlname/。 yml 文件配置改为 permalink: post/:urlname，有的人会觉得我把这么多文章都放在一个post下不会很乱呢？ 首先，几天写一个帖子，一年也就是100篇，10年也就1000篇，你觉得1000个文件或者目录，对百度或者google算是问题么？就算他们觉得多了，你真能坚持10年么？ 其次，有的帖子里，加上了 :category/:urlname/ 的形式，我没有这样做，一来是我觉得在 public 目录下那么多分类的目录，本身我就觉得乱，二来，我的MD文件，在执行 hexo new 的时候，就会写上日期，比如这样 hexo new 20160616-新文章，然后我在用 sublime 打开这个文件进行编辑的时候，会把title中的 20160616- 去掉，这样帖子展示在读者面前的时候，标题就不会还带着个日期了，三来，我就算去掉了 title 中的日期信息，但是不会修改md文件本身的名字，所以，在 _post 目录下，我的文章还是这个样子的。 这样的目录，首先文件的排列是按照时间顺序，我可以了解我每个文章大概什么时间写的，而且就算是文章经过了多次修改，依然可以知道文章第一次的生成时间。其次，每个MD文件在 new 的时候，同时会建立一个和文件名字相同的目录，这样，我可以把每个帖子里的图片，直接扔到这个目录里面去，然后在文章里想插入图片的时候，就可以用下面这样的语法来显示。 1![post目录下的文件命名样式](files-in-post-dir.png) 怎么样？轻松加愉快吧。对了，这个功能需要插件的配合，差点忘记说了，名字叫 hexo-asset-image，具体可以看这篇文章《让Markdown的书写更加顺畅的技巧》，有详细介绍。 好了，经过的修改，hexo g 的时候，生成的文章url就非常清爽了，大家可以看下图感受一下。 总结经过这样的修改，我的这篇文章，最新的url就变成了 http://www.wuliaole.com/post/permalink_and_internal_link_in_hexo，可以被自己站内的其他文章方便地引用了，而且使用额外 front-matter 变量还有一个额外的好处，不会因为文章题目的变化而导致网页的永久链接变化，因为 urlname 是每次 hexo new 之后就订好的，不会轻易变化了，而中文的文件名却可以不受影响，可以随便改变，比如加个 xxx（2017年1月1日最新更新版） 的题目，或者像我这个文章，之前题目里的 永久链接 不小心打成了 用久链接，修改好了，但是英文名字不会变化，也就是url不会变化，这样一来，无论是对搜索引擎还是博客的作者都是大大的方便。","link":"/2016/06/17/permalink_and_internal_link_in_hexo/"},{"title":"MAC系统从BASH转到了OH-MY-ZSH","text":"从bash转向zshMAC下的terminal不是很漂亮，换用了iTerm 2，正好今天iterm从2.1.4升级到了最新的3.0， Zsh和bash一样，是一种Unix shell，但大多数Linux发行版都默认使用bash shell。但Zsh有强大的自动补全参数和自定义配置功能等等，如果想配置zsh，可以借助一个叫Oh-my-zsh的项目，来帮你轻松搞定，Github地址。这里正好记录一下zsh的配置过程，下次如果重新装，也可以有个参考。 直接上代码。 安装oh-my-zsh自动安装oh-my-zsh： 1wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 或者手动安装oh-my-zsh： 1git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh 创建或修改zsh的配置文件如果你已经有一个~/.zshrc文件的话，使用以下命令先做个备份也是好的 1cp ~/.zshrc ~/.zshrc.orig 然后从模板来创建zsh的配置文件 1cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 设置zsh为你的默认的shell1chsh -s /bin/zsh 如果你想切换回来bash，使用下列命令即可。 1chsh -s /bin/bash 上述过程都需要输入你的密码。如果你想看看自己的机子上装了哪些shell，可以使用如下命令： 1cat /etc/shells 重启ITERM或者TERMINAL启用新shell重启并开始使用你的zsh（或者bash），简单的方式是直接打开一个新的终端窗口便可… 至此，GAME OVER. 关于插件配置文件中找到 plugins=(git)，想加什么插件就把名字放里面就是了，比如plugins=(rails git ruby) 就开启了rails，git 和 ruby 三个插件。 更多的介绍，大家可以去这个地方，他写得已经很详细了，没有必要再引用过来重新写一遍了。 自己使用了git colorize 还有 web-search 这几个插件。 参考资料zsh – 给你的Mac不同体验的Terminal！那些我希望在一开始使用 Zsh(oh-my-zsh) 时就知道的","link":"/2016/06/01/switch_from_bash_to_ohmyzsh/"},{"title":"LINUX下的用户管理","text":"Linux下有三类用户 超级用户：root 具有操作系统的一切权限 UID 值为0 普通用户：普通用户具有操作系统有限的权限，UID值 500 - 6000 伪用户：是为了方便系统管理，满足相应的系统进程文件属主的要求，伪用户不能登录系统，UID值 1 – 499 用户管理用户添加与信息用户管理文件：cat /etc/passwd，在此文件中，只定义帐号，不定义口令。 文件中每行定义一个用户，分七个部分： 帐号名称：root 用户密码：x 用户标识码（用户ID）：0 组标识码（用户组ID）：0 用户描述信息：admin 用户家目录：/root 用户环境：/bin/bash 用户信息查看id1id username 查看一个用户的UID, GID以及组信息 参数：g 只显示GID，G 只显示所有组，u 只显示UID 查看用户相关信息finger1finger username 查看用户的相关信息，包括用户的主目录，启动shell，用户名等 参数：l 显示帐号信息，m 忽略真实姓名，p 显示帐号信息，但是不显示计划文件和方案文件内容，s 显示帐号信息（不同格式） 用户口令管理用户口令文件：cat /etc/shadow 此文件只有root用户能访问，分九个部分： 用户名：root 口令：存放加密口令，如果第一个字符是 !，表示该用户不能登录 最后一次修改时间： 最大时间间隔：0 可以随时改变 最小时间间隔：99999 表示永远不过期 警告时间：1周 不活动时间： 失效时间： 保留：最后一个字段是保留的，看以后有没有新功能加入。 创建用户命令useradd或者adduseruseradd 或者 adduser(man useradd) 参数：-u -g -G -d -s -c -e -k -m -M -r 1234567891011121314151617181920212223-b, --base-dir BASE_DIR #新账户的主目录的基目录-c, --comment COMMENT #新账户的 GECOS 字段-d, --home-dir HOME_DIR #新账户的主目录-D, --defaults #显示或更改默认的 useradd 配置-e, --expiredate EXPIRE_DATE #新账户的过期日期-f, --inactive INACTIVE #新账户的密码不活动期-g, --gid GROUP #新账户主组的名称或 ID-G, --groups GROUPS #新账户的附加组列表-h, --help #显示此帮助信息并推出-k, --skel SKEL_DIR #使用此目录作为骨架目录-K, --key KEY=VALUE #不使用 /etc/login.defs 中的默认值-l, --no-log-init #不要将此用户添加到最近登录和登录失败数据库-m, --create-home #创建用户的主目录-M, --no-create-home #不创建用户的主目录-N, --no-user-group #不创建同名的组-o, --non-unique #允许使用重复的 UID 创建用户-p, --password PASSWORD #加密后的新账户密码-r, --system #创建一个系统账户-R, --root CHROOT_DIR #chroot 到的目录-s, --shell SHELL #新账户的登录 shell-u, --uid UID #新账户的用户 ID-U, --user-group #创建与用户同名的组-Z, --selinux-user SEUSER #为 SELinux 用户映射使用指定 SEUSER 也可以通过手动方式添加一个用户，需要以下四个步骤： 在/etc/passwd中添加一条记录 创建用户主目录 在用户主目录中设置默认的配置文件 设置用户初始口令 用户帐号的维护(删改)12345678910passwd username #设置用户密码（注意：没有设置密码的用户不能登录）userdel username #删除用户usermod -l newName username #新的登录名称usermod -L username #锁定用户usermod -U username #解锁用户usermod -R, --root CHROOT_DIR #更改用户的家目录directory to chroot intousermod -s, --shell SHELL #更改用户使用的shell，比如改为/sbin/nologin则禁止该用户ssh接入passwd -l username #锁定用户的密码（只有根用户才能进行此操作）passwd -u username #解锁用户的密码（只有根用户才能进行此操作）passwd -d username #删除已命名帐号的密码（只有根用户才能进行此操作） 变化用户身份1su userName 说明：从管理员到普通用户不用使用密码；从普通用户到其他用户需要使用密码 这样，至改变用户身份，环境变量不变； 1su -userName 完全转变，包括身份和环境变量 只允许root用户登录 可以在/etc/目录下建立一个名为nologin的文件 1touch /etc/nologin 解除方法，删除nologin文件即可 1rm -rf /etc/nologin 用户组管理用户组分两类： 私有组：当在创建一个新用户user时，若没有指定他所属于的组，Linux就建立一个和该用户同名的私有组 标准组：标准组可以容纳多个用户，若使用标准组，在创建一个新用户时，就应该指定该用户所属于的组 用户组的管理文件位置：/etc/group 分为四个部分： 组名：用户登录时所在的组名 组口令：一般不使用 组标识码（GID） 组内用户列表：属于改组的所有用户列表 添加用户组两种方法： useradd username 这种方法会建立一个和usernmae同名的私有组 groupdadd groupname 正统的方法，建立一个组 12useradd username #默认建立username用户组groupadd groupname #添加一个用户组 修改组名1groupmod -n newName groupName 删除组帐号groupdel 组帐号名称 #注意：删除的帐号必须存在，且不能是某个用户的私有组 添加用户到组1gpasswd -a userName groupName #a是添加的意思 从组中删除用户1gpasswd -d userName groupName #d是删除的意思 查看某个用户属于哪个组1groups userName 查看某个组有哪些用户12tail 5 /etc/group #显示最后5个组tail /etc/group #默认显示最后10行","link":"/2016/06/18/user_management_in_linux/"},{"title":"VIM常用命令","text":"文章更新 20160602-初次成文 20160607-调整了格式，加入一个VIM小游戏 20160831-格式调整，丰富内容 VIM常用命令Insert(插入)模式这个模式就是常用的打字的地方，嗯，就是这样。 进入 i -&gt; 在光标前插入 I -&gt; 在句首插入 a -&gt; 在光标后插入 A -&gt; 在句尾插入 离开 Esc Ctrl + c Ctrl + [ Normal模式进入vim时候的默认模式，在这个模式下可以随意使用命令 简单移动 h j k l -&gt; 左 下 上 右 0(数字零) -&gt; 移动光标到行头 $ -&gt; 移动光标到行尾 gg -&gt; 到第一行 G -&gt; 到最后一行 w -&gt; 到下一个单词的开头。 e -&gt; 到下一个单词的结尾。 简单操作 dd -&gt; 剪切当前行 yy -&gt; 赋值当前行 p -&gt; 粘贴 u -&gt; 撤销 . -&gt; 上次命令的重复 命令的组合 daw -&gt; 删除当前单词 2dd -&gt; 删除包含当前行在内的2行 3p -&gt; 粘贴文本3次 100idesu [ESC] → 会写下 “desu” 100次 0y$ -&gt; 从行头拷贝到本行最后一个字符 visual模式进入 v -&gt; 连续选择模式 V -&gt; 连续行选择模式 v从当前字符开始选，以后每次选中一行，但第一次选择的是从当前字符开始的行。而V从当前行开始选择，直到光标结束之处。 Ctrl + v -&gt; 块选择模式，比如可以在多行之前的某个未知，插入注释 块选择 Ctrl+v 在表格中删除指定列非常有用 离开 Esc Ctrl + c Ctrl + [ &gt; 和 &lt;将选中字符右移或左移 shiftwidth位置 d 与 D 的区别d只删除选中的字符，而D删除选中字符所在行的所有字符，c和C，y和Y同理 select模式（选择模式）进入 gh gH g(Ctrl + h) 切换 Ctrl + o -&gt; 临时切换到可视化模式执行一个命令 Ctrl + g -&gt; 切换到可视化模式 光标移动 fx -&gt; 移动光标到当前行的下一个 x 处。很明显，x 可以是任意一个字母，而且你可以使用 ; 来重复你的上一个 f 命令。 tx -&gt; 和上面的命令类似，但是是移动到 x 的左边一个位置。 Fx -&gt; 和 fx 类似，不过是往回找。 w -&gt; 光标往前移动一个词。 b -&gt; 光标往后移动一个词。 0 -&gt; 移动光标到当前行首。 ^ -&gt; 移动光标到当前行的第一个字母位置。 $ -&gt; 移动光标到行尾。 ) -&gt; 移动光标到下一个句子。 ( -&gt; 移动光标到上一个句子 替换 :s/hello/world 替换当前行中第一个hello为world :%s/hello/world 替换每一行中第一个hello为world :s/hello/world/g 替换当前行中所有的hello为world :%s/hello/world/g 替换每一行中所有的hello为world :%s/hello/world/gc 找到当前文件中所有的hello，并逐一询问用户是否要替换 内容提取 :r !date 将当前时间插入到当前文件 :r /path/to/src.file 将src.file里的内容输出到当前文件 解决vi/vim中粘贴会在行首多很多缩进和空格的问题在拷贝前输入:set paste (这样的话，vim就不会启动自动缩进，而只是纯拷贝粘贴），然后输入i，再进行黏贴，就不会有格式错乱的问题了。 拷贝完成之后，输入:set nopaste (关闭paste) 总结VIM的命令甚多，组合也很多，记忆是不能长时间记住的。唯一的捷径就是多多使用，用的多了，使用这些命令时就像手拿筷子一样，变成了本能。 参考文件 移动组周技术分享-代码效率","link":"/2016/06/02/common_used_shortkeys_for_vim/"},{"title":"OSX下配置VSCode的PHP调试环境","text":"文章更新 20160620-初次成文，基本照搬了WIN下的设置，文章比较杂乱，没有图 20160823-补充图片，更新内容 20170727-查漏补缺 为什么会有这篇文章因为自己在MAC下不能写WinForm的程序，所以用来练习PHP比较顺手，而正好也在接触ThinkPHP框架，就在MAC下重温一次安装和代码调试过程。 PS: Windows系统下的PHP环境配置，请戳这里 在OS X下配置PHP环境请看我的另外一个帖子《MAC OS系统使用Homebrew配置NGINX PHP和MYSQL》，环境包括安装PHP 5.6，NGINX, MYSQL 下载并安装VSCodeVSCode下载地址，选择OSX版本下载。 下载安装后，双击解压缩，最新版本的VSCode会自动提示是否要把程序移动到Application文件夹以保持下载文件夹的干净，同意。 小技巧，运行VSCode之后，按 F1 键，输入命令 Shell命令，提能提示后选择 Shell命令：在PATH中安装 code 命令，这样处理之后，在shell下的任意地址都可以通过输入 code . 命令打开VSCode并把当前目录作为工作目录。 打开程序后，依次选择 CODE 首选项 用户设置，从左侧把这样几个设置复制到右侧去，然后做相应的修改。 123456789// 将设置放入此文件中以覆盖默认设置{ \"editor.fontFamily\": \"Monaco, 'Courier New', monospace\", \"editor.fontSize\": 14, \"files.autoSave\": \"afterDelay\", \"files.autoSaveDelay\": 1000, //下面这句是指出Php的安装路径，为了XDEBUG调试用的 \"php.validate.executablePath\": \"\\usr\\local\\sbin\\php56\" } 在VSCode安装php调试插件打开VSC，按Command+shift+p（这个快捷键和sublime的一样），输入ext install php debug，回车后会在VSCODE STORE里搜索 php debug为关键词的组件，我装了PHP DEBUG，版本是1.9.4 我主要装了debug和format。 然后vsc提示安装成功，重启vsc便可以启用相关扩展。 添加php调试参数重启了vsc，打开一个Php,会看到vsc的一个提示。 这里说点题外话，在osx下，用finder默认是看不到像 /var /tmp 这些隐藏文件夹的，如果你希望在finder中看到这些目录，请在terminal下执行 defaults write com.apple.Finder AppleShowAllFiles YES，然后按住Option键，单击Dock上的Finder图标不放，大概2秒后将在Finder图标上打开菜单，最下面多了一行”重新启动”，单击启动FINDER就可以看到隐藏的目录和文件了。想关闭也简单，YES改成NO再执行一次就好了。 需要在用户设置里添加一条配置 php.validate.executablePath，让php插件可以找到php的路径。 按照上面添加的配置，找到autosave的方式，打开用户设置，在右侧添加一句 1\"php.validate.executablePath\": \"\\usr\\local\\sbin\\php56\" 记住如果仅有一条配置，最后一条json配置，末尾没有逗号。 不解释，直接上图。 安装xDebug在MAC系统下，很多程序都可以使用Homebrew来安装，xDebug也不例外。 命令是 12345brew tap josegonzalez/phpbrew tap homebrew/dupesbrew tap homebrew/versionsbrew tap homebrew/homebrew-phpbrew install php56-xdebug 因为xDebug默认同样使用 9000 端口，这在MAC OS下默认的 PHP-FPM 的 9000 端口正好产生了冲突，所以我们需要修改一下xDebug使用的端口（如果你打算修改 PHP-FPM 的端口？我试过了，PHP无法解析了） 找到你的PHP.INI文件，这个默认一般在/usr/local/etc/php56/路径下，如果找不到，可以通过find / -name php.ini命令来查找该文件的位置。 找到之后，在末尾添加几行 12345678910[xdebug] xdebug.default_enable=1 xdebug.remote_enable=1 xdebug.remote_handler=dbgp xdebug.remote_host=localhost xdebug.remote_port=9001 ;这里要记得不能使用默认的9000端口 xdebug.remote_autostart=1 xdebug.remote_log=\"/var/log/xdebug.log\" ;xdebug的日志文件 xdebug.idekey=\"vscode-xdebug\" ;目前我也不清楚干嘛用的 zend_extension=\"/Applications/MAMP/bin/php/php5.4.10/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so\" 并且，由于xDebug和Zend有冲突，所以请把zend的相关参数要注释掉。 典型就是如下几条： 123456[Zend];zend_extension_ts = \"C:\\Program Files\\xampp\\php\\zendOptimizer\\lib\\ZendExtensionManager.dll\";zend_extension_manager.optimizer_ts = \"C:\\Program Files\\xampplite\\php\\zendOptimizer\\lib\\Optimizer\";zend_optimizer.enable_loader = 0;zend_optimizer.optimization_level=15;zend_optimizer.license_path = 如果上面的已经被注释掉了，就OK了。 完成后，进入VSCODE，依次选择左侧的 Debug按钮，点击齿轮，在下拉菜单中选择 PHP 然后，会自动生成一个launch.json文件 12345678910111213141516171819{ \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Listen for XDebug\", \"type\": \"php\", \"request\": \"launch\", \"port\": 9001 }, { \"name\": \"Launch currently open script\", \"type\": \"php\", \"request\": \"launch\", \"program\": \"${file}\", \"cwd\": \"${fileDirname}\", \"port\": 9001 } ]} 唯一需要注意的，就是把 port 也修改为 9001（和你在php.ini 文件中的 xdebug.remote_port=9001一致即可。 如何确定xDebug安装成功用浏览器打开 http://localhost/phpinfo.php 然后在结果中使用 Cmd+F 搜索 xDebug ，如果存在则说明配置成功。 再上个图 参考资料 xDebug百度百科词条 NETBEANS官方出的XMAPP配置XDEBUG说明 XDEBUG官方一种贴心的配置方法","link":"/2016/06/20/config_php_debug_environment_on_mac_osx_with_vscode/"},{"title":"使用GIT管理发布阿里云CENTOS网站代码","text":"文章更新20160616-第一次更新20160621-添加了SSH免密码连接的方式 服务器安装git我的阿里云服务使用的centos 6.5 x64，先更新yum 1yum update centos 6以上的yum已经有了git源，所以不用担心，直接安装 1yum install git 查看git版本 1git --version 目前版本是1.7.1，然后配置用户名和密码 12git config --global user.name \"testuser\"git config --global user.email \"testuser@example.com\" 查看安装后的信息 12cd ~cat .gitconfig 或者使用下面一条命令 1git config --list 本地开发机器上创建git目录1git init repo.git 这个repo用来以后放调试代码。 在centos服务器上创建git管理账号第一步，先创建git账号，方便管理。关于Linux的所有用户和用户组的，可以参考这篇文章《LINUX下的用户管理》。 12sudo groupadd git #新建一个git用户组sudo useradd git -m -s /sbin/nologin -d /home/gits -g git #新建一个git用户，创建目录/home/gits，并禁止shell登录，添加到git用户组 当在创建一个新用户user时，若没有指定他所属于的组，Linux就建立一个和该用户同名的私有组 解释一下，-m表示创建用户主目录，即如果-d后面的目录不存在，这里就是创建的意思，-s是指定用户的登录shell，这里写-s /sbin/nologin 表示用户无法使用ssh登录，-d表示该账号的主目录， -g表示将该用户加入git组 如果希望恢复git用户bash登录，可以使用 sudo usermod -s /bin/bash username 。 是不是看得有点云里雾里的？其实我也有点糊涂，所以特意自己整理了一篇关于linux用户管理的帖子，大家可以移步这里。 然后把上面的几个命令，拆解成了多句话，虽然不够简洁，但是意思就容易明白多了。 12groupadd gits #添加gits用户组useradd git1 -s /sbin/nologin -d /home/git -g gits #创建用户git1，并且添加到gits组，指定其主目录为/home/git目录 创建git远程仓库第二步，新建一个git仓库，这个仓库叫“git bare repository”，git裸仓库。 1234cd /home/gitchown -R git1:gits git #改权限cd gitgit --bare init 这个仓库和本地的那个不一样，可以发现本地的那个仓库有在project下有一个.git的目录，而project下还有自己的代码。但是这个git裸仓库它没有自己的project，他只有和本地.git目录下一样的内容。这个git目录主要是用来保存用户git的更新的，而不是保存代码的。 使用post-receive脚本更新代码第三步，当客户端push到服务器来时，自动更新网站部署的工作目录。 12$ mkdir /alidata/www.xiaowei.com #网站的目录地址$ vim hooks/post-receive #新建目录以及文件，输入以下内容 12#!/bin/shGIT_WORK_TREE=/alidata/www/xiaowei.com git checkout -f 为上述脚本添加可执行权限 1$ chmod +x hooks/post-receive post-receive 这个脚本在提交文件到git仓库时，会运行文件内的代码，所以通过这样的方法，我们在客户端push提交代码后，就能自动更新网站的文件了。 本地仓库和远程仓库关联并推送在本地开发电脑上，建立本地git目录 1234mkdir xiaowei.comcd xiaowei.comgit initgit clone ssh://git1@www.zenmeban.com:22/home/git #注意，端口号22后面不能有冒号 会看到提示 warning: You appear to have cloned an empty repository. 不用管，因为本来远程仓库就是空的。 建立关联 123456git remote add origin ssh://git1@www.zenmeban.com:22/home/gittouch READMEecho \"git test\" &gt;&gt; READMEgit add READMEgit commit -m 'first README file'git push origin master 会问你git1用户的密码，这个时候需要在远程服务器上使用passwd为git1指定个密码，否则这个用户还处于锁定状态。 如果遇到了下面的错误 123456error: insufficient permission for adding an object to repository database ./objectsfatal: failed to write objecterror: unpack failed: unpack-objects abnormal exitTo ssh://git1@www.zenmeban.com/home/git ! [remote rejected] master -&gt; master (n/a (unpacker error))error: failed to push some refs to 'ssh://git1@www.zenmeban.com/home/git' 说明git1权限不足，通过ls -all查看git目录，发现很多用户是属于root的，可执行chmod给git1分配权限 12cd /home/gitsudo chown -R git1:gits * 好了，现在再此push，看到下面的提示 12345Writing objects: 100% (3/3), 203 bytes | 0 bytes/s, done.Total 3 (delta 0), reused 0 (delta 0)remote: error: git checkout-index: unable to create file README (Permission denied)To ssh://git1@www.zenmeban.com/home/git* [new branch] master -&gt; master 说明/home/git可以写了，但是check out部分，也就是写入/alidata/www/xiaowei.com(你的开发目录)有问题，一看就是权限问题。 再次使用chown把你的工作目录的权限分配一下就可以了。 然后，本地添加个新文件，然后重新push一下，完美。 使用ssh免密码连接git库并且推送生成一对儿rsa公钥密钥 1ssh-keygen -t rsa 三次输入回车，完事。 这里有一个重要的问题，需要总结一下，你在某个git目录下生成的ssh key，生成的用户名就是那个，比如我在xiaowei.com这个目录下，git保存的账号是git1。 12Your identification has been saved in /home/git/.ssh/id_rsa. #私钥保存位置Your public key has been saved in /home/git/.ssh/id_rsa.pub. #公钥保存位置 需要把公钥复制到服务器上的.ssh文件里面去。 这里学习一个新的命令 scp。 1scp -P port /home/user/filename user@serverip:/home/user/dirname 以上端口中： P 为参数，port端口。这里要注意，因为 ssh 命令后面的 ssh -p229 这里的p是小写的，而scp命令里的P是大写的。 user 为 ssh user。 serverip 为远程服务器ip或者域名。 /home/user/filename 为远程服务器的文件名。 /home/user/dirname 为本地服务服务器的目录名字。 该命令的作用就是将本地的文件复制到远程的服务器地址。 1scp -P 22 /home/git/.ssh/id_rsa.pub git1@www.zenmeban.com:~/.ssh 通过ssh-keygetn生成一堆新的rsa钥匙，注意，远程服务器需要在对应用户的.ssh目录下的authorized_keys文件里，写上本地要连接的用户对应的公钥。 然后，可以通过 ssh -i ~/.ssh/git1_rsa git1@www.zenmeban.com 检测你的连接是否成功。 另外还可以通过 ssh -vT git1@www.zenmeban.com 调试模式来看看错误出在哪里。 这里正好介绍一下本地.ssh目录下的config文件，这个文件可以告诉ssh去哪里找私钥，如果不配置好这个文件，ssh连接是无法正确免敲密码的。 123456789101112131415161718Host github HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/githubHost coding HostName git.coding.net PreferredAuthentications publickey IdentityFile ~/.ssh/codingHost aliyunroot HostName www.zenmeban.com PreferredAuthentications publickey IdentityFile ~/.ssh/aliyun_root User rootHost aliyungit1 HostName www.zenmeban.com PreferredAuthentications publickey IdentityFile ~/.ssh/aliyun_git1 User git1 一段配置对应一个要连接的远程域名，当你要通过不同用户连接同一个远程服务器的时候，就像上面的配置项3和4中那样，就需要通过一个User配置项，来区分不同的用户名，以便ssh可以找到不同的私钥了。 比如，ssh aliyunroot 就会直接使用git1用户连接阿里云的服务器了。 好了，GAME OVER。 参考文章 How to Install Git on CentOS 6 使用git同步管理自己的网站 How To Set Up Automatic Deployment with Git with a VPS","link":"/2016/06/17/update_aliyun_centos_web_code_by_git/"},{"title":"MAC OS系统使用Homebrew配置NGINX PHP和MYSQL","text":"文章更新 20160701-初次成文 20160704-完整配置完成 20160708-整理小错误，理顺一些不通顺的地方 20160815-系统升级到了CAPITAN，一些地方重新修改 20160928-补充PHPMYADMIN的使用注意事项 20161006-补充xDebug和VSCode的配置内容 20170218-修改了一些小错误 20170728-调整Homebrew内容到其他帖子 为什么会有这篇文章MAC OS系统下，全部使用Homebrew来配置NGINX, PHP以及MYSQL的文章并不多，所以自己总结了整个安装过程。本文针对EI CAPITAN或者更高的MAC OS版本。 确认Homebrew就绪Homebrew的安装可以参见另外一个帖子 删除旧版PHP在安装新版PHP之前，首先要删掉系统自带的旧版PHP程序，我的系统是 OSX EI CAPITAN，PHP版本是5.5.38，根据网上的一篇文章，写了个脚本 为了方便，最好先切换到root账户下。 12345678910111213141516cd /private/etc/ rm -rf php-fpm.conf.default php.ini php.ini.defaultcd /usr/bin/ rm -rf php php-config phpdoc phpizecd /usr/include rm -rf phpcd /usr/librm -rf phpcd /usr/sbin rm -rf php-fpmcd /usr/share rm -rf phpcd /usr/share/man/man1 rm -rf php-config.1 php.1 phpize.1cd /usr/share/man/man8 rm -rf php-fpm.8 上述操作，在EI CAPITAN之前的MAC版本下执行不会遇到问题，而在EI CAPITAN下会遇到Operation not permitted的权限错误。这是因为自从EI CAPITAN开始，MAC系统默认开启了System Integrity Protection（SIP，系统完整性保护），从而导致用户无法在系统目录下执行操作。 若要关闭SIP，需重启系统，进入 recover模式（重启之后按住 Command+r），在 工具 中找到 terminal 执行 csrutil disable 命令，然后重启，SIP保护就被关闭了。 安装PHP和PHP-FPM因为Homebrew的库中的PHP默认没有带PHP-FPM，因此需要首先tap（或者说登记）一个特殊的PHP库 12brew tap homebrew/dupesbrew tap homebrew/homebrew-php 更多类库，可以到GITHUB上查看更多，链接戳这里 现在，就可以使用下面命令来安装PHP-FPM了，并且为了保证同时编译MySQL，以及不配置默认的apache，需要使用下面的参数： 1brew install php56 --without-apache --with-fpm --with-mysql 上面的意思就是安装PHP 5.6，不装APACHE，附带FPM以及MYSQL。 安装时间视网络和机器速度而定，我装了大约半个小时。 错误：Cannot find libz123456checking if the location of ZLIB install directory is defined... noconfigure: error: Cannot find libzREAD THIS: https://git.io/brew-troubleshootingIf reporting this issue please do so at (not Homebrew/brew): https://github.com/Homebrew/homebrew-php/issues 说明安装程序无法找到libz库，在新的OS系统下，这通常是因为xcode的更新到7或者8之后，缺少命令行工具造成的 运行 12xcode-select --install brew upgrade 继续 错误：insufficient permission for adding an object to repository database .git/objects1234error: insufficient permission for adding an object to repository database .git/objectsfatal: failed to write objectfatal: unpack-objects failedError: Fetching /usr/local/Library/Taps/homebrew/homebrew-core failed! 这个错误很典型，在Homebrew的使用过程中很常见，稍微留意就可以知道和上面遇到的错误一样，都是Homebrew缺少某目录的操作权限，可以参考上面的错误处理方式。 输入命令 1sudo chown -R $(whoami) /usr/local/Library/Taps/homebrew/ 错误：The brew link step did not complete successfully1234567891011==&gt; make installError: The `brew link` step did not complete successfullyThe formula built, but is not symlinked into /usr/localCould not symlink./usr/local/Library/LinkedKegs is not writable.You can try again using: brew link php56==&gt; CaveatsThe php.ini file can be found in: /usr/local/etc/php/5.6/php.ini 按照系统提示，执行 brew link php56，让Homebrew重新链接相应的文件。 123Linking /usr/local/Cellar/php56/5.6.23...Error: Could not symlink ./usr/local/Library/LinkedKegs is not writable. 还是权限问题，继续 sudo chown -R $(whoami) /usr/local/Library/LinkedKegs，再次执行 brew link php56，搞定，继续。 PHP-FPM的启动和使用好了，终于顺利装好了php56，静下心来看看输出的信息。 需要注意的是，PHP 5.6的安装，连带一起安装了PHP-FPM，这个东西怎么说呢，我自己也不是很理解，可以说是一种替代了FASTCGI的控制器，但是什么是FASTCGI，或者什么是CGI，我也说不清楚，反正就是多了个PHP-FPM。 1234567891011121314151617181920212223242526272829303132333435363738✩✩✩✩ Extensions ✩✩✩✩If you are having issues with custom extension compiling, ensure thatyou are using the brew version, by placing /usr/local/bin before /usr/sbin in your PATH: PATH=\"/usr/local/bin:$PATH\"PHP56 Extensions will always be compiled against this PHP. Please install themusing --without-homebrew-php to enable compiling against system PHP.✩✩✩✩ PHP CLI ✩✩✩✩If you wish to swap the PHP you use on the command line, you should add the following to ~/.bashrc,~/.zshrc, ~/.profile or your shell's equivalent configuration file: export PATH=\"$(brew --prefix homebrew/php/php56)/bin:$PATH\"✩✩✩✩ FPM ✩✩✩✩To launch php-fpm on startup: mkdir -p ~/Library/LaunchAgents cp /usr/local/opt/php56/homebrew.mxcl.php56.plist ~/Library/LaunchAgents/ launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.php56.plistThe control script is located at /usr/local/opt/php56/sbin/php56-fpmOS X 10.8 and newer come with php-fpm pre-installed, to ensure you are using the brew version you need to make sure /usr/local/sbin is before /usr/sbin in your PATH: PATH=\"/usr/local/sbin:$PATH\"You may also need to edit the plist to use the correct \"UserName\".Please note that the plist was called 'homebrew-php.josegonzalez.php56.plist' in old versions of this formula.To have launchd start homebrew/php/php56 now and restart at login: brew services start homebrew/php/php56==&gt; Summary🍺 /usr/local/Cellar/php56/5.6.23: 330 files, 38M, built in 5 minutes 30 seconds 在最后更新这个帖子的时候，PHP-FPM又更新到了5.6.24。 大概看了下上面的输出信息，有几个需要注意的地方： 由于MAC OS 10.8或者更新的系统，预装了PHP-FPM，所以如果想使用brew安装的PHP-FPM，需要确保用户目录/usr/local/bin位于系统路径之前(至少要前于 /usr/sbin)，比如执行 PATH=&quot;/usr/local/bin:$PATH&quot; 如果你希望在BASH或者ZSH的控制台环境下使用PHP命令行工具，需要在.bashrc或者.zshrc文件的最后添加一行 export PATH=&quot;$(brew --prefix homebrew/php/php56)/bin:$PATH&quot; 如果需要PHP-FPM随系统自启，则依次执行3条命令： mkdir -p ~/Library/LaunchAgents #参数p是根据需要创建中间目录。 ln -s /usr/local/opt/php56/homebrew.mxcl.php56.plist ~/Library/LaunchAgents/。 launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.php56.plist。关于参数w的用法，我使用man launchctl看了一下，得到了这段解释 Overrides the Disabled key and sets it to false or true for the load and unload subcommands respectively. In previous versions, this option would modify the configuration file. Now the state of the Disabled key is stored elsewhere ondisk in a location that may not be directly manipulated by any process other than launchd. 意思是说这个参数将改写disable key参数，在加载plist之后将其改写为false，在卸载plist之后将其改写为true。在更早的版本中，使用这个参数将改写服务的配置文件。现在，disabled key参数将保存在磁盘上的某个位置，除了launchd程序外，其他程序并不可以直接对其进行操作。 说点其他的，在配置php on mac的整个过程中，基本上有3个plist文件需要launchctl进行加载或者卸载。分别是homebrew.mxcl.nginx.plist、homebrew.mxcl.php56.plist和homebrew.mxcl.mysql.plist，这三个文件存放的位置位置并不尽相同，nginx.plist存放在/Library/LaunchDaemons/目录下，而php56.plist和mysql.plist则通过软链接到了~/Library/LaunchAgents目录下，并且，nginx.plist文件修改owner为root，而后两者则没有，但是却带了-w参数。关于LaunchDaemon和LaunchAgents的区别，网上有两个篇文章讲解得不错，分别是： * [了解LaunchDaemons](http://afoo.me/posts/2014-12-12-understanding-launch-daemons-of-macosx.html) * [LaunchDaemons vs LaunchAgents](http://www.grivet-tools.com/blog/2014/launchdaemons-vs-launchagents/) 控制命令脚本位于 /usr/local/opt/php56/sbin/ 下，名称为php56-fpm 关于第二点，多说几句。如果你使用bash shell，添加的命令为 1echo 'export PATH=\"/usr/local/sbin:$PATH\"' &gt;&gt; ~/.bash_profile &amp;&amp; . ~/.bash_profile 如果你的ZSH shell，命令是 1echo 'export PATH=\"/usr/local/sbin:$PATH\"' &gt;&gt; ~/.zshrc &amp;&amp; . ~/.zshrc 如果你也不确定自己用的哪种shell，使用 echo $SHELL 命令查看。 错误分析找不到PHP-FPM的配置文件如果运行PHP-FPM提示找不到配置文件，则可以通过 find / | grep php-fpm.conf.default，看看默认文件在哪里，然后CP一个过去。 1cp /usr/local/etc/php/5.6/php-fpm.conf.default /usr/local/etc/php/5.6/php-fpm.conf 或者 1php-fpm --fpm-config /usr/local/etc/php/5.6/php-fpm.conf #指定配置文件的位置 日志打开错误然后，再次手动运行php-fpm，又遇到新的错误。 123[04-Jul-2016 23:22:25] ERROR: failed to open error_log (/usr/local/var/log/php-fpm.log): No such file or directory (2)[04-Jul-2016 23:22:25] ERROR: failed to post process the configuration[04-Jul-2016 23:22:25] ERROR: FPM initialization failed 错误信息显示：不能正确的打开”日志”文件，原因是php-fpm在 /usr/local/var/log/ 找不到名为php-fpm.log的日志文件。 打开配置文件， 1vim /usr/local/etc/php/5.6/php-fpm.conf 修改文件中 error_log 项，默认前缀是 /usr/var，但并没有这个路径，要修改为 /usr/local/var 12error_log = /usr/local/var/log/php-fpm.logpid = /usr/local/var/run/php-fpm.pid 或者不修改配置文件中配置项的路径，在php-fpm的运行参数中添加参数prefix，指定放置运行时文件的相对路径前缀 1php-fpm --fpm-config /usr/local/etc/php-fpm.conf --prefix /usr/local/var 到此，php-fpm守护进程已经基本可以正确的启动了。 再次运行 php-fpm -v，已经可以成功得到版本号了，5.6.26，GAME OVER. 如果还不放心，可以通过查看内存中端口号为9000的进程，如果看到了PHP-FPM，则说明确实运行成功了。 1lsof -Pni4 | grep LISTEN | grep php 或者简单的 1lsof -i :9000 结果 123php-fpm 35370 root 7u IPv4 0x7a8545f6d5d08f1d 0t0 TCP 127.0.0.1:9000 (LISTEN)php-fpm 35371 _www 0u IPv4 0x7a8545f6d5d08f1d 0t0 TCP 127.0.0.1:9000 (LISTEN)php-fpm 35372 _www 0u IPv4 0x7a8545f6d5d08f1d 0t0 TCP 127.0.0.1:9000 (LISTEN) 这里提前说一下这个端口9000的问题，我在调试PHP代码的时候使用了xDebug，但是如果按照默认设置的话，经常无法正常调试，后来终于发现是因为xDebug也使用了9000端口，我个人是把XDEBUG的端口修改为了9001才正常的。话说网上的说法是XDEBUG先定义的9000端口，然后PHP-FPM蛮横的也用了9000…. 安装MySQL1brew install mysql 设置MySQL随你账户的启动和停止。 1ln -sfv /usr/local/opt/mysql/*.plist ~/Library/LaunchAgents 想手动启动的话，运行： 1launchctl load ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist 使用mysql -V或者--version查看MySQL版本(注意不要错写成mysql -v因为小写v是–Verbose的缩写，而不是Version的缩写) 增强Mysql安全性为了增强Mysql服务器的安全性，我们可以通过运行 secure_mysql_installation 这个程序，来修改root密码，去掉匿名账户，并且关闭远程root登录权限。 运行后，会进入下面的设置过程（2016年8月15日更新）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162Securing the MySQL server deployment.Connecting to MySQL using a blank password.VALIDATE PASSWORD PLUGIN can be used to test passwordsand improve security. It checks the strength of passwordand allows the users to set only those passwords which aresecure enough. Would you like to setup VALIDATE PASSWORD plugin?Press y|Y for Yes, any other key for No: #设置一个 VALIDATE PASSWORD 的插件帮你完成任务，选YThere are three levels of password validation policy:LOW Length &gt;= 8MEDIUM Length &gt;= 8, numeric, mixed case, and special charactersSTRONG Length &gt;= 8, numeric, mixed case, special characters and dictionary filePlease enter 0 = LOW, 1 = MEDIUM and 2 = STRONG: #我这里选的3，最强的New password: #输入密码Re-enter new password: #再次输入密码Estimated strength of the password: 100 #显示你设置的密码强度Do you wish to continue with the password provided?(Press y|Y for Yes, any other key for No) : #认可的话，选择Y继续By default, a MySQL installation has an anonymous user,allowing anyone to log into MySQL without having to havea user account created for them. This is intended only fortesting, and to make the installation go a bit smoother.You should remove them before moving into a productionenvironment.Remove anonymous users? (Press y|Y for Yes, any other key for No) : #是否删掉匿名账户，YSuccess.Normally, root should only be allowed to connect from'localhost'. This ensures that someone cannot guess atthe root password from the network.Disallow root login remotely? (Press y|Y for Yes, any other key for No) : #禁止ROOT账户远程登录，YSuccess.By default, MySQL comes with a database named 'test' thatanyone can access. This is also intended only for testing,and should be removed before moving into a productionenvironment.Remove test database and access to it? (Press y|Y for Yes, any other key for No) : #删除测试数据库以及相应的访问权限，Y - Dropping test database...Success. - Removing privileges on test database...Success.Reloading the privilege tables will ensure that all changesmade so far will take effect immediately.Reload privilege tables now? (Press y|Y for Yes, any other key for No) : #重新载入权限以测试上述设置是否成功，YSuccess.All done! 测试Mysql连接命令 mysql -uroot -p，输入刚才设置的密码 123456789101112131415Enter password:Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 10Server version: 5.7.14 HomebrewCopyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; quitBye 如何修改mysql的root账号密码使用上面的命令(mysql -uroot -p)进入mysql命令行界面，然后输入 1set password for 'root'@'localhost'=password('passwd'); 显示结果 1Query OK, 0 rows affected, 1 warning (0.00 sec) 不用担心显示0 rows affected, 密码是改了的，只是需要继续刷新权限。 1flush privileges; 显示结果 1Query OK, 0 rows affected (0.00 sec) 显示的是0 rows affected，别担心，quit推出mysql命令行，然后再次继续的时候，你会发现mysql密码已经修改成了新的密码，旧的密码已经失效。 好了，简单的说，更新mysql用户的密码，有3种方式 可以使用 set password for 'user_name'@'host_name'=password('new_pwd') 方式来修改密码 可以使用 update 系统表方式，update user set password=password('passwd') where user='user_name'注： 对于user表password类，如果不用password函数的话，导致更新后无法登陆。但如果将账户更新为空密码，可以使用加密函数，也可以不使用，2者等同。 也可以在用户创建后直接使用grant方式来更新用户密码。 注意：对应root密码丢失或需要重置root密码的情形，需要使用系统选项--skip-grant-tables启动服务器后进行重置。 具体可以参考这篇文章：《MySQL 修改用户密码及重置root密码》 安装phpMyAdmin安装autoconfphpMyadmin的安装需要autoconf 1brew install autoconf 结果 12345678==&gt; Downloading https://homebrew.bintray.com/bottles/autoconf-2.69.el_capitan.bottle.4.tar.gz######################################################################## 100.0%==&gt; Pouring autoconf-2.69.el_capitan.bottle.4.tar.gz==&gt; CaveatsEmacs Lisp files have been installed to: /usr/local/share/emacs/site-lisp/autoconf==&gt; Summary🍺 /usr/local/Cellar/autoconf/2.69: 70 files, 3.0M 然后设置$PHP_AUTOCONF环境变量 如果使用默认的bash shell，使用命令： 1echo 'PHP_AUTOCONF=\"'$(which autoconf)'\"' &gt;&gt; ~/.bash_profile &amp;&amp; . ~/.bash_profile 如果是ZSH shell，使用命令： 1echo 'PHP_AUTOCONF=\"'$(which autoconf)'\"' &gt;&gt; ~/.zshrc &amp;&amp; . ~/.zshrc 准备工作完成，开始安装phpMyAdmin 1brew install phpmyadmin 看看结果 12345678910111213141516171819202122232425Webserver configuration example (add this at the end ofyour /etc/apache2/httpd.conf for instance) : Alias /phpmyadmin /usr/local/share/phpmyadmin &lt;Directory /usr/local/share/phpmyadmin/&gt; Options Indexes FollowSymLinks MultiViews AllowOverride All &lt;IfModule mod_authz_core.c&gt; Require all granted &lt;/IfModule&gt; &lt;IfModule !mod_authz_core.c&gt; Order allow,deny Allow from all &lt;/IfModule&gt; &lt;/Directory&gt;Then, open http://localhost/phpmyadminMore documentation : file:///usr/local/Cellar/phpmyadmin/4.6.2/share/phpmyadmin/doc/Configuration has been copied to /usr/local/etc/phpmyadmin.config.inc.phpDon't forget to: - change your secret blowfish - uncomment the configuration lines (pma, pmapass ...)==&gt; Summary🍺 /usr/local/Cellar/phpmyadmin/4.6.3: 2,257 files, 63.2M, built in 5 minutes 29 seconds 结果里面的介绍的使用Apache时候的配置方法，使用Nginx呢？直接在你的ngnix需要的地方，link出来一个链接即可 1ln -s /usr/local/share/phpmyadmin ./phpmyadmin 注意上面需要进入的你的网站的根目录，如果是/var/www，你也可以写完整的路径 ln -s /usr/local/share/phpmyadmin /var/www/phpmyadmin 安装 Nginx命令 1brew install nginx 看结果 123456789The default port has been set in /usr/local/etc/nginx/nginx.conf to 8080 so thatnginx can run without sudo.nginx will load all files in /usr/local/etc/nginx/servers/.To have launchd start nginx now and restart at login: brew services start nginxOr, if you don t want/need a background service you can just run: nginx 就是告诉你nginx默认使用了8080端口，其定义在 /usr/local/etc/nginx/nginx.conf 文件中，这个定义因为端口号大于1024，所以不需要sudo启动，如果需要改为80端口，则需要修改文件Owner为root，这个地方需要注意。后面继续说这个问题。 Nginx的启动和停止如果需要背景运行Nginx，输入命令 12brew services start nginxbrew services stop nginx 或者直接输入 nginx 命令，前台运行，输入Control+C停止运行。 运行后，通过测试网页地址 http://127.0.0.1:8080 来看看是否可以看到默认的Nignx页面。 或者通过运行命令curl -IL http://127.0.0.1:8080 来看看能否读取到页面信息，也可以间接验证Nginx是否正常。 修改端口为80从上面的结果可以看到 Nginx 默认安装在了8080端口，因为一般调试网页默认都是80端口，因此如果需要Nginx使用80端口，需要让Nginx的启动文件加载在root权限下面，也就是说需要将其启动文件从普通用户更改到root用户下(这是因为只有root用户，才可以使用小于1024的端口）。 修改 /usr/local/etc/nginx/nginx.conf 配置文件 将 listen: 8080 修改为 listen: 80 即可。 先停止nginx，然后使用启动(命令sudo brew services start nginx测试一下，因为nginx这时候已经成为root用户的执行文件了，启动和停止都需要 sudo 的前缀。 Nginx自动启动123sudo ln -s /usr/local/opt/nginx/homebrew.mxcl.nginx.plist /Library/LaunchDaemons/sudo chown root:wheel /Library/LaunchDaemons/homebrew.mxcl.nginx.plistsudo launchctl load /Library/LaunchDaemons/homebrew.mxcl.nginx.plist 如果不想Nginx自动启动，使用下面的命令 1sudo launchctl unload /Library/LaunchDaemons/homebrew.mxcl.nginx.plist 更多nginx.conf设置删除默认的 nginx.conf 文件，并且下载我在Github上提供的配置文件。（提醒一下，默认配置文件路径是 /usr/local/etc/nginx/nginx.conf.default） 12rm /usr/local/etc/nginx/nginx.confcurl https://gist.githubusercontent.com/frdmn/7853158/raw/nginx.conf -o /usr/local/etc/nginx/nginx.conf 新的配置文件力求轻量化，只涉及了worker设置，日志格式/路径等设置，nginx.conf.default 里的其他没用的设置，以及那些被注释掉的废话一律没有。 配置文件涉及了几个目录和文件 123error_log /usr/local/etc/nginx/logs/error.logaccess_log /usr/local/etc/nginx/logs/access.loginclude /usr/local/etc/nginx/sites-enabled/* 手动建立 12345678mkdir -p /usr/local/etc/nginx/logs #访问日志存放目录mkdir -p /usr/local/etc/nginx/sites-available mkdir -p /usr/local/etc/nginx/sites-enabledmkdir -p /usr/local/etc/nginx/conf.d #存放 扩展配置文件 以及 用户配置文件mkdir -p /usr/local/etc/nginx/ssl #SSL证书以及私钥目录sudo mkdir -p /var/wwwsudo chown :staff /var/wwwsudo chmod 775 /var/www 这里说一下site-available和sites-enable的区别 sites-available - 配置 虚拟主机（存放配置文件，代表多个虚拟主机的配置） sites-enabled - 存放 软链接，指向 sites-available 中的配置文件，实际上，nginx 是加载 sites-enabled 下的配置，作为虚拟主机） 这里稍微多说一下如何配置虚拟多网站访问，首先你要修改/etc下的hosts文件，这个和windows系统下的hosts文件基本原理一样。 123127.0.0.1 peipei.com127.0.0.1 xiaowei.com127.0.0.1 meimei.com 然后，修改 sites-available 目录的 default 文件，添加像下面这样的配置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162server { listen 80; server_name peipei.com www.peipei.com; root '/Users/wangyi/BitTorrent Sync/Sync Gits/php/peipei.com'; access_log /usr/local/etc/nginx/logs/default.access.log main; location / { include /usr/local/etc/nginx/conf.d/php-fpm; } location = /info { allow 127.0.0.1; deny all; rewrite (.*) /.info.php; } error_page 404 /404.html; error_page 403 /403.html;}server { listen 80; server_name xiaowei.com www.xiaowei.com; root '/Users/wangyi/BitTorrent Sync/Sync Gits/php/xiaowei.com'; access_log /usr/local/etc/nginx/logs/default.access.log main; location / { include /usr/local/etc/nginx/conf.d/php-fpm; } location = /info { allow 127.0.0.1; deny all; rewrite (.*) /.info.php; } error_page 404 /404.html; error_page 403 /403.html;}server { listen 80; server_name localhost; root '/var/www'; access_log /usr/local/etc/nginx/logs/default.access.log main; location / { include /usr/local/etc/nginx/conf.d/php-fpm; } location = /info { allow 127.0.0.1; deny all; rewrite (.*) /.info.php; } error_page 404 /404.html; error_page 403 /403.html;} 安装xDebug命令 1234567brew install &lt;php-version&gt;-xdebug``` 比如，上面咱们安装的是php 5.6，那么这里的命令就可以写成``` bashbrew install php56-xdebug 结果 12345678910111213141516171819202122==&gt; Installing homebrew/php/php56-xdebug==&gt; Downloading https://homebrew.bintray.com/bottles-php/php56-xdebug-2.4.1.el_c######################################################################## 100.0%==&gt; Pouring php56-xdebug-2.4.1.el_capitan.bottle.tar.gz==&gt; CaveatsTo finish installing xdebug for PHP 5.6: * /usr/local/etc/php/5.6/conf.d/ext-xdebug.ini was created, do not forget to remove it upon extension removal. * Validate installation via one of the following methods: * * Using PHP from a webserver: * - Restart your webserver. * - Write a PHP page that calls \"phpinfo();\" * - Load it in a browser and look for the info on the xdebug module. * - If you see it, you have been successful! * * Using PHP from the command line: * - Run `php -i \"(command-line 'phpinfo()')\"` * - Look for the info on the xdebug module. * - If you see it, you have been successful!==&gt; Summary🍺 /usr/local/Cellar/php56-xdebug/2.4.1: 2 files, 188.8K 没啥说的，主要就是通过两种方式验证xDebug是否安装成功，一是可以通过查看phpinfo()函数的输出，另外一个则是看php -i，看结果中是否有xDebug的项目即可，有了就OK了。 网站配置1234curl https://gist.githubusercontent.com/frdmn/7853158/raw/php-fpm -o /usr/local/etc/nginx/conf.d/php-fpm #PHP-FPM配置curl https://gist.githubusercontent.com/frdmn/7853158/raw/sites-available_default -o /usr/local/etc/nginx/sites-available/default #虚拟多域名curl https://gist.githubusercontent.com/frdmn/7853158/raw/sites-available_default-ssl -o /usr/local/etc/nginx/sites-available/default-ssl #虚拟多域名curl https://gist.githubusercontent.com/frdmn/7853158/raw/sites-available_phpmyadmin -o /usr/local/etc/nginx/sites-available/phpmyadmin #虚拟多域名 使用git clone命令clone我的虚拟多域名的网站实例（包含403、404以及一个phpinfo()信息页面）： 12git clone http://git.frd.mn/frdmn/nginx-virtual-host.git /var/wwwrm -rf /var/www/.git #删掉.git目录 SSL网站配置使用下列命令，建立一个4096位的RSA钥匙对，以及自签名的证书： 12openssl req -new -newkey rsa:4096 -days 365 -nodes -x509 -subj \"/C=US/ST=State/L=Town/O=Office/CN=localhost\" -keyout /usr/local/etc/nginx/ssl/localhost.key -out /usr/local/etc/nginx/ssl/localhost.crtopenssl req -new -newkey rsa:4096 -days 365 -nodes -x509 -subj \"/C=US/ST=State/L=Town/O=Office/CN=phpmyadmin\" -keyout /usr/local/etc/nginx/ssl/phpmyadmin.key -out /usr/local/etc/nginx/ssl/phpmyadmin.crt 设置虚拟多域名（virtual hosts）在sites-enabled目录中设置软连接，链接到sites-available中的对应目录 123ln -sfv /usr/local/etc/nginx/sites-available/default /usr/local/etc/nginx/sites-enabled/defaultln -sfv /usr/local/etc/nginx/sites-available/default-ssl /usr/local/etc/nginx/sites-enabled/default-sslln -sfv /usr/local/etc/nginx/sites-available/phpmyadmin /usr/local/etc/nginx/sites-enabled/phpmyadmin 再次设置Nginx自动启动: 1sudo launchctl load /Library/LaunchDaemons/homebrew.mxcl.nginx.plist 完毕恭喜你，所有设置已经完毕，尽情享受你的环境吧。 下面是一些虚拟路径以及作用： http://localhost #”Nginx works” 页面 http://localhost/info #phpinfo() 页面 http://localhost/nope #”Not Found” 页面 https://localhost:443 #”Nginx works” 页面 (SSL) https://localhost:443/info #phpinfo() 页面(SSL) https://localhost:443/nope #”Not Found” 页面 (SSL) https://localhost:306 #phpMyAdmin (SSL) 使用别名控制服务为了方便的启动PHP相关服务，可以设置下列别名： 123456789101112131415alias nginx.start='sudo launchctl load /Library/LaunchDaemons/homebrew.mxcl.nginx.plist'alias nginx.stop='sudo launchctl unload /Library/LaunchDaemons/homebrew.mxcl.nginx.plist'alias nginx.restart='nginx.stop &amp;&amp; nginx.start'alias php-fpm.start=\"launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.php56.plist\"alias php-fpm.stop=\"launchctl unload -w ~/Library/LaunchAgents/homebrew.mxcl.php56.plist\"alias php-fpm.restart='php-fpm.stop &amp;&amp; php-fpm.start'alias mysql.start=\"launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist\"alias mysql.stop=\"launchctl unload -w ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist\"alias mysql.restart='mysql.stop &amp;&amp; mysql.start'alias nginx.logs.error='tail -250f /usr/local/etc/nginx/logs/error.log'alias nginx.logs.access='tail -250f /usr/local/etc/nginx/logs/access.log'alias nginx.logs.default.access='tail -250f /usr/local/etc/nginx/logs/default.access.log'alias nginx.logs.default-ssl.access='tail -250f /usr/local/etc/nginx/logs/default-ssl.access.log'alias nginx.logs.phpmyadmin.error='tail -250f /usr/local/etc/nginx/logs/phpmyadmin.error.log'alias nginx.logs.phpmyadmin.access='tail -250f /usr/local/etc/nginx/logs/phpmyadmin.access.log' 现在你可以使用短小的别名来控制服务的启动和停止了，而不用输入长长的 launchctl 命令: Nginx相关的控制命令你可以使用下面的命令来启动、停止、重启 Nginx: 123nginx.startnginx.stopnginx.restart 快速检查错误和查看日志，使用下面的命令： 123456nginx.logs.accessnginx.logs.default.accessnginx.logs.phpmyadmin.accessnginx.logs.default-ssl.accessnginx.logs.errornginx.logs.phpmyadmin.error 检查配置: sudo nginx -t 显示结果 12nginx: the configuration file /usr/local/etc/nginx/nginx.conf syntax is oknginx: configuration file /usr/local/etc/nginx/nginx.conf test is successful PHP-FPM相关的控制命令你可以使用下面的命令来启动、停止、重启 PHP-FPM: 123php-fpm.startphp-fpm.stopphp-fpm.restart 检查PHP-FPM配置:php-fpm -t MySQL相关的控制命令你可以使用下面的命令来启动、停止、重启 MySQL 服务: 123mysql.startmysql.stopmysql.restart 常见错误错误 Nginx: ‘[emerg] mkdir() “/usr/local/var/run/nginx/client_body_temp”‘可能的解决办法：升级到至少Yosemite以上的MAC OS版本，然后重新使用Homebrew强制安装nginx 1brew reinstall --force nginx 错误PHP-FPM: ‘lsof -Pni4 | grep LISTEN | grep php’ doesn’t return anything可能的解决办法：确保你的系统变量路径设置正确，使用命令： 1echo $PATH | grep php56 来检查php56是否在系统路径中，如果没有任何返回结果，你需要调整你的 .zshrc/.bash_profile. 文件设置，确保在这个文件末尾，有这样一行： 1export PATH=\"$(brew --prefix homebrew/php/php56)/bin:$PATH\" 错误 git: ‘Could not resolve host: git.frd.mn’可能的解决办法：这可能是我的服务器的问题，请与我联系。 错误 curl: ‘Failed to connect to localhost port 80: Connection refused’可能的解决办法：这是一个涉及 IPv6 的问题，问题出在你的Mac电脑的 /etc/hosts 文件。如果想修复这个错误，在hosts文件中，找到 “fe80::1%lo0 localhost” 这一行，并且把他注释掉，或者使用下面的命令一键搞定： 1sudo sed -i \"\" 's/^fe80\\:\\:/\\#fe80\\:\\:/g' /etc/hosts 错误 brew: ‘configure: error: Can not find OpenSSL’s ‘可能的解决办法：确认Xcode已经安装，并且保证Xcode CLI工具安装并且保持最新版本。 错误 访问本地网站出现 ‘502 bad gateway’的提示。先检查php-fpm是否顺利执行了。 错误：Mavericks: Compilation error while building PHP / missing zlib可能的解决办法：恢复 /usr/include 目录，输入下面的命令： 1sudo ln -s /Applications/Xcode5-DP.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk/usr/include /usr/include 参考资料 INSTALL NGINX, PHP AND MYSQL ON OS X MySQL 修改用户密码及重置root密码 how to install Xdebug on MAC OS X nginx、php-fpm、mysql用户权限解析 了解LaunchDaemons LaunchDaemons vs LaunchAgents","link":"/2016/07/01/config_nginx_php_and_mysql_on_mac_using_homebrew/"},{"title":"从跨版本升级PHP说CENTOS的软件安装","text":"更新记录20160622-初次成文 为什么会有这篇文章最近帮亲戚改一个PHP的系统，需要PHP版本 &gt; 5.4.0，发现自己的阿里云是5.3.29，然后升级过程稍微有点曲折，就在这里开个帖子，总结一下。 我的系统是CENTOS 6.5 64位，采用php -v看到的版本是5.3.29，使用rpm -qa | grep php，显示的结果为空，这说明我的PHP是通过编译安装，而不是通过 RPM 或者 YUM 安装的。 这里正好多说两句，关于LINUX系统下安装程序的2种方法。参考了下面几篇帖子总结而成。 Linux源码包编译安装与rpm安装方法介绍 安装 RPM 包或者安装源码包 Redhat/CentOS 软件安装之RPM和YUM Linux下安装程序的2种方式源程序编译安装如果是下载源程序编译安装到LINUX系统上，首先需要注意阅读随源程序一起的README文件或者INSTALL文件说明。其实，在Linux下面安装一个源码包是最常用的，日常工作中大部分软件都是通过源码安装的。安装一个源码包，需要我们自己把源代码编译成二进制的可执行文件。如果你读得懂这些源代码，那么你就可以去修改这些源代码自定义功能，然后再去编译成你想要的。使用源码包的好处除了可以自定义修改源代码外，还可以定制相关的功能，因为源码包在编译的时候可以附加额外的选项。 源码包的编译用到了Linux系统内的编译器，常见的源码包一般都是用C语言开发的，这也是因为C语言为Linux上最标准的程序语言。Linux上的C语言编译器叫做gcc，利用它就可以把C语言变成可执行的二进制文件。所以如果你的机器上没有安装gcc就没有办法去编译源码。你可以使用 yum install -y gcc 来完成安装。 安装一个源码包，通常需要三个步骤： 配置 ./config 配置程序参数，指定程序安装目录之类的。 编译 make 使用这个命令会根据Makefile文件中预设的参数进行编译，这一步是gcc在工作。 安装 make install 安装步骤，生成相关的软件存放目录和配置文件的过程。 上面介绍的3步并不是所有的源码包软件都一样的，也就是说源码包的安装并非具有一定的标准安装步骤。这就需要你拿到源码包解压后，然后进入到目录找相关的帮助文档，通常会以INSTALL或者README为文件名。下面详细说一下每个步骤。 配置构建应用的第一步就是通过ROOT用户执行 configure 脚本,该脚本位于程式源文件的主目录下： 1./configure 该脚本将扫描检测系统，以确保程式所需的所有库文件已存在，并做好文件路径及其他所需的设置工作。如果程式所需的库文件不完全，该设置脚本就会退出，并告诉你还需要哪些库文件或是哪些版本太旧需要更新。 如果遇见这种情况，仅弄到含有该库文件的软件包还是不够的，同时还要找到具有该库文件所有头文件的研发包，在Linux中，这样的包一般以 -dev 作为文件名的结尾。 安装好所有需要的库文件后，重新运行设置脚本，直到没有错误提示为止，这说明需要的库文件已全部安装妥当了即满足了依赖关系，然后才会生成一个Makefile文件。 同时，在配置这一步可以定制功能，加上相应的选项即可，具有有什么选项可以通过 ./config --help 命令来查看。 编译当设置脚本成功退出后，接下来要做的就是编译代码了。具体操作为在源文件的主目录中运行 make 命令： 1make 注：这时，你会看到一串编译输出数据迅速从屏幕上滚过，如果正常的话，系统会返回的提示符状态。 安装当软件成功编译后，最后一步就是将他们安装到系统上。大部分程式的 makefile 文件中都会有一个用于安装的函数。需要注意的是，大多时候我们必须作为root用户来安装程式，这样程式就把文件安装到 /usr 或其他只有终极用户才有写权限的目录中。依旧是在源文件的主目录下，执行如下命令： 1make install 注：这样程序就会安装到你的计算机上了。 卸载另外，当你不再使用该程序时，能使用软件所带的卸载功能，一般程序都会具有此功能。转换至源文件的主目录下，执行以下命令即可： 1make uninstall 调整参数多数情况下，利用上面介绍的方法安装的程式，都位于 /usr/local 下面，编译安装源码包还有一个特点，就是我们可以自己指定安装位置，这需要在配置时指定程序具体安装到哪个文件夹，通常我们会装在 /opt 下,命令如下: 1./configure --prefix = /opt/ 注：当然有时候也有例外，有些程序根本就不理会你指定的文件夹，它会自己指定文件夹进行安装。 RPM 包安装（含YUM）编译安装的PHP 5.3版本的卸载因为我的安装方式是编译安装，所以在rpm -qa | grep php是没有显示结果的。 所以，只能通过删除PHP目录，或者重命令的方式来卸载掉老版本的PHP，需要注意的是，PHP在5.4版本之后，内存中的程序，改名叫php-fpm，而不再是单纯的php了。 而我装的5.3.29的PHP，则没有这个东西，也没有安装NGINX，所以，还是很简单的。 1234/etc/init.d/httpd #停掉httpd服务，也就是顺便停止了PHP解析killall httpd #杀掉httpd相关的进程mv /alidata/server/php-5.3.29 /alidata/server/php-5.3.29-old #不删掉目录，只改名字rm -f php #删掉php和php-5.3.29的软链接 这样就算把php 5.3.29暂时搞没了，是不是很简单？ 下面开始安装新版本了。 编译安装PHP 5.5.7我的apache版本是2.4.10，最高支持PHP到5.5.7，我使用了一个在apache下安装php的脚本，地址在我的github下有源文件，具体请移步这里下载。 下来了sh脚本之后，执行下列命令 1scp -P 22 ./install-.sh root@server:/alidata/server/. 登录服务器 1234cd /alidata/servermkdir php-5.5.7ln -s php-5.5.7 php./install.sh 执行完之后，测试下网站，如果不放心，可以通过service httpd restart重启下apache。 有一些权限问题，直接登录后 chmod 777 .给相应的权限，顺利解决。 参考资料在CentOS上把PHP从5.4升级到5.5:比较详细的介绍了使用yum安装php 5.4.13的过程","link":"/2016/06/22/upgrade_php_from_5.3_to_5.4_or_high_version_with_rpm_or_yum/"},{"title":"如何更新CENTOS/REHL系统的REPO库","text":"更新日期20160624-初次成文20180928-更新了EPEL的内容 为什么会有这篇文章因为使用系统默认的YUM源，更新系统速度慢呗！我使用的阿里云的CENTOS系统，在使用 YUM 安装和更新软件的时候，速度不是很理想，因此一直在寻找更新和添加 YUM REPO^1 的方法，而且网上现在也有很多阿里云的国内镜像，或者是比如清华大学、重庆大学这些机构提供的 REPO 库，正好趁现在这个机会总结一下。不过在继续讨论这个问题之前，先 基本的概念 什么是REHL？ REHL是Red Hat Enterprise Linux的缩写。目前有很多个版本的Linux，比如CentOS、RedHat的RHEL、Fedora、Ubuntu、Debian等等，这些Linux大致可以分为两个系列，面向个人桌面领域，和面向服务器领域。 其实，Red Hat Linux是Red Hat（红帽公司）最早发行的个人版本的Linux，然后从9.0版本之后，红帽公司就停止了个人版本的Linux，或者可以说是个人桌面版，而是将企业的精力转向了服务器版本的开发上，也就是推出了RHEL。 而原来的个人版的REDHAT LINUX，则由来自开源社区的Fedora计划合并，成为Fedora Core发行版本。 至此，Red Hat Linux则分为两个系列，分别是由RedHat公司提供收费技术支持和更新的Red Hat Enterprise Linux，也就是上面所说的RHEL，以及由开源社区支持的Fedora Core。 其他的Linux都有什么？ 上面说了Fedora和RHEL，此外，还有CentOS，Debian，Ubuntu等。 CentOS不是Redhat的，但它是由Redhat的服务器版本RHEL重编译而来的，和RHEL就是对孪生兄弟。它是完全克隆的免费Redhat企业版。CentOS可以像REHL一样的构筑Linux系统环境，但不需要向RedHat付任何的费用，同样也得不到任何有偿技术支持和升级服务。其特点是面向企业级服务器应用、开源免费、各大企业服务器广泛使用、文档资料齐全、稳定、安全。 Fedora Core(缩写为FC)，上文提到过，FC被红帽公司定位为新技术的实验场地，许多新的技术都会在 FC 中检验，如果稳定的话，红帽公司则会考虑加入 Red Hat Enterprise Linux 中。由于版本更新频繁，性能和稳定性得不到保证，因此，一般在服务器上不推荐采用Fedora Core。其实可以这么认为，Fedora就是Red Hat发行Red Hat企业版Linux的一个实验版本，拿用户做测试，为Red Hat企业版发布做基础。特点：适合桌面应用、稳定性较差 Debian，或者称Debian系列，包括Debian和Ubuntu等。Debian是社区类Linux的典范，是迄今为止最遵循GNU规范。Debian最具特色的是 apt-get/dpkg包 管理方式，其实Redhat的YUM也是在模仿Debian的APT方式，但在二进制文件发行方式中，APT应该是最好的了。Debian的资料也很丰富。 Ubuntu，基于Debian发行版和GNOME桌面环境.它使用Bash作为基础Shell，所以在很多基础命令上，ubuntu与CentOS的差别不是很明显，而ubuntu在桌面界面上要做的更为出色。其特点是面向桌面应用、界面美观、操作简单。 什么是Repo？ Repo是Repository的缩写，Repository是仓库/项目的意思，通常简写为repo，但是这个单词，在linux下，和在git下的含义并不完全相同。git下的含义这里就不讨论了。 在linux下，repo是yum源的配置文件，一个repo文件定义了有ige或者多个软件仓库的细节内容，例如我们将从哪里下载需要安装或者升级的软件包，repo文件中的设置内容将被yum读取和应用！ 什么是yum？ YUM是 Yellowdog Updater Modified 的简称，通过命令方式解决LINUX系统下RPM包的安装工具，是CENTOS、RHEL系统下安装更新软件的利器，解决了rpm安装包的依赖性问题，为使用者和程序开发者提供了不小的便利，YUM基于 GNU（General Public License）协议授权公布，YUM在安装软件包之前，会通过检测在线REPO库内的软件依赖关系，从而节省用户自己分析依赖项的辛苦。 yum是如何工作的？ YUM的工作原理并不复杂，每一个 RPM软件的头（header）里面都会纪录该软件的依赖关系，那么如果可以将该头的内容纪录下来并且进行分析，可以知道每个软件在安装之前需要额外安装哪些基础软件。也就是说，在服务器上面先以分析工具将所有的RPM档案进行分析，然后将该分析纪录下来，只要在进行安装或升级时先查询该纪录的文件，就可以知道所有相关联的软件。所以YUM的基本工作流程如下： 服务器端：在服务器上面存放了所有的RPM软件包，然后以相关的功能去分析每个RPM文件的依赖性关系，将这些数据记录成文件存放在服务器的某特定目录内。 客户端：如果需要安装某个软件时，先下载服务器上面记录的依赖性关系文件(可通过WWW或FTP方式)，通过对服务器端下载的纪录数据进行分析，然后取得所有相关的软件，一次全部下载下来进行安装。 常用的repo（仓库）都有哪些？ 目前比较常用的5个YUM库分别是 RPMForge, EPEL, REMI, ATrpms 以及 Webtatic，经过近几年的发展，阿里云也逐渐发展壮大，拥有了自己的 YUM REPO库。这几个REPO库包含的软件并不完全相同，但是足可以满足一般用户的需求。 下面的命令，分别对应 CentOS/RHEL 的版本 7/6/5，以及 32位 或者 64位 等不同版本情况，有的库甚至包含了 Fedora 系统的RPM包。 linux软件的安装方式？ 刚才提到了RPM，rpm是红帽公司的linux的软件包格式，类似软件包的扩展名还有deb包、run包、bin包等等，都是因为上面多种不同的linux版本造成了不同的安装包的规范名称， 通常，在RHEL/CENTOS/FEDORA这些linux系统下，软件包的扩展名通常是rpm，在debian/ubuntu的linux，安装包的扩展名通常是deb。 另外，还有几种拓展名，比如run，sh，bin这些，都是安装文件的扩展名，并不严格区分linux系统，想要运行这些文件，通常先chmod给他们一个+x的权限，然后运行即可。 除了上面说的安装包或者安装执行文件的方式，还有一种就是编译的方式，但是这种方式比比较复杂，优点就是灵活度很高，比如，可以自定义软件的安装路径，安装使用的账号等各种参数，这种方式通常用于安装源代码的安装。需要一个编译的过程，然后再安装。 举例： 安装nagios插件（nagios是一种开源的监控软件，需要多种插件支持监控模块） 1234cd /tmp/nagios-plugins-* #先进入目录./configure --with-nagios-user=nagios --with-nagios-group=nagios # 配置，即安装的用户安装的路径都可在此设置，这一步一般用来生成 Makefile，为下一步的编译做准备make #编译过程如果 在 make 过程中出现 error ，你就要记下错误代码，缺少什么包就安装什么包。make install #如果make无问题就可以直接安装了。 比较好的YUM REPO之前在网上搜索 LINUX 系统难题的过程中，在 CENTOS 官方论坛发现一些用户，并不推荐使用 Webtatic^2 的 REPO 库。其原因是 Webtatic 的库里的一些RPM包[^3]的命名和官方有冲突，但是依然发现网上很多地方提供的教程使用了Webtatic的包，没办法，也许就像之前那篇帖子里讨论的如何强制树莓派使用静态IP地址一样，很多博客更新的解决办法都存在抄来抄去的问题，我自己也不例外，不过希望自己每一个帖子，都能保持不断的更新，这也是为什么我写博客的时候，都会在冒段的地方，加入 更新日期 这个看似没多大用的段落，也是为了督促自己不断改正错误，能够与时俱进。 添加 阿里云 库阿里云是最近新出的一个镜像源。得益于阿里云的高速发展，这么大的需求，肯定会推出自己的镜像源。阿里云Linux安装镜像源地址：https://opsx.alibaba.com/mirror，网站比较友好，可以看到页面的第一个就是CentOS的镜像源，然后点击查看帮助，就有了详细的安装方法。 1234567891011121314151617181920212223#CentOS 5wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-5.repo#或者curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-5.repo#CentOS 6wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo#或者curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo#CentOS 7wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo#或者curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 添加 RPMForge 库1234567891011121314#系统为 CentOS/RHEL 7 x86 64bit:rpm -Uvh http://pkgs.repoforge.org/rpmforge-release/rpmforge-release-0.5.3-1.el7.rf.x86_64.rpm#系统为 CentOS/RHEL 6 x86 64bit:rpm -Uvh http://pkgs.repoforge.org/rpmforge-release/rpmforge-release-0.5.3-1.el6.rf.x86_64.rpm#系统为 CentOS/RHEL 6 x86 32bit:rpm -Uvh http://pkgs.repoforge.org/rpmforge-release/rpmforge-release-0.5.3-1.el6.rf.i686.rpm#系统为 CentOS/RHEL 5 x86 64bit:rpm -Uvh http://pkgs.repoforge.org/rpmforge-release/rpmforge-release-0.5.3-1.el5.rf.x86_64.rpm#系统为 CentOS/RHEL 5 x86 32bit:rpm -Uvh http://pkgs.repoforge.org/rpmforge-release/rpmforge-release-0.5.3-1.el5.rf.i386.rpm 添加 EPEL 库12345678#系统为 CentOS/RHEL 7 64位rpm -Uvh http://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-5.noarch.rpm#系统为 CentOS/RHEL 6 64位rpm -Uvh http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm#系统为 CentOS/RHEL 5 64位rpm -Uvh http://dl.fedoraproject.org/pub/epel/5/x86_64/epel-release-5-4.noarch.rpm 添加 REMI 库1234567891011121314151617#系统为 CentOS/RHEL 7rpm -Uvh http://rpms.famillecollet.com/enterprise/remi-release-7.rpm#系统为 CentOS/RHEL 6rpm -Uvh http://rpms.famillecollet.com/enterprise/remi-release-6.rpm#系统为 CentOS/RHEL 5rpm -Uvh http://rpms.famillecollet.com/enterprise/remi-release-5.rpm#系统为 Fedora 24rpm -Uvh http://rpms.famillecollet.com/fedora/remi-release-24.rpm#系统为 Fedora 23rpm -Uvh http://rpms.famillecollet.com/fedora/remi-release-23.rpm#系统为 Fedora 22rpm -Uvh http://rpms.famillecollet.com/fedora/remi-release-22.rpm 添加 ATrpms 库1234567891011121314151617181920212223242526#系统为 CentOS/RHEL 7 x86 64bitrpm -Uvh http://dl.atrpms.net/all/atrpms-repo-7-7.el7.x86_64.rpm#系统为 CentOS/RHEL 6 x86 64bitrpm -Uvh http://dl.atrpms.net/all/atrpms-repo-6-7.el6.x86_64.rpm#系统为 CentOS/RHEL 6 x86 32bitrpm -Uvh http://dl.atrpms.net/all/atrpms-repo-6-7.el6.i686.rpm#系统为 CentOS/RHEL 5 x86 64bitrpm -Uvh http://dl.atrpms.net/all/atrpms-repo-5-7.el5.x86_64.rpm#系统为 CentOS/RHEL 5 x86 32bitrpm -Uvh http://dl.atrpms.net/all/atrpms-repo-5-7.el5.i386.rpm#系统为 Fedora 20 x86 64bitrpm -Uvh http://dl.atrpms.net/all/atrpms-repo-20-7.fc20.x86_64.rpm#系统为 Fedora 20 x86 32bitrpm -Uvh http://dl.atrpms.net/all/atrpms-repo-20-7.fc20.i686.rpm#系统为 Fedora 19 x86 64bitrpm -Uvh http://dl.atrpms.net/all/atrpms-repo-19-7.fc19.x86_64.rpm#系统为 Fedora 19 x86 32bit:rpm -Uvh http://dl.atrpms.net/all/atrpms-repo-19-7.fc19.i686.rpm 添加 Webtatic 库centos论坛上有人对 Webtatic 的库比较反感，因为这里的程序包的命名好像和官方的不是很一致，让我对 Webtatic 的印象不是特别好。 12345678#系统为 CentOS/RHEL 7:rpm -Uvh http://repo.webtatic.com/yum/el7/webtatic-release.rpm#系统为 CentOS/RHEL 6:rpm -Uvh http://repo.webtatic.com/yum/el6/latest.rpm#系统为 CentOS/RHEL 5:rpm -Uvh http://repo.webtatic.com/yum/el5/latest.rpm 生成缓存1yum makecache 总结RPMForge、ATrpms的repo地址连不上，Webtatic的普遍不得到推荐，所以，EPEL和REMI还有阿里云的三个装上就好了。 参考网站 Top 5 Yum Repositories for CentOS/RHEL 7/6/5 常用Linux分类 认识repo文件 文中的缩写说明[^3]: RPM 是 LINUX 下的一种软件的可执行程序，你要做的就是通过rpm命令安装那些后缀名是rpm的文件包，就可以安装好某个软件了。RPM是Redhat Linux Packet Manager的缩写，后缀是rpm。","link":"/2016/06/24/how_to_add_new_yum_repos_to_centos_rhel/"},{"title":"MAC系统下卸载NODE.JS并且使用BREW安装","text":"文章更新 20160703-初次成文 20170727-小错误更新 为什么会有这篇文章主要是因为懒得用vagrant来配置，并且自己的电脑硬盘不是特别大，所以就想熟悉下，正好homebrew不熟悉，通过这次的练习，也算初步掌握了Homebrew的常见问题。 Mac下如何完整卸载node.js因为之前使用brew doctor发现了node安装在了/usr/local/include目录下，这样homebrew就会觉得有文件没有应该放对位置，因此我就要先卸载一次再使用brew来安装它，而不是简单使用node.js的安装包安装。 123456Warning: Unbrewed header files were found in /usr/local/include.If you didn't put them there on purpose they could cause problems whenbuilding Homebrew formulae, and may need to be deleted.Unexpected header files: /usr/local/include/node/android-ifaddrs.h 能看到没有放对位置的文件，基本上都是Node.js的文件，因此，还是决定把这些目录全部删掉，网上搜了完整删除Node.js的方法，基本上就是吧Node.js的文件和目录全部删掉即可。 写了个脚本，也不算脚本吧。 1234567891011sudo rm -rf /usr/local/lib/node_modulessudo rm -rf /usr/local/include/nodesudo rm -rf /usr/local/bin/nodesudo rm /usr/local/bin/npmsudo rm /usr/local/share/man/man1/node.1sudo rm /usr/local/lib/dtrace/node.dsudo rm -rf ~/.npmsudo rm -rf ~/.node-gypsudo rm /opt/local/bin/node #我这里没有找到sudo rm /opt/local/include/node #我这里没有找到sudo rm -rf /opt/local/lib/node_modules #我这里没有找到 好了，世界清静了。 使用homebrew安装Node.js和npm确认Homebrew就绪Homebrew的安装可以参见另外一个帖子 安装Node.js和NPM1brew install node 这样安装Node.js已经把NPM一起安装了，然后通过 node -v 和 npm -v 分别检查node和npm是否安装正确。 也可能会看到下面这个错误: node没有被link，使用 brew link node，遇到错误 1234567891011Linking /usr/local/Cellar/node/6.2.2...Error: Could not symlink share/doc/node/gdbinitTarget /usr/local/share/doc/node/gdbinitalready exists. You may want to remove it: rm '/usr/local/share/doc/node/gdbinit'To force the link and overwrite all conflicting files: brew link --overwrite nodeTo list all files that would be deleted: brew link --overwrite --dry-run node 上面的结果是说link node的时候遇到错误，建议先使用 rm '/usr/local/share/doc/node/gdbinit' #删除文件，然后重新使用 brew link --overwrite node #强制连接，并且覆盖所有冲突的文件 结果 1Linking /usr/local/Cellar/node/6.2.2... 7 symlinks created 连接成功了 再次 node -v 和 npm -v 如果能看到版本号，就说明node安装完毕。 参考文献 How to Install Node.js and NPM on a Mac","link":"/2016/07/03/how_to_uninstall_nodejs_and_reinstall_with_brew/"},{"title":"ssh免密连接那点事","text":"文章更新记录 20160623-初次成文 20170214-情人节更新限定 为什么会有这篇文章因为懒呗，觉得ssh这种方式是在是太方便了。所以就把自己在几台主要开发机上都配置成了这种方式，顺便也熟悉了一下MACOS、树莓派、OPENWRT以及CENTOS几种linux系统下对ssh免密配置的稍微不同。 先来看一个配置文件(.ssh目录下的config文件) 123456789101112131415161718192021222324252627282930313233343536Host github1 HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/github1Host github2 HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/github2Host codingnet1 HostName git.coding.net PreferredAuthentications publickey IdentityFile ~/.ssh/codingHost aliyunroot HostName www.aliyun.com PreferredAuthentications publickey IdentityFile ~/.ssh/aliyun_root User rootHost aliyungit1 HostName www.aliyun.com PreferredAuthentications publickey IdentityFile ~/.ssh/aliyun_git1 User git1Host oproot HostName www.wodeshumeipai.com Port 22 CheckHostIP no PreferredAuthentications publickey IdentityFile ~/.ssh/op_root User rootHost pipi HostName www.wodeshumeipai.com Port 22 CheckHostIP no PreferredAuthentications publickey IdentityFile ~/.ssh/raspberry_pi User pi 这个文件是告诉本机ssh连接应该去哪里找密钥的，比较重要的几个参数： Host oproot #这个默认的名字，通过这个简称，可以使用 ssh oproot 甚至ssh -vT git@github的方式直接连接。 HostName www.wodeshumeipai.com #这个是要连接的服务器地址 Port 22 #端口号 CheckHostIP no #这个参数，比较特殊，适用于反向解析的情况，可以让服务器忽略反向IP的检查。 PreferredAuthentications publickey #默认就用这个publickey就可以，其他还没有研究。 IdentityFile ~/.ssh/raspberry_pi #告诉ssh去哪里找密钥文件。 User pi #要使用哪个用户名去连接服务器，这个用户名所对应的服务器主目录下，应该有authorized_keys。 有了上面这个文件，只是ssh免密的第一步，然后，需要生成一下ssh的rsa key，使用命令 1ssh-keygen -t rsa -C \"you@youremail.com\" 然后，把pub的内容填写到github.com或者coding.net的设置里去，然后使用命令ssh -vT git@git.coding.net以及ssh -vT git@github.com来测试连接是否正确。如果不正确，先修改RSAkey的文件权限，给600最好。 12chmod 600 id_rsachmod 600 id_rsa.pub 如果还不行，那就使用~/.ssh/config文件中规定的Host名来替换相应的git repo的域名，比如，按照上面的设置，不要使用ssh -vT git@git.coding.net，而要使用ssh -vT git@codingnet1来测试。 经过这样的修改，应该可以基本解决ssh的免密了，如果还不行，可以参考我的另外一个帖子，本来是讨论Hexo在deploy时候卡住的问题，但是其实卡住的原因就是git的权限问题，所以值得参考，入口在这里。 Windows下GIT的免密先确认生成了ssh秘钥文件，并且把公钥（.pub）放到GITHUB中，如果你还有其他需要，比如我将HEXO的source文件放到了coding.net，同时我还有第二个github账号用来存放hueman的theme文件。所以，这三个地方我都放好了相应pub文件内容。 然后测试一下连接github和coding.net是否正确ssh -T git@github.com ssh -T git@git.coding.net 正确的，下一步，修改hexo/.git目录下的config文件，这是修改之前的内容 1234567891011121314[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true ignorecase = true[submodule \"themes/hueman\"] url = https://github.com/tinyvane2/hexo-theme-hueman.git[remote \"origin\"] url = https://git.coding.net/tinyvane/hexo.git fetch = +refs/heads/*:refs/remotes/origin/*[branch \"master\"] remote = origin merge = refs/heads/master 需要修改的就是其中使用了https方式存取git的几行，分别将他们从https方式，修改为git方式。 12345678[submodule \"themes/hueman\"] ... url = git@github.com:tinyvane2/hexo-theme-hueman.git ...[remote \"origin\"] ... url = git@git.coding.net:tinyvane/hexo.git ... 然后，hexo d以及git push就应该不再需要输入密码了。 PS: 关于一个客户端设置多个github账号的设置，请参见这篇文章一个客户端设置多个github账号 重点就是 12ssh-add ~/.ssh/id_rsassh-add ~/.ssh/id_rsa_two 将你的两个不同账号的ssh密钥添加到ssh-agent内，如果遇到ssh-agent不能启动的错误，先用命令eval 'ssh-agent -s'启动一下。 centos系统ssh免密需要注意的是，这些linux系统下，要登录ssh的用户，首先在服务器端，一是要要设置密码，二是需要允许ssh登录，通过在服务器上使用passwd命令查看对应的登录用户名，其登录方式不能是/sbin/nologin，否则其他设置都是扯淡。 但是，这里反过来讲，如果设置了/sbin/nologin;/sbin/false，就能禁止ssh登录了么？那可不一定，这里有一篇文章，详细的谈了这个问题。解决办法，也不是很麻烦，就是需要改变/etc/ssh/sshd_config中的几个设置。 123AllowAgentForwarding noAllowTcpForwarding noX11Forwarding no 这个地方，可以以后再详细讨论，这个涉及服务器安全领域了，是个需要系统总结的话题。 另外一个需要修改的文件是 /etc/ssh/sshd_config。 1234567#PermitRootLogin without-password #找到这里，把它注释，这个项目，需要重点说一说PermitRootLogin yes #改为yesStrictModes yesRSAAuthentication yesPubkeyAuthentication yesUsePAM yes 参数PermitRootLogin可以有4个参数,分别是 yes, without-password, forced-commands-only, 以及 no。 默认yes。 如果这个参数设置为without-password，则root用户无法使用密码授权登录服务器。如果设置为forced-commands-only，则root用户允许使用public key授权登录，但是只有当命令行指定登录的时候才可以，这种设置在需要远程备份服务器的时候很有用，因为远程服务器可能已经禁止了root登录。 如果参数设置为no，root用户则根本不允许登录。 通过命令重启ssh以及sshd 12service ssh restartservice sshd restart 这里注意，使用 /etc/init.d/ssh restart 的方式重启是不成功的，具体为什么？我现在也不知道。 然后，还需要给服务器端的.ssh目录适当的权限，可以参考下面来设置。 123456mkdir /home/sshloginusername/.sshchown -R sshloginusername:sshloginusername /home/sshloginusernamechmod 700 /home/sshloginusernamechmod 700 /home/sshloginusername/.sshchmod 644 /home/sshloginusername/.ssh/authorized_keys #公钥文件的所有权限chmod 600 /home/sshloginusername/.ssh/id_rsa 是不是发现上面这些设置很乱？这里介绍一个命令ssh-copy-id。 ssh-copy-id 命令可以把本地主机的公钥复制到远程主机的 authorized_keys 文件上，ssh-copy-id 命令也会给远程主机的用户主目录（home）和 ~/.ssh, 和 ~/.ssh/authorized_keys设置合适的权限，就不用设置上面那么多记不清的数字了。 一句话介绍 1ssh-copy-id [-i ~/.ssh/id_rsa.pub] user@server 树莓派ssh免密树莓派基本和centos很像，唯一的问题是我在添加公钥到authorized_keys之后，本以为可以正常登陆，没想到非常费劲，检查了几乎所有地方，也找不到什么，后来才发现，是屏幕直接复制的公钥，在黏贴到auth文件里的时候，最前面少了一个字母s。导致ssh变成了sh，太坑了。 怎么发现的？因为在搜索的过程中，网上有人说ubuntu的authorized_keys文件格式和其他系统有点区别，但是没想到自己挖的坑这么2B。 我使用了 123scp -P 22 ~/.ssh/id_rsa.pub user@server:/home/pi/.ssh/temp.pubssh -p 22 user@servercat /home/pi/.ssh/temp.pub &gt;&gt; /home/pi/.ssh/authorized_keys 为什么特意还把这些无聊的命令要写一遍呢，因为scp -P 22是个大写的，而ssh -p22后面的p是小写的，并且直接跟着22。又是一个坑。 同时，在检查登录错误的时候，可以通过tail -10 /etc/log/auth.log看登录日志。 需要重点说的是，在我ssh家中的树莓派的时候，遇到了一个警告。 1Reverse Mapping Checking – Possible Break-in Attempt Error with SSH 在网上搜索的时候，注意到了这个帖子，其中有一段关于这个问题的解释。 当使用SSH或SFTP连接某个host时，会有一系列的检查以保证你能够连接到你想连接的机器。其中一项是 “reverse lookup on the IP address”检查机器名称和你要连接的机器名称一致。否则，你会得到这样一个错误信息：”reverse mapping checking getaddrinfo for … POSSIBLE BREAK-IN ATTEMPT!”. 这是告诉我们，尽管我们在连接my.example.com ，但是实际上该server的IP 地址对应到192-168-1-243.foo.bar.net 。但这个发生的时候，就是因为server 上的reverse DNS 没有设置好。 举例说，应该是把192.168.1.243 映射到 my.example.com 。 因为我知道这个反向解析可以接受，所以我可以在本机hosts文件上添加一行（在Linux系统下，一般位于/etc/hosts），来让这个警告消失。 但是，还有另外一个解决办法，就是修改本机/etc/ssh/ssh_config，将其中的 GSSAPIAuthentication 设置为 no，或者，修改服务器上的/etc/ssh/sshd_config文件。注意到区别了么？本地的话，是ssh_config，服务器端是 sshd_config，注意不要搞混乱了。 openwrt系统ssh免密openwrt使用的嵌入式的linux系统，目录和命令和其他系统不是很一样，但是也不是很麻烦。 主要需要注意的是，authorized_keys 文件，并不是存在/root或者/home/username这样的目录的.ssh目录下，而是位于/etc/dropbear/.ssh目录下。 并且遇到一个错误，Exit before auth (user 'root', 0 fails): Exited normally，当时觉得这个错误很神奇，因为解释是还没认证就退出了，想找错误无所适从，后来证明，问题和树莓派上的错误一模一样的。 并且，openwrt没有auth.log文件，想看登录日志，直接输入logread。 sshd_config文件说明网上搜索那个反向警告信息的时候，发现的，很详细，仔细看看也有很大的帮助。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112# 1. 关于 SSH Server 的整体设定，包含使用的 port 啦，以及使用的密码演算方式Port 22 # SSH 预设使用 22 这个 port，您也可以使用多的 port ！ # 亦即重复使用 port 这个设定项目即可！Protocol 2,1 # 选择的 SSH 协议版本，可以是 1 也可以是 2 ， # 如果要同时支持两者，就必须要使用 2,1 这个分隔了！#ListenAddress 0.0.0.0 # 监听的主机适配卡！举个例子来说，如果您有两个 IP， # 分别是 192.168.0.100 及 192.168.2.20 ，那么只想要 # 开放 192.168.0.100 时，就可以写如同下面的样式：ListenAddress 192.168.0.100 # 只监听来自 192.168.0.100 这个 IP 的SSH联机。 # 如果不使用设定的话，则预设所有接口均接受 SSHPidFile /var/run/sshd.pid # 可以放置 SSHD 这个 PID 的档案！左列为默认值LoginGraceTime 600 # 当使用者连上 SSH server 之后，会出现输入密码的画面， # 在该画面中，在多久时间内没有成功连上 SSH server ， # 就断线！时间为秒！Compression yes # 是否可以使用压缩指令？当然可以?！ # 2. 说明主机的 Private Key 放置的档案，预设使用下面的档案即可！HostKey /etc/ssh/ssh_host_key # SSH version 1 使用的私钥HostKey /etc/ssh/ssh_host_rsa_key # SSH version 2 使用的 RSA 私钥HostKey /etc/ssh/ssh_host_dsa_key # SSH version 2 使用的 DSA 私钥# 2.1 关于 version 1 的一些设定！KeyRegenerationInterval 3600 # 由前面联机的说明可以知道， version 1 会使用 # server 的 Public Key ，那么如果这个 Public # Key 被偷的话，岂不完蛋？所以需要每隔一段时间 # 来重新建立一次！这里的时间为秒！ServerKeyBits 768 # 没错！这个就是 Server key 的长度！# 3. 关于登录文件的讯息数据放置与 daemon 的名称！SyslogFacility AUTH # 当有人使用 SSH 登入系统的时候，SSH会记录资 # 讯，这个信息要记录在什么 daemon name 底下？ # 预设是以 AUTH 来设定的，即是 /var/log/secure # 里面！什么？忘记了！回到 Linux 基础去翻一下 # 其它可用的 daemon name 为：DAEMON,USER,AUTH, # LOCAL0,LOCAL1,LOCAL2,LOCAL3,LOCAL4,LOCAL5,LogLevel INFO # 登录记录的等级！嘿嘿！任何讯息！ # 同样的，忘记了就回去参考！# 4. 安全设定项目！极重要！# 4.1 登入设定部分PermitRootLogin no # 是否允许 root 登入！预设是允许的，但是建议设定成 no！UserLogin no # 在 SSH 底下本来就不接受 login 这个程序的登入！StrictModes yes # 当使用者的 host key 改变之后，Server 就不接受联机， # 可以抵挡部分的木马程序！#RSAAuthentication yes # 是否使用纯的 RSA 认证！？仅针对 version 1 ！PubkeyAuthentication yes # 是否允许 Public Key ？当然允许啦！只有 version 2AuthorizedKeysFile .ssh/authorized_keys # 上面这个在设定若要使用不需要密码登入的账号时，那么那个 # 账号的存放档案所在档名！# 4.2 认证部分RhostsAuthentication no # 本机系统不止使用 .rhosts ，因为仅使用 .rhosts 太 # 不安全了，所以这里一定要设定为 no ！IgnoreRhosts yes # 是否取消使用 ~/.ssh/.rhosts 来做为认证！当然是！RhostsRSAAuthentication no # 这个选项是专门给 version 1 用的，使用 rhosts 档案在 # /etc/hosts.equiv配合 RSA 演算方式来进行认证！不要使用HostbasedAuthentication no # 这个项目与上面的项目类似，不过是给 version 2 使用的！IgnoreUserKnownHosts no # 是否忽略家目录内的 ~/.ssh/known_hosts 这个档案所记录 # 的主机内容？当然不要忽略，所以这里就是 no 啦！PasswordAuthentication yes # 密码验证当然是需要的！所以这里写 yes ?！PermitEmptyPasswords no # 若上面那一项如果设定为 yes 的话，这一项就最好设定 # 为 no ，这个项目在是否允许以空的密码登入！当然不许！ChallengeResponseAuthentication yes # 挑战任何的密码认证！所以，任何 login.conf # 规定的认证方式，均可适用！#PAMAuthenticationViaKbdInt yes # 是否启用其它的 PAM 模块！启用这个模块将会 # 导致 PasswordAuthentication 设定失效！ # 4.3 与 Kerberos 有关的参数设定！因为我们没有 Kerberos 主机，所以底下不用设定！#KerberosAuthentication no#KerberosOrLocalPasswd yes#KerberosTicketCleanup yes#KerberosTgtPassing no # 4.4 底下是有关在 X-Window 底下使用的相关设定！X11Forwarding yes#X11DisplayOffset 10#X11UseLocalhost yes# 4.5 登入后的项目：PrintMotd no # 登入后是否显示出一些信息呢？例如上次登入的时间、地点等 # 等，预设是 yes ，但是，如果为了安全，可以考虑改为 no ！PrintLastLog yes # 显示上次登入的信息！可以啊！预设也是 yes ！KeepAlive yes # 一般而言，如果设定这项目的话，那么 SSH Server 会传送 # KeepAlive 的讯息给 Client 端，以确保两者的联机正常！ # 在这个情况下，任何一端死掉后， SSH 可以立刻知道！而不会 # 有僵尸程序的发生！UsePrivilegeSeparation yes # 使用者的权限设定项目！就设定为 yes 吧！MaxStartups 10 # 同时允许几个尚未登入的联机画面？当我们连上 SSH ， # 但是尚未输入密码时，这个时候就是我们所谓的联机画面啦！ # 在这个联机画面中，为了保护主机，所以需要设定最大值， # 预设最多十个联机画面，而已经建立联机的不计算在这十个当中# 4.6 关于使用者抵挡的设定项目：DenyUsers * # 设定受抵挡的使用者名称，如果是全部的使用者，那就是全部 # 挡吧！若是部分使用者，可以将该账号填入！例如下列！DenyUsers testDenyGroups test # 与 DenyUsers 相同！仅抵挡几个群组而已！# 5. 关于 SFTP 服务的设定项目！Subsystem sftp /usr/lib/ssh/sftp-server","link":"/2016/06/23/how_to_ssh_server_without_inputing_the_password/"},{"title":"Hexo如何添加文章分类目录","text":"文章更新 20160705-初次成文 问什么会有这篇文章没有为什么，因为发现一个帖子写的太长的话，自己看起来也纠结，别说网上的访客了。所以以后，尽量保证每个帖子长度适中，不会引起阅读疲劳。 添加分类文章单页在命令行里面输入： 1hexo new page \"categories\" 然后你会发现source里面多了个目录categories，里面有个index.md。 我们看到默认的页面是这样的： 1234title: namedate: 2016-07-05 11:15:00 tags: --- 编辑，将页面的类型设置为 categories ，主题将自动为这个页面显示所有分类。 1234title: 分类date: 2016-07-05 11:39:04type: \"categories\"--- 注意：如果有启用多说 或者 Disqus 评论，默认页面也会带有评论。需要关闭的话，请添加字段 comments 并将值设置为 false，如： 1234title: 分类date: 2016-07-05 11:39:04type: \"categories\"comments: false 可以打开scaffolds/post.md文件，在tags:上面一行加入categories:,保存后，重新执行hexo n ‘name’命令，会发现新建的页面里有categories:项了。scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值。 好了，分类显示页面建立完毕。 设置文章分类列表在我们编辑文章的时候，直接在categories:项填写属于哪个分类，比如categories: 随笔，同时，这个分类也支持中文，同样，显示的路径也会会是中文。 距离，我们设置的分类是： 1categories: raspberry 那在生成页面后，分类列表就会出现编程这个选项，他的访问路径是： 1*/categories/raspberry 如果我们想要把路径名和分类名分别设置，需要怎么办呢？ 打开根目录下的配置文件_config.yml（注意不是themes主题目录下的_config.yml，那个文件叫 主题配置文件），找到如下位置做更改： 1234567# Category &amp; Tagdefault_category: uncategorizedcategory_map: 树莓派: raspberry 写作: writing 其他: otherstag_map: 在这里 category_map: 是设置分类的地方，每行一个分类，冒号前面是分类名称，后面是访问路径。可以提前在这里设置好一些分类，当编辑的文章填写了对应的分类名时，就会自动的按照对应的路径来访问。 需要注意的问题如果你使用了第三方主题，比如我就用NEXT主题，那么上面的设置就没啥用了，主题设置文件，就是 themes/next/_config.yml 会替代站点的设置文件。主题里设置的就没用了。 所以，还是要注意修改主题下的配置文件，比如我的是这样的 123456789101112# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives)menu: home: / categories: /categories #about: /about archives: /archives tags: /tags #commonweal: /404.html","link":"/2016/07/05/how_to_add_category_with_hexo_and_next_theme/"},{"title":"树莓派如何断开WIFI连接","text":"文章更新 20160705-初次成文 为什么会有这篇文章最近发现自己的树莓派有俩IP地址，去路由器上看了一下，发现树莓派在接网线使用固定IP的同时，也使用着WLAN，这倒好，一个π俩IP，虽然可能你觉得没啥问题，但是我在出差的时候，使用apt—get update &amp;&amp; apt-get upgrade更新非常非常的慢，我个人想，这可能是因为正在使用WIFI传输数据导致的。 在上大学的时候，因为有两个网卡，插着两根网线，一个连接着拨号宽带，一个连接着校园网，当时就是用静态路由表，来指定比如访问192.168.50.xxx - 192.168.80.xxx ip段的访问都走校园网。所以，觉得π也许面临同样的困惑。 无奈用VNC Viewer连接了树莓派，发现屏幕右上角，无法找到删掉已经记住密码的WIFI，有人说了你直接把无线路由器的密码改了不就好了，我靠，那我所有的笔记本手机岂不是都要重新输入密码了？好了，废话CUT OUT。 参考的是网上的一个帖子树莓派3命令行配置wifi无线连接和蓝牙连接。 对了，这个帖子主要讲的是，如何用命令行搞定WIFI和蓝牙，不是使用GUI哦。GUI的方法，如果哪位兄弟知道方法，也麻烦留言告诉我一下，提前谢谢了! 如何扫描WIFI并且连接命令很简单 1iwlist scan 可以马上扫描出来周围的WIFI热点信息 1234567891011121314151617181920212223242526wlan0 Scan completed :Cell 01 - Address: 00:1E:20:50:AA:BBChannel:8Frequency:2.447 GHz (Channel 8)Quality=70/70 Signal level=-32 dBmEncryption key:onESSID:\"WIFINAME\"Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s; 6 Mb/s9 Mb/s; 12 Mb/s; 18 Mb/sBit Rates:24 Mb/s; 36 Mb/s; 48 Mb/s; 54 Mb/sMode:MasterExtra:tsf=0000000000000000Extra: Last beacon: 2157000ms agoIE: Unknown: 000546616E6379IE: Unknown: 010882848B960C121824IE: Unknown: 030108IE: Unknown: 050401020000IE: Unknown: 0706303020010B14IE: Unknown: 2A0100IE: Unknown: 32043048606CIE: IEEE 802.11i/WPA2 Version 1Group Cipher : TKIPPairwise Ciphers (2) : CCMP TKIPAuthentication Suites (1) : PSKIE: Unknown: 7F080000000000000040IE: Unknown: DD180050F2020101000003A4000027A4000042435E0062322F00 配置连接到某个热点，命令 1sudo vim /etc/wpa_supplicant/wpa_supplicant.conf 12345678# 在该文件最后添加下面的话network={ ssid=\"WIFINAME\" psk=\"password\"}# 引号部分分别为wifi的名字和密码# 保存文件后几秒钟应该就会自动连接到该wifi# 查看是否连接成功 到这里问题就简单了，这里保存着已经连接过记住密码的热点信息，直接把密码改掉，并且使用命令 1sudo service networking restart 重启网络配置就可以了。这时候发现WIFI已经断了，GAME OVER。 如何使用蓝牙连接树莓派3也直接支持蓝牙，使用直接使用自带命令即可,先打开要连接的蓝牙设备,然后配置树莓派: 命令 1sudo bluetoothctl 然后进入配置模式 12345678910111213141516171819202122232425[NEW] Controller BB:27:EB:0D:9D:DD raspberrypi [default][bluetooth]# list #列出周围扫描到的蓝牙设备Controller BB:27:EB:0D:9D:DD raspi3 [default][bluetooth]# power on #打开蓝牙Changing power on succeeded[bluetooth]# scan on #扫描周围设备Discovery started #开始发现设备[CHG] Controller BB:27:EB:0D:9D:DD Discovering: yes[NEW] Device E8:07:BF:3A:25:AA NDZ-03-GA[CHG] Device E8:07:BF:3A:25:AA RSSI: -66[bluetooth]# agent on #打开代理Agent registered[CHG] Device E8:07:BF:3A:25:AA RSSI: -56[bluetooth]# pair E8:07:BF:3A:25:AA #与某设备进行配对Attempting to pair with E8:07:BF:3A:25:AA[CHG] Device E8:07:BF:3A:25:AA Connected: yes[CHG] Device E8:07:BF:3A:25:AA UUIDs: 00001108-0000-1000-8000-00805f9b34ff[CHG] Device E8:07:BF:3A:25:AA Paired: yesPairing successful #配对成功[CHG] Device E8:07:BF:3A:25:AA Connected: no[bluetooth]# trust E8:07:BF:3A:25:AA[CHG] Device E8:07:BF:3A:25:AA Trusted: yesChanging E8:07:BF:3A:25:AA trust succeeded[bluetooth]# connect E8:07:BF:3A:25:AA #连接该设备 这样就连上蓝牙设备了，如果是蓝牙音响的话还得装下支持软件: 1sudo apt-get install pulseaudio pulseaudio-module","link":"/2016/07/05/how_to_make_raspberry_disconnect_wifi/"},{"title":"树莓派折腾之：为树莓派安装VPN支持","text":"文章更新 20160705-初次成文 20160712-继续完善，OPENVPN版本2.3.11 20160722-完善格式，修改了几个脚本 为什么会有这个文章主要是因为之前在树莓派上安装了samba服务，但是外网服务访问，所以网上看到的解决办法是要给π安装一个vpn，先拨号进到VPN里，就可以正常访问了。虽然我还没有放弃继续尝试外网访问树莓派的samba服务，但是先学习下如何安装OPENVPN吧。 下载OpenVPN推荐从OPENVPN的官方网站下载。 123cd $HOMEwget http://build.openvpn.net/downloads/releases/latest/openvpn-latest-stable.tar.gzgzip -dc openvpn-latest-stable.tar.gz | tar xvf - 这里，国内的小伙伴会遇到一个很恶心的问题，就是wget下载失败，多亏了功夫网呗。还好wget以及curl都可以使用代理。 12curl -x http://127.0.0.1:1080 github.comwget -e \"http_proxy=127.0.0.1:1080\" github.com 至于，如何让树莓派自己可以科学上网，大家可以看我的另外一篇文章，《搬瓦工自动配置shadowsocks翻墙》。 解压缩之后，可以看到OPENVPN解压缩到了openvpn-2.3.11目录，顺便也就知道了OP的版本号。 还有一些工作需要做，执行下列命令升级系统，添加必备组件，以便进行后面的OP编译和安装。 123sudo apt-get updatesudo apt-get install --only-upgrade openssl -ysudo apt-get install gcc make automake autoconf dh-autoreconf file patch perl dh-make debhelper devscripts gnupg lintian quilt libtool pkg-config libssl-dev liblzo2-dev libpam0g-dev libpkcs11-helper1-dev chkconfig -y 编译和安装12345sudo mkdir /etc/openvpn/cd $HOME/openvpn-2.3.11/ #注意你的OPENVPN的版本号，这里会稍有不同sudo ./configure --prefix=/usrsudo makesudo make install 加入自动启动，应该在 etc/init.d/ 下创建一个openvpn的服务脚本，我这里直接给出我写好的 123sudo wget https://raw.githubusercontent.com/tinyvane/randomfiles/master/etcinitdopenvpn.sh -O /etc/init.d/openvpnsudo chmod +x /etc/init.d/openvpn #加入可执行权限sudo update-rc.d openvpn defaults #加入自动启动 通过下面的命令，检查是否设置都正确 1chkconfig --list | grep openvpn 结果应该像下面这样 1openvpn 0:off 1:off 2:on 3:on 4:on 5:on 6:off 使用easyras3创建密钥和证书123456mkdir $HOME/clientsidecd $HOME/clientsidegit clone git://github.com/OpenVPN/easy-rsacd easy-rsa/easyrsa3./easyrsa init-pki #生成了pki目录./easyrsa gen-req client1 nopass #默认名字，回车即可，生成两个文件client1.req和client1.key 客户端的证书和密钥生成完毕，下面继续生成服务器端的 123456789101112mkdir $HOME/serversidecd $HOME/serversidegit clone git://github.com/OpenVPN/easy-rsacd easy-rsa/easyrsa3./easyrsa init-pki #生成pki目录./easyrsa build-ca #生成证书，这个必须输入一个密码，后面的选项回车即可，生成ca.crt证书文件./easyrsa gen-req server nopass #生成私钥，server.req和server.key两个文件。./easyrsa sign-req server server #输入密码，生成服务器证书文件server.crtopenssl dhparam -out dh2048.pem 2048 #时间特别长，可以喝杯咖啡等一会openvpn --genkey --secret ta.key./easyrsa import-req $HOME/clientside/easy-rsa/easyrsa3/pki/reqs/client1.req client1./easyrsa sign-req client client1 下面我写了两个bash脚本，用来合并上面的证书和密钥内容，这样 Copy certs and keys to correct directory,Later we will merge them with the config filecp $HOME/serverside/easy-rsa/easyrsa3/pki/ca.crt $HOME/serverside/cp $HOME/serverside/easy-rsa/easyrsa3/pki/issued/server.crt $HOME/serverside/cp $HOME/serverside/easy-rsa/easyrsa3/dh2048.pem $HOME/serverside/cp $HOME/serverside/easy-rsa/easyrsa3/pki/private/server.key $HOME/serverside/cp $HOME/serverside/easy-rsa/easyrsa3/ta.key $HOME/serverside/cp $HOME/serverside/easy-rsa/easyrsa3/pki/issued/client1.crt $HOME/clientside/cp $HOME/serverside/easy-rsa/easyrsa3/ta.key $HOME/clientside/cp $HOME/serverside/easy-rsa/easyrsa3/pki/ca.crt $HOME/clientside/cp $HOME/clientside/easy-rsa/easyrsa3/pki/private/client1.key $HOME/clientside/ Client Scriptvim $HOME/clientside/raspberrypi.ovpn clientdev tunproto udpremote change_this_to_server_address 34557resolv-retry infinitenobindpersist-keypersist-tunca ca.crtcert client1.crtkey client1.keytls-auth ta.key 1remote-cert-tls servercipher AES-256-CBCcomp-lzoverb 3 Now merge certs and keys into client script, so we only have one file to handlecd $HOME/clientside/wget https://raw.githubusercontent.com/tinyvane/randomfiles/master/merge.sh -O merge.shsudo chmod +x merge.shsudo ./merge.shsudo chown $USER $HOME/clientside/raspberrypi.ovpn Now transfer client script raspberrypi.ovpnin $HOME/clientside/ to your client PCDue to permissions, I had to transfer it to C:\\Then in windows, copy the fileto C:\\Program Files (x86)\\OpenVPN\\config经过上面的处理，树莓派上的$HOME/clientside/目录下，会多了一个raspberrypi.ovpn文件，这个文件，要在之后，从树莓派上，复制到你本机电脑上OPENVPN的客户端下。 先不用着急，继续在树莓派上处理OPENVPN的服务器端脚本。 Server Scriptvim $HOME/serverside/server.conf port 34557proto udpdev tunca ca.crtcert server.crtkey server.keytls-auth ta.key 0dh dh2048.pemserver 10.8.0.0 255.255.255.0cipher AES-256-CBCcomp-lzopersist-keypersist-tunuser nobodygroup nogroupstatus openvpn-status.logverb 3push “redirect-gateway def1”push “dhcp-option DNS 202.106.46.151”push “dhcp-option DNS 202.106.195.68”keepalive 5 30 Now merge certs and keys into server script, so we only have one file to handlecd $HOME/serverside/wget https://raw.githubusercontent.com/tinyvane/randomfiles/master/merge_server.sh -O merge_server.shsudo chmod +x merge_server.shsudo ./merge_server.sh 经过上面的处理，在 下得到了一个新的文件 server.conf，将这个文件复制到 /etc/openvpn/ sudo cp $HOME/serverside/server.conf /etc/openvpn/ 编辑文件 /etc/sysctl.conf sudo vim /etc/sysctl.conf 找到下面这行，取消注释，允许数据转发。 net.ipv4.ip_forward=1 保存，退出。 让配置生效 sysctl -p Make file for firewall settingsudo vim /usr/local/bin/firewall.sh 添加下面内容 ``` bash#!/bin/bashiptables -t filter -Fiptables -t nat -Fiptables -A INPUT -p udp –dport 1194 -j ACCEPT #允许接收目的端口为1194的包；1194就是server.conf中配置的端口iptables -A FORWARD -m state –state RELATED,ESTABLISHED -j ACCEPTiptables -A FORWARD -s “10.8.0.0/24” -j ACCEPTiptables -A FORWARD -j REJECTiptables -t nat -A POSTROUTING -s “10.8.0.0/24” -j MASQUERADE #源地址转换：将vpn子网的ip替换为pi的本地ip，这句话我没有加，也能成功，不过还在深入学习防火墙的作用。#iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j SNAT –to-source 192.168.1.111 Make firewall script executable, run it and checksudo chmod +x /usr/local/bin/firewall.shsudo /usr/local/bin/firewall.shsudo iptables –list 得到类似下面的结果： Chain INPUT (policy ACCEPT)target prot opt source destination Chain FORWARD (policy ACCEPT)target prot opt source destinationACCEPT all – anywhere anywhere state RELATED,ESTABLISHEDACCEPT all – 192.168.10.0/24 anywhereREJECT all – anywhere anywhere reject-with icmp-port-unreachable Chain OUTPUT (policy ACCEPT)target prot opt source destination add new text line into file /etc/rc.localbefore ‘exit 0′ to ensure the firewall rules are run at reboot or power up.sudo vim /etc/rc.local /usr/local/bin/firewall.sh 重启树莓派 sudo reboot 记得在服务器上把server.conf中的端口号加入UDP转发到树莓派上，否则也是无法顺利连接上去的。 Connect VPN client from remote locationdoes not work when client and server are connectedto same router and you try external IP address.If you want to do a local test at homeconnect to local IP address of server e.g. 192.168.1.4when you go to your remote location, connect to no-ip address or external static IPVPN 客户端MAC下我使用的是TUNNELVPN，把之前文章里讨论的 raspberrypi.ovpn 文件，在运行VPN客户端之后，拖拽到右上角的图标上，然后就配置好了，点连接即可。 参考文章 树莓派搭建Openvpn Install latest openvpn and easyrsa3 利用 Privoxy 让命令行下的 wget 和 curl 等命令实现自动代理","link":"/2016/07/06/install_openvpn_on_raspberry/"},{"title":"如何在CENTOS6上安装GHOST","text":"文章更新 20160707-初次成文 为什么会有这篇文章因为想多试试不同的博客风格，而且据说GHOST和WP很像，并不是纯静态博客，所以才有了这个帖子。 安装准备接手一台新的服务器之前，必然是修改root密码，更改ssh端口，ssh免密连接，以及添加Yum源并且update这样的工作，就不多废话了。 安装Nginx配置 Nginx yum 源新建并编辑 Nginx yum 源文件：vim /etc/yum.repos.d/nginx.repo 12345[nginx]name=nginx repo baseurl=http://nginx.org/packages/centos/$releasever/$basearch/ gpgcheck=0 enabled=1 安装 Nginx1yum install nginx -y #安装 Nginx 然后查询下nginx的状态，由于EL6和EL7的区别，所以，如果你在CENTOS6下，是没有systemctl命令的，因为EL6是基于SYSV管理服务，而EL7是基于systemD来管理服务，所以命令上回有所不同。 如果是EL7 123systemctl enable nginx #设置 Nginx 随服务器自动启动systemctl start nginx #启动 Nginxsystemctl status nginx #查看 Nginx 状态，看到如图enabled 和 active 状态，则说明 Nginx 设置成功： 如果是EL6 123sudo service nginx statussudo service nginx startsudo service nginx status 查询nginx状态在浏览器访问服务器 IP 地址，如果可以看到 Nginx 的 Welcome to Nginx! 欢迎信息，说明 Nginx 配置成功。 使用 Nginx 反向代理 Ghost众所周知，网站基本都以 80 端口作为默认端口（除非你不想让别人访问你的网站），也就是说：访问域名或服务器 IP 地址，实际上是在访问该服务器的 80 端口。而 Ghost 默认运行在 2368 端口上。 为了输入域名或服务器 IP 地址就可以访问到你的 Ghost 博客，需要将访问 80 端口的请求，反向代理到 Ghost 的 2368 端口上： 12cd /etc/nginx/conf.d #进入 Nginx 配置目录vim ghost.conf #新建 Ghost 博客的 Nginx 配置文件 输入下面的代码 12345678910server { listen 80; # 下面修改为你的域名；如果没有域名，则输入服务器 IP 地址，并且记得末尾的分号 server_name your_domain_or_ip; location / { proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $http_host; proxy_pass http://127.0.0.1:2368; }} 修改 default.conf 文件名为 default.conf.bak，也就是使这个 Nginx 的默认配置文件失效，否则会跟上面的 Ghost 配置文件冲突 1mv default.conf default.conf.bak 重启 Nginx 12systemctl restart nginx #如果是EL7sudo service nginx restart #如果是EL6 使用 nginx -t 测试 Nginx 配置文件是否语法正确：若输出的结果有 ok、successful 等字样，表示配置正确 添加用于管理博客的用户 wwwLinux 系统有一套完整方便的用户权限控制方法。在生产环境部署应用时，使用 root 这个拥有服务器最高权限的用户是有风险的，而应该遵循最小权限原则，也就是说：只需要使用能满足应用正常运行的最低权限的用户即可。我们应该保持这样的良好习惯。 1234useradd -d /var/www www #添加用户 www 并指定其默认用户目录为 /var/wwwpasswd www #为用户 www 设置密码usermod -aG wheel www #把用户 www 添加到 wheel 用户组（方便用户 www 使用 sudo 命令）groups www #查看用户 www 的用户组，此时输出的结果应该是：www : www wheel，表明用户 www 位于 www 和 wheel 两个用户组 安装 Node.js123curl --silent --location https://rpm.nodesource.com/setup_4.x | bash -yum install nodejs -ynode -v #显示版本，我这里是4.4.7 另外一个安装的办法我并没有尝试，因为还没有系统的学习，就不想添加负担了，先继续把东西装好是第一位的。 从这个步骤开始，所有操作均在用户 www 下完成，即通过su www来切换到www用户下即可。 建议 Linux 和 OS X 用户使用 n 管理 Node.js 版本，Windows 用户使用 Nodist 安装 n 和 Node.js su www #切换至用户 wwwcurl -L http://git.io/n-install | N_PREFIX=/var/www bash #安装 n 重启 SSH 窗口，即可使用 n安装 Node.js v0.10.* 和 Node.js LTS：n 0.10 和 n lts，等待完成切换 Node.js 版本到 v0.10：输入n，用键盘方向键选择版本，如图： 切换node.js版本 温馨提示：严重建议使用 Node.js v0.10.* 运行 Ghost，其他版本暂时有各种大大小小的问题。 安装 Ghost 中文版将 Ghost 安装在 /var/www/ghost 目录下： mkdir /var/www #创建目录cd /var/www #进入wget http://dl.ghostchina.com/Ghost-0.7.4-zh.zip #下载 Ghost v0.7.4 中文版unzip Ghost-0.7.4-zh.zip -d ghost #解压 Ghost 中文版压缩包到 ghost 文件夹：cd ghost #进入 ghost 文件夹cp config.example.js config.js #从示例配置文件复制并新建 Ghost 配置文件 config.jsvim config.js #找到其中的 production 字段，也就是生产环境下的配置项，修改其中的 url 为自己的域名或服务器 IP 地址 我的 config.js 配置文件如下： 1234567891011121314151617181920production: { url: 'your domain or ip', mail: {}, database: { client: 'sqlite3', connection: { filename: path.join(__dirname, '/content/data/ghost.db') }, debug: false }, server: { host: '127.0.0.1', port: '2368' }, storage: { provider: 'local-file-store' } }, 12npm install --production #安装 Ghost 依赖npm start #测试 Ghost 是否安装成功 然后遇到了错误 12ERROR: Unsupported version of NodeGhost needs Node version ~0.10.0 || ~0.12.0 || ~4.2.0 you are using version 4.4.7 看来Ghost对node.js的版本确实比较挑剔，只好卸载了4.4.7，来重新安装Ghost的指定版本了。 yum remove nodejs -y 网上找了一下，在EL6下，没有4.2.x版本的node.js，所以只好找0.10.x了 地址在这里，http://nodejs.org/dist/latest-v0.10.x/node-v0.10.46-linux-x64.tar.gz然后，说一下没有找到rpm安装包，所以只能编译安装了。 为了编译node.js，需要yum install gcc make，或者yum -y groupinstall “Development Tools” 123456789101112yum -y groupinstall \"Development Tools\" #安装开发编译工具包，或者使用 yum install gcc-c++ makecd /usr/local/src #一般把下载的源代码放在这个目录下面wget http://nodejs.org/dist/latest-v0.10.x/node-v0.10.46.tar.gztar zxf node-*.tar.gz cd node-v* ./configure #准备进行编译，配置参数，虽然node.js没有这个步骤make #编译sudo make install #安装ln -s /usr/local/bin/node /usr/bin/node #创建软链接ln -s /usr/local/bin/npm /usr/bin/npm #创建软链接node --version #或者node -v 检查版本npm --version #或者npm -v 检查版本 node.js和npm就安装好了，然后执行 12npm install --production #安装 Ghost 依赖npm start #测试 Ghost 是否安装成功 又一个新错误 1ERROR: Cannot find module '/var/www/ghost/node_modules/sqlite3/lib/binding/node-v11-linux-x64/node_sqlite3.node' 从网上看了看这个错误，应该是环境编译有问题，重新来一次 12rm -rf node_modules &amp;&amp; npm cache clean npm install --production 这次虽然遇到了2个warn，但是最后成功了。 然后 npm start 浏览器输入购买的域名或服务器 IP 地址，如果能看到 Ghost 博客，说明 Ghost 安装成功关闭 Ghost：按 Ctrl + C PM2 使 Ghost 永久运行开发模式下的 Ghost 在你退出 SSH 终端窗口后，便会自动关闭。如果要让 Ghost 一直运行，需要使用进程守护软件守护 Ghost 进程，Node.js 社区比较火的两款进程守护软件为 Forever 和 PM2。这里使用 PM2 作为演示。 npm install -g pm2 #用 npm 全局安装 PM2cd /var/www/ghost #必须进入 Ghost 博客目录：NODE_ENV=production pm2 start index.js –name “ghost” #在 Ghost 博客目录下，让 Ghost 以 Production 模式（生产模式）运行，指定程序入口文件为 index.js，并且将此进程命名为 ghostpm2 startup centos #使 Ghost 开机自启动pm2 save #保存目前的 PM2 配置 温馨提示：PM2 重启进程的命令是 pm2 restart 进程名恭喜你！现在，浏览器中输入你的域名或服务器 IP 地址，就可以访问你的 Ghost 博客啦！浏览器地址栏增加 /ghost，如 http://loyalsoldier.me/ghost 即可访问 Ghost 博客管理后台。 使用pm2 restart ghost，没问题，然后使用pm2 show ghost，结果显示错误 1234567891011121314151617181920┌───────────────────┬───────────────────────────────────┐│ status │ errored ││ name │ ghost ││ restarts │ 60 ││ uptime │ 0 ││ script path │ /var/www/ghost/index.js ││ script args │ N/A ││ error log path │ /root/.pm2/logs/ghost-error-0.log ││ out log path │ /root/.pm2/logs/ghost-out-0.log ││ pid path │ /root/.pm2/pids/ghost-0.pid ││ interpreter │ node ││ interpreter args │ N/A ││ script id │ 0 ││ exec cwd │ /var/www/ghost ││ exec mode │ fork_mode ││ node.js version │ 0.10.46 ││ watch &amp; reload │ ✘ ││ unstable restarts │ 0 ││ created at │ N/A │└───────────────────┴───────────────────────────────────┘ 使用cat查看/root/.pm2/logs/ghost-error-0.log，发现错误是 12Error: invalid site url at ConfigManager.validate (/var/www/ghost/core/server/config/index.js:349:31) 原来是卡在这个函数上面 123456// Check that our url is valid if (!validator.isURL(config.url, {protocols: ['http', 'https'], require_protocol: true})) { errors.logError(new Error('Your site url in config.js is invalid.'), config.url, 'Please make sure this is a valid url before restarting'); return Promise.reject(new Error('invalid site url')); } 才知道，原来在config.js里面的url，需要https或者http开头，我直接写了个IP就不行啦，好办，直接改成http://ip 再次pm2 restart ghost &amp;&amp; pm2 show ghost，ok了这次。 第一次访问 Ghost 博客管理后台，需要按照流程注册一个账号，这个账号用于登录和管理 Ghost。以后，只需要访问 http://你的域名或服务器 IP 地址/ghost 即可撰写、发表博文！ 用 Git 为 Ghost 博客进行版本控制使用版本控制是一个技术人员必备的技能，也是一个好习惯。每次对内容的修改，推送到远程的版本库进行版本控制，有几个好处： 这些修改永远不会丢失（相当于内容备份）；万一修改出错，可以随时切换回旧版本的内容（相当于修改容错功能）；记录应用的改版历程……下面让我们以 Github 为例，看看怎么为 Ghost 博客使用 Git 版本控制服务（国内类似服务有 Git@OsChina）： 注册 Github 账号浏览器打开 https://github.com/new 新建 Github 仓库（git repo）：如图填写仓库名称和描述，点击Create Repository（创建仓库）： 创建Github仓库 进入 Ghost 博客目录：cd /var/www/ghost添加 Github 账号到 Git 中：git config –global user.email “you@example.com“（you@example.com 替换为注册 Github 的邮箱账号），然后添加 Github 用户名：git config –global user.name “Your Name”（Your Name 替换为你的 Github 账号昵称）初始化 Git 仓库：git init将刚刚新建的 Github 仓库地址添加到 Ghost 目录：git remote add origin https://github.com/你的 Github 用户名/你的仓库名称.git，如图红色方框所示： 添加远程仓库 把 Ghost 博客目录下所有文件改动添加到 Git 暂存区（Git Index）：git add .（这里确实有个英文句号）提交更改到 Git 本地仓库（Local Repository）：git commit -m “XXXX”（XXX 部分替换为本次提交修改的内容，如“发布博文《在阿里云 CentOS 7 系统上部署 Ghost 博客》”）把本次更改推送到远程仓库（Upstream Repository）：git push -u origin master每次对 Ghost 博客目录的文件或内容进行了修改，或发布了新博文，都可以重复步骤 7~9，将修改推送到 Github，称之为版本控制。 升级 Ghost 到最新版本最新版 Ghost 中文版可以在 Ghost 中文网 找到Ghost 中文版更新方法参照 这个说明 中的“如何升级”部分 参考文章 在阿里云 CentOS 7 系统上部署 Ghost 博客","link":"/2016/07/07/how_to_install_ghost_on_centos_6/"},{"title":"树莓派折腾之：搭建FTP服务","text":"文章更新 20160706-初次成文 为什么会有这篇文章其实一直想弄FTP，但是没有动力，直到这两天搭建OPENVPN，要下载几个服务器上的证书和配置文件到本地，才觉得用FTP方便一些。 下载安装vsftp安装vsftp，开源的轻量级的常用ftp服务器 1sudo apt-get install vsftpd 先备份，然后编辑配置文件, 12sudo cp /etc/vsftpd.conf /etc/vsftpd.conf.origsudo vim /etc/vsftpd.conf vsftp的配置文件，它允许你设置所有类型的限制和策略，目前没有深入研究，修改如下 123456# 不允许匿名访问anonymous_enable=NO# 设定可以进行写操作write_enable=YES# 设定本地用户可以访问local_enable=YES 重启vsftpd服务 1sudo service vsftpd restart 通过ftp连接树莓派系统，以用户名pi登录，密码是pi用户的密码。ftp的根目录是/home/pi，即pi用户的HOME目录，可上传或下载文件了。 需要注意记得要在防火墙上，开启21端口，并且最好做端口转发，因为我所在的北京联通就封掉了80和21端口，而且谁也不想天天看一堆暴力破解天天攻击你的FTP端口吧。 参考文章 Raspberry Pi从零开始搭建低成本NAS(6)-文件共享","link":"/2016/07/06/how_to_install_ftp_on_raspberry/"},{"title":"Linux/Raspbian每个目录用途说明","text":"文章更新 20160707-初次成文 为什么会有这篇文章因为在使用apt-get purge remove openvpn之后，发现系统里依然有很多openvpn名字的目录或者文件，比如像下面这样 1234567/usr/sbin/openvpn/etc/default/openvpn/etc/network/if-down.d/openvpn/etc/network/if-up.d/openvpn/etc/bash_completion.d/openvpn/etc/init.d/openvpn/run/openvpn 有强迫症+洁癖的我当然就很不爽了，挨个查看之后，就删掉了这些，但是对于一些目录的用户比较感兴趣，就找到了下面这篇文章，英文的，翻译了，留在这里，增加自己对LINUX系统的了解。 Linux和Windows的区别的显著区别之一就是其不同的目录结构，并不仅仅是格式上的不同，而是不同位置上保存的东西区别很大。 在Windows中，典型的路径可能是这样的 D:\\Folder\\subfolder\\file.txt，而在Linux中，路径则是这样的 /Folder/subfolder/file.txt。 斜线倾斜的方向不同，并且，在Linux中，也没有C盘D盘的概念，Linux系统启动之后，根分区 就”挂载”在了在了 / 的位置，并且所有的文件、文件夹、设备以及不同的硬盘光驱之类的，也都挂载在了 /。 虽然可能在下面这个例子中并不明显，但是Linux系统对文件或者文路径的名称中的大小写字符是敏感的。 比如 /Folder/subfolder/file.txt 与 /folder/subfolder/file.txt并不是同一个文件。 Linux系统目录说明Unix中和Linux的目录结构是一个统一的目录结构，所有的目录和文件最终都统一到”/“根文件系统下。文件系统是无论是不是挂载过来的，最终都分层排列到以”/“为起始的文件系统之下。Linux目录结构遵循”文件系统层次结构（Filesystem Hierarchy Structure，FHS)”，这标准是由“自由标准组织（Free Standards Group）”进行维护的，然而大多数LINUX发行版都有意或者无意的与这一规范背离。 “/“ 根路径 这是Linux系统的“根”目录，也是所有目录结构的最底层。在UNIX以及和它兼容的系统中，”/“是一个单独的目录。 /boot 这个目录下包含系统启动文件（boot loader），例如Grub，Lilo或者Kernel，以及initrd，system.map等配置文件。 Initrd ramdisk或者””initrd””是指一个临时文件系统，它在启动阶段被Linux内核调用。initrd主要用于当“根”文件系统被挂载之前，进行准备工作。 /sys 这个目录下包含内核、固件以及系统相关文件。 /sbin 包含系统操作和运作所必需的二进制文件以及管理工具，主要就是可执行文件。类似WINDOWS下的EXE文件。 /bin 包含单用户模式下的二进制文件以及工具程序，比如cat，ls，cp这些命令。 /lib 包含/sbin和/bin目录下二进制文件运行所需要的库文件。 /dev 内含必需的系统文件和驱动器。 /etc 内含系统配置文件，其下的目录，比如 /etc/hosts, /etc/resolv.conf, nsswitch.conf, 以及系统缺省设置，网络配置文件等等。以及一些系统和应用程序的配置文件。 /home 每一个用户的在这个目录下，都会单独有一个以其用户名命令的目录，在这里保存着用户的个人设置文件，尤其是以 profile结尾的文件。但是也有例外，root用户的数据就不在这个目录中，而是单独在根路径下，保存在单独的/root文件夹下。 /media 一个给所有可移动设备比如光驱、USB外接盘、软盘提供的常规挂载点。 /mnt 临时文件系统挂载点。比如，你并不想长期挂载某个驱动器，而是只是临时挂载一会U盘烤个MP3之类的，那么应该挂载在这个位置下。 /opt 在Linux系统中，这个目录用到的并不多，opt是 可选系统程序包（Optional Software Packages）的简称。这个目录在UNIX系统，如Sun Solaris用途要广泛的多。 /usr 用户数据目录，包含了属于用户的实用程序和应用程序。这里有很多重要的，但并非关键的文件系统挂载这个路径下面。在这里，你会重新找到一个 bin、sbin 和 lib目录，其中包含非关键用户和系统二进制文件以及相关的库和共享目录，以及一些库文件。 /usr/sbin 包含系统中非必备和并不是特别重要的系统二进制文件以及网络应用工具。 /usr/bin 包含用户的非必备和并不是特别重要的二进制文件。 /usr/lib 保存着/usr/sbin以及/usr/bin中二进制文件所需要的库文件。 /usr/share “平台无关”的共享数据目录。 /usr/local 是/usr下的二级目录，这里主要保存着包含系统二进制文件以及运行库在内的本地系统数据。 /var 这个路径下通常保存着包括系统日志、打印机后台文件（spool files）、定时任务（crontab）、邮件、运行进程、进程锁文件等。这个目录尤其需要注意进行日常的检查和维护，因为这个目录下文件的大小可能会增长很快，以致于很快占满硬盘，然后导致系统便会出现各种奇奇怪怪的问题。 /tmp 顾名思义，这是一个临时文件夹，专门用来保存临时文件，每次系统重启之后，这个目录下的”临时”文件便会被清空。同样，/var/tmp 也同样保存着临时文件。两者唯一的不同是，后者 /var/tmp目录保存的文件会受到系统保护，系统重启之后这个目录下的文件也不会被清空。 /proc 这个目录是驻留在系统内存中的虚拟（psuedo，伪）文件系统，其中保存的都是文本格式的系统内核和进程信息。 LINUX系统目录结构图 需要注意的是，不同LINUX发行版本的目录结构会有一些差异，这对LINUX新手来说比较纠结，但是大体上，所以LINUX的不同发行版本，都符合上面这幅图片中的路径结构。 参考文章1.Linux Directory Structure Overview","link":"/2016/07/07/directory_introduction_in_linux_or_raspbian/"},{"title":"搬瓦工自动配置shadowsocks翻墙","text":"文章更新 20160708-初次成文 为什么会有这篇文章便宜买了个搬瓦工的VPS，就是为了能科学上网用，看到在主机的控制面板里，竟然有一键配置，觉得搬瓦工还是很人性化的，能简单的地方就不要复杂嘛。 一键安装shadowsocks搬瓦工自带shaowsocks一键安装，直接进入KiwiVM控制面板，拉倒最下面的Shadowsocks Server，安装就好。然后系统就会分配IP、端口和密码，如果自己用，直接使用就行了。 配置说明自带的系统只有一个用户，想自己多弄几个用户，就要自己更改配置。SS官方的WIKI上，也公布了单用户配置，和多用户配置两个具体配置文件。 1vim /etc/shadowsocks.json 我使用的多用户配置， 1234567891011121314{ \"server\":\"my_server_ip\", \"local_address\": \"127.0.0.1\", \"local_port\":1080, \"port_password\": { \"8381\": \"foobar1\", \"8382\": \"foobar2\", \"8383\": \"foobar3\", \"8384\": \"foobar4\" }, \"timeout\":300, \"method\":\"aes-256-cfb\", \"fast_open\": false} 配置的说明：server the address your server listens（服务器IP）local_address the address your local listens（本地代理地址）local_port local port（本地代理端口）port_password password used for encryption(自己设定的服务器端口和密码)timeout in seconds（超时断开，以秒为单位）method default: “aes-256-cfb”, see Encryption（加密方式）fast_open use TCP_FASTOPEN, true / false（是否使用TCP）workers number of workers, available on Unix/Linux（这个只在Unix和Linux下有用，可不设置） SS的启动可选择前端启动（可看见日志），或者后台启动 前端启动： ssserver -c /etc/shadowsocks.json 后端启动： 开始：ssserver -c /etc/shadowsocks.json -d start结束：ssserver -c /etc/shadowsocks.json -d stop 设置开机启动设置好了，但是如果只是这样，那每次都要手动启动ss，太麻烦。可以将其加到开机启动项。 1vim /etc/rc.local 将最后一行删掉，那是官方的默认配置，然后添加一行 1ssserver -c /etc/shadowsocks.json -d start 其他说明非root用户运行ss 按照上面的设置shadowsocks是以root权限运行的，不是很安全，可以这样设置。 sudo useradd ssuser //添加一个ssuser用户 sudo ssserver [other options] –user ssuser //用ssuser这个用户来运行ss 其中的[other options]是只，之前启动ss的命令，比如ssserver -c /etc/shadowsocks.json -d start。这样就可以使用非root用户来运行ss了。 然后修改开机启动项，将之前的ssserver -c /etc/shadowsocks.json -d start改为ssserver -c /etc/shadowsocks.json -d start –user ssuser，然后保存就OK了。 更多的问题，请看官方的说明文档。 参考文章 搬瓦工Shadowsocks配置总结","link":"/2016/07/08/how_to_scientificly_online_by_shadowsocks/"},{"title":"树莓派折腾之：树莓派和ShadowSocks","text":"文章更新 20160712-初次成文 20160907-CENTOS安装方法 为什么会有这篇文章因为发现在树莓派系统中，使用wget下载OPENVPN源代码的时候，远程服务器竟然连不上，估计是被QIANG掉了，所以，只能在树莓派上安装ShadowSocks的客户端了，用来让树莓派访问那些被功夫网鄙视的网站了。 树莓派安装Shadowsocks客户端先保证你的QIANG外服务器上安装好了Shadowsocks的服务器端，如何安装可以参考我的另外一篇文章：《搬瓦工自动配置shadowsocks翻墙》，记下服务器的IP、端口号、密码以及加密方式。 接下来, 在树莓派上配置Shadowsocks客户端, 这是让树莓派翻QIANG的必要条件。 123456#安装pip管理python包sudo apt-get install python-pip python-m2crypto#安装python版shadowsockssudo pip install shadowsocks#设置shadowsocks客户端配置文件sudo vim /etc/shadowsocks.json shadowsocks.json文件内容模板如下： 1234567891011{ \"server\":\"xxx.xxx.xxx.xxx\", //VPS IP \"server_port\":8388, //VPS端口 \"local_address\": \"xxx.xxx.xxx.xxx\", //树莓派IP \"local_port\":1080, //树莓派端口 \"password\":\"mypassword\", //VPS上设置shadowsocks服务器的密码 \"timeout\":60, \"method\":\"encrypt_method\", //VPS 上设置的加密方式, 不知道可以选择\"aes-256-cfb\" \"fast_open\": false, \"workers\": 1} 若要设置SS客户端开机自启动，需编辑/etc/rc.local文件，在最后的exit一行之前添加： 1/usr/local/bin/sslocal -c /etc/shadowsocks.json -d start 然后检查sslocal是否正确运行 1sudo systemctl status rc-local.service 如果rc.local正确运行，可以看到类似下面的的输出： 123456789● rc-local.service - /etc/rc.local Compatibility Loaded: loaded (/lib/systemd/system/rc-local.service; static) Drop-In: /etc/systemd/system/rc-local.service.d └─ttyoutput.conf Active: active (running) since Wed 2016-07-13 00:06:01 CST; 1min 40s ago Process: 603 ExecStart=/etc/rc.local start (code=exited, status=0/SUCCESS) Main PID: 1072 (sslocal) CGroup: /system.slice/rc-local.service └─1072 /usr/bin/python /usr/local/bin/sslocal -c /etc/shadowsocks.json -d start curl和wget实例具体如何让curl和wget走代理呢？很简单 12curl -x http://127.0.0.1:1080 github.comwget -e \"http_proxy=127.0.0.1:1080\" github.com GAME OVER. 参考文章 在树莓派上设置透明代理","link":"/2016/07/12/raspberry_pi_and_shadowsocks/"},{"title":"树莓派折腾之：BTSYNC同步所有电脑和手机","text":"文章更新 20160526-初次成文 20160712-内容独立分拆，补充了脚本内容，文章添加部分内容 20160714-添加了一个检测BTSYNC挂载盘丢失重新挂载的脚本 20160722-修改了btsync控制脚本，并且将daemon user从btsync改为pi 20160724-修改了btsync控制脚本，以及btsync.confg配置文件 20160818-在海外的VPS上装了BTSYNC，只是因为有一个静态IP可以当做known_hosts来加强不同主机之间的联系 20160819-更改了外接盘挂掉检测脚本，remount方式更加可靠。 20160830-BTSync正式改名为Resilio Sync，文章内容基于2.4.0 RC2 20160901-更新了在CentOS 7上安装Resilio Sync，CentOS的防火墙设置 20160909-更新了Resilio Sync Archive 目录的运行机制，请注意阅读相关章节 20160913-更新了软件的使用注意事项 为什么会有这篇文章因为电脑越来越多，又想进一步提高效率，本文初衷就是这么简单，工作文件，生活照片，随手可得，这就是这篇文章的目标。至于为什么推荐BiTtorent Sync(现在已经改名了，叫Resilo Sync)，可能是因为最早接触吧。而且网上介绍的文章比较多，并且自己有一个树莓派24小时开机，不利用起来说不过去。至于类似的方案嘛，最近从小众软件听说了Syncthing，应该也是个不错的替代品，因为后者开源并且免费。但是我目前已经用了BTSYNC很久了，并且买了个人永远授权，对于我来说稳定熟悉的工具效率更高一些。 在MAC和PC上安装Resilio Sync因为都有相应的客户端，也没啥好设置的，打开用即可，所以就不多介绍了，重点介绍在CENTOS和树莓派两个平台上的安装。Resilio Sync软件的官方地址在这里，可以看到BTSYNC几乎是各种平台全覆盖，不得不觉得很细心。2.4.0 rc2的内测地址在这里 在树莓派上上安装Resilio Sync### 为BTSYNC创建独立账户 1sudo adduser --quiet --system --group --disabled-password btsync 我后来没有使用Resilio Sync独立账户，而直接使用了pi账户，因为权限问题有点复杂。 下载并安装1234cd /usrsudo wget http://internal.getsync.com/2.4.0.662_SYHTTS/resilio-sync_arm.tar.gz #树莓派需要下载ARM版本sudo tar -zxvf resilio-sync_arm.tar.gz -C /usr/local/sbin rslsync #解压缩,btsync表示只需要压缩包中的 rslsync 一个文件/usr/local/sbin/rslsync --webui.listen 0.0.0.0:8888 #初次运行，监听8888端口提供GUI管理界面 然后，在手机或者电脑上访问 http://your_raspberry_ip:8888/gui 即可看到GUI界面。 需要注意的是，这样执行，只按照默认配置执行的，如果需要定义自己的配置，请首先通过 ./rslsync --dump-sample-config 来dump一份默认的配置文件，文件名是 rslsync.conf 例如执行 1/usr/local/sbin/rslsync --dump-sample-config &gt; /etc/rslsync.conf 这个文件，需要修改的主要就是给你这台运行btsync的服务器起个名字，并且修改下密码以及监听端口，然后以后每次执行，就可以通过 ./rslsync --config rslsync.conf 来执行你配置好的参数了。 配置开机启动为了让Resilio Sync每次树莓派开机都启动，我参考这个地方，写了个脚本放在/etc/init.d下面 1sudo vim /etc/init.d/rslsync.sh 脚本如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#!/bin/sh# /etc/init.d/rslsync#set -x### BEGIN INIT INFO# Provides: rslsync daemon# Required-Start: $remote_fs $syslog# Required-Stop: $remote_fs $syslog# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: Resilio Sync server daemon# Description: This service is used to support the Resilio Sync.# Placed in /etc/init.d/### END INIT INFO# Original Author: Nicolas Bernaerts &lt;nicolas.bernaerts@laposte.net&gt;# Current Author: FOOLMAN &lt;tinyvane@gmail.com&gt;# Version:# Ori V1.0, 06/09/2013 - Creation# Ori V1.1, 09/09/2013 - Use under-priviledged system user# Ori V1.0, 07/12/2016 - Localized into China Raspberry Pi Users# Ori V2.0, 07/22/2016 - Change daemon user from btsync to pi# Cur V3.0, 08/25/2016 - Change pid file location and delete pidmake parameter from start-stop-daemon# Cur V3.1, 08/30/2016 - Necessary change of service name from btsync for rslsync. /lib/lsb/init-functions# description variablesPATH=/sbin:/usr/sbin:/bin:/usr/bin:/usr/local/sbinDESC=\"Resilio Sync server\"DAEMON_NAME=\"rslsync\"DAEMON_USER=\"pi\"DAEMON_PATH=\"/usr/local/sbin/${DAEMON_NAME}\"DAEMON_OPTS=\"\"DAEMON_DESC=$(get_lsb_header_val $0 \"Short-Description\")DAEMON_PID=\"/home/pi/.sync/sync.pid\"DAEMON_LOG='/var/log/rslsync'# Exit if rslsync program is not installedif [ ! -x \"${DAEMON_PATH}\" ] ; then echo \"Binary ${DAEMON_PATH} does not exist. Aborting\" exit 0fi# Exit if rslsync user home directory doesn't exist, is \"pi\" in this script.if [ ! -d \"/home/${DAEMON_USER}\" ]; then echo \"User /home/${DAEMON_USER} does not exist. Aborting\" exit 0fi# Function that starts the daemon/service# 0 - daemon started# 1 - daemon already running# 2 - daemon could not be starteddo_start() { local result pidofproc -p \"${DAEMON_PID}\" \"${DAEMON_PATH}\" &gt; /dev/null if [ $? -eq 0 ]; then log_warning_msg \"${DAEMON_NAME} is already started\" result=0 else log_daemon_msg \"Starting ${DAEMON_DESC}\" \"${DAEMON_NAME}\" touch \"${DAEMON_LOG}\" chown $DAEMON_USER \"${DAEMON_LOG}\" chmod u+rw \"${DAEMON_LOG}\" if [ -z \"${DAEMON_USER}\" ]; then start-stop-daemon --start --quiet \\ --exec \"${DAEMON_PATH}\" -- --config /etc/rslsync.conf result=$? else start-stop-daemon --start --quiet \\ --chuid \"${DAEMON_USER}\" \\ --exec \"${DAEMON_PATH}\" -- --config /etc/rslsync.conf result=$? fi log_end_msg $result fi return $result}# Function that stops the daemon/service# 0 - daemon stopped# 1 - daemon already stopped# 2 - daemon could not be stoppeddo_stop() { # Stop the daemon local result pidofproc -p \"${DAEMON_PID}\" \"${DAEMON_PATH}\" &gt; /dev/null if [ $? -ne 0 ]; then log_warning_msg \"${DAEMON_NAME} is not started\" result=0 else log_daemon_msg \"Stopping ${DAEMON_DESC}\" \"${DAEMON_NAME}\" pkill -p \"${DAEMON_PID}\" \"${DAEMON_PATH}\" result=$? log_end_msg $result # remove pid file rm -f \"${DAEMON_PID}\" fi return $result}do_restart() { local result do_stop result=$? if [ $result = 0 ]; then do_start result=$? fi return $result}do_status() { local result status_of_proc -p \"${DAEMON_PID}\" \"${DAEMON_PATH}\" \"${DAEMON_NAME}\" result=$? return $result}do_usage() { echo $\"Usage: $0 {start | stop | restart | status}\" exit 1}# deal with different parameters : start, stop &amp; statuscase \"$1\" in start) do_start; exit $? ;; stop) do_stop; exit $? ;; restart) do_restart; exit $? ;; status) do_status; exit $? ;; *) do_usage; exit 1 ;;esac PS: 说明，这个脚本我修改了好几遍，需要注意的是，因为在btsync.conf配置文件中，有指定pid文件的选项，导致和控制脚本的makepid总是冲突，因为我把btsync.conf中pid file的相关选项给注释掉了，然后只用控制脚本的makepid选项来控制pid文件的创建和删除，目前看上去一切正常。 PS: 经过几个月的使用和证实，发现即便不指定btsync.conf中的PID文件的位置，BTSYNC也会在/home/pi/.sync目录下，生成一个叫sync.pid的文件，而通过 --pidfile &quot;${DAEMON_PID}&quot; --make-pidfile \\参数指定的pid文件，pid的数值却不正确。所以我在最新的脚本文件里，start-stop-daemon命令里，删掉了--pidfile &quot;${DAEMON_PID}&quot; --make-pidfile \\。并且，将控制脚本里的DAEMON_LOG='/var/log/btsync'这句话，直接指定到了/home/pi/.sync/sync.pid，然后发现脚本终于可以通过systemctl start/stop btsync来手动控制BTSYNC的启动和停止了。 然后给可执行权限，并且加入到启动项中 12sudo chmod +x /etc/init.d/rslsyncsudo update-rc.d rslsync defaults 如果需要手动停止和启动Resilio Sync，则使用下面的命令即可 123sudo service rslsync start #启动BTSyncsudo service rslsync stop #停止BTSyncsudo service rslsync status #查看BTSync状态 rslsync.conf详解我的配置如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081{ \"device_name\": \"Pi in Beijing\", \"listening_port\" : 0, // 0 - randomize port/* storage_path dir contains auxilliary app files if no storage_path field: .sync dir created in current working directory */ \"storage_path\" : \"/home/pi/.sync\", //这个地方如果注释掉的话，RslSync会在rslsync可执行程序的同级目录下建立.sync目录，不是很直观/* set location of pid file */ //\"pid_file\" : \"/home/btsync/btsync.pid\", //我把这句给注释掉地了，因为和控制脚本中的makepid冲突了，具体原因，大家可以自己感受一下/* use UPnP for port mapping */ \"use_upnp\" : true,/* limits in kB/s. 0 - no limit */ \"download_limit\" : 0, \"upload_limit\" : 0,/* proxy configuration */// \"proxy_type\" : \"socks4\", // Valid types: \"socks4\", \"socks5\", \"http_connect\". Any other value means no proxy// \"proxy_addr\" : \"192.168.1.2\", // IP address of proxy server.// \"proxy_port\" : 1080,// \"proxy_auth\" : false, // Use authentication for proxy. Note: only username/password for socks5 (RFC 1929) is supported, and it is not really secure// \"proxy_username\" : \"user\",// \"proxy_password\" : \"password\", \"webui\" : { \"listen\" : \"0.0.0.0:8888\" // remove field to disable WebUI/* preset credentials. Use password or password_hash */ ,\"login\" : \"username\" ,\"password\" : \"password\"// ,\"password_hash\" : \"some_hash\" // password hash in crypt(3) format// ,\"allow_empty_password\" : false // Defaults to true/* ssl configuration */// ,\"force_https\" : true // disable http// ,\"ssl_certificate\" : \"/path/to/cert.pem\"// ,\"ssl_private_key\" : \"/path/to/private.key\"/* directory_root path defines where the WebUI Folder browser starts (linux only). Default value is / */// ,\"directory_root\" : \"/home/pi/MySharedFolders/\"/* directory_root_policy defines how directory_root is used (linux only). Valid values are: \"all\" - accepts directory_root and its subdirectories for 'getdir' and 'adddir' actions \"belowroot\" - accepts directory_root's subdirectories for 'getdir' and 'adddir' actions, but denies attempts to use 'adddir' to create directories directly within directory_root Default value is \"all\". */// ,\"directory_root_policy\" : \"all\"/* dir_whitelist defines which directories can be shown to user or have folders added (linux only) relative paths are relative to directory_root setting */// ,\"dir_whitelist\" : [ \"/home/user/MySharedFolders/personal\", \"work\" ] }/* !!! if you set shared folders in config file WebUI will be DISABLED !!! shared directories specified in config file override the folders previously added from WebUI. *//*, \"shared_folders\" : [ { \"secret\" : \"MY_SECRET_1\", // required field - use --generate-secret in command line to create new secret \"dir\" : \"/home/user/bittorrent/sync_test\", // * required field \"use_relay_server\" : true, // use relay server when direct connection fails \"use_tracker\" : true, \"search_lan\" : true, \"use_sync_trash\" : true, // enable SyncArchive to store files deleted on remote devices \"overwrite_changes\" : false, // restore modified files to original version, ONLY for Read-Only folders \"known_hosts\" : // specify hosts to attempt connection without additional search [ \"192.168.1.2:44444\" ] } ]*//* Advanced preferences can be added to config file. Info is available at \"http://help.getsync.com/customer/portal/articles/1902048-sync-advanced-preferences--more-options\"For example see folder_rescan_interval below *///, \"folder_rescan_interval\" : \"86400\"} 有几个地方一定要注意 “device_name”: “Pi in Beijing” #这个是你服务器的标示，改一个比较容易记的 “storage_path” : “/home/pi/.sync”, #这个是配置文件，一定要设置好位置 “pid_file” : “/home/pi/.sync/sync.pid”, #这个是进程的pid文件位置，如果你使用了上面我的启动脚本，请记得这里一定要设置和我这里相同 2和3的权限，一定要属于btsync，并且记得给外接硬盘上的btysnc目录权限，可以使用 sudo chown -R btsync:btsync file 检测脚本发现BTSYNC经常无缘无故的挂掉，因此就想用一个脚本，放在系统cron中每10分钟检测一次，重新挂载，不过现在觉得这不是解决之道，要么是树莓派3无法承受高IO，要么是我的系统有问题，准备重新刷机之后在看看。无论如何，脚本先放出来吧，大家参考一下思路就够了。 12345678910111213141516171819#!/bin/shset -x#date：2016/08/19logFile=\"/var/log/BTSyncCheck.log\"df -l | grep \"13db65cc-f3f1-4158-8cc6-118602a6a7dc\"if [ $? -ne 0 ]then echo \"$(date) $(time) Everthing seems to be fine....\" &gt;&gt; $logFile exit 1else echo \"$(date) $(time) WTF! Pi could not find portable hd again! Let's do something：.....\" umount /media/pi/13db65cc-f3f1-4158-8cc6-118602a6a7dc umount -lf /mnt/hd250g mount UUID=\"13db65cc-f3f1-4158-8cc6-118602a6a7dc\" /mnt/hd250g echo \"$(date) $(time) Portable HD remount. Glad to know everything got back to normal!\" &gt;&gt; $logFile exit 1fi 关于shell脚本编程，我单独开了一个帖子，介绍了条件检测和条件判断的几种例子，地址在这里。 将脚本加入系统cron中 1sudo vim /etc/crontab 加入这么一句 1*/10 * * * * root /usr/BTSyncCheck.sh &amp; 建立日志文件 1sudo touch /var/log/BTSyncCheck.log 在CentOS系统上安装下载并导出配置我的CentOS有6和也有7，除了systemctl和service那块，几乎没什么差别，注意选择安装程序的版本就好了。另外需要注意的是，CentOS 7默认没有安装iptable，而改用了新的firewall-cmd命令，所以，还需要注意在防火墙中把Resilio Sync的的listening port加进去，否则不同peer之间也容易联系不到彼此，尤其是在企业环境下，企业防火墙设置一般是除了80端口其他端口一律封掉，所以，如果迫不得已，你可以需要让Resilio Sync监听80端口，然后用VPN做返现代理。关于CentOS 7的防火墙设置，可以看我的另外一篇帖子 123wget http://internal.getsync.com/2.4.0.662_SYHTTS/resilio-sync_x64.tar.gz -O /usrtar -zxvf /usr/resilio-sync_x64.tar.gz -C /usr/local/sbin rslsync/usr/local/sbin/rslsync --dump-sample-config &gt; /etc/rslsync.conf #导出配置文件 编辑配置rslsync.conf因为写过好多遍了，这里就不啰嗦了，主要修改的地方就几个 123456789101112{ \"device_name\": \"&lt;这里要成你想要的名字&gt;\", \"listening_port\" : 0, // 如果不设置，就随机使用端口，如果你的路由器不支持UPNP，就需要指定一个端口(在指定端口的同时，要禁用UPNP)，否则会连不到relay server或者联系不到你的其他peer // 这个port还有一个作用，其实指定了也比较好，就是需要把他当做known——host的时候，这样可以让其他的链接到这个服务器，然后帮助peer各自找到其他的peer \"webui\" : { \"listen\" : \"0.0.0.0:8888\", //如果有需求，可以修改这里，因为8888这个端口太招摇了，所以还是换一个比较隔色的比较好 \"login\" : \"username\", \"password\" : \"password\" } ,\"directory_root\" : \"/home/pi/MySharedFolders/\" //指定默认目录，比如你外接了硬盘，这里还是要指定} 运行RslSync一句话 1/usr/local/sbin/rslsync --config /etc/rslsync.conf 把RslSync加入开机启动在文件 /etc/rc.local 的末尾处的 exit 0 前一行加入 1/usr/local/sbin/rslsync --config /etc/rslsync.conf 在CentOS 7中，rc.local已经不被推荐使用，所以最好编写控制脚本，放到/etc/init.d目录下去，并配合使用systemd来控制服务的启动、停止等动作。 当然了，如果你是服务器，N天不断电的那种，单独执行也就够了。 重启机器，RslSync就启动了。 通过本地浏览器打开 &lt;服务器的IP地址&gt;:&lt;端口&gt;/gui 登陆以后，输入账号密码，即可开始使用Sync。 文件丢失惊魂准备重新刷一次系统盘，重装下系统看看，好在BTSYNC还有20多天的试用期才结束，不过昨天发现我的40多G的照片，在另外一个台式机上没了，吓死我了，后来终于在 .sync 下的 .archive 目录下找到了，稍微安心一点，看来备份无论什么时候都不能放松。关于这个目录中到底有什么，我这里也从官方论坛找到了解释，在下面附上一小节来说一下。 关于.sync目录中文件的作用特别注意，.sync目录下的文件不要轻易移动，尤其是那些 0 byte 的文件，如果你发现你的同步目录下的文件没了，而在 .sync 目录下发现了，不要轻易把文件移动回来，经过我的本人的多次确认，并且以丢失了10张照片和一段视频为代价，确认了 Resilio Sync 使用 Archive 的目录并不是单纯地存放被删掉的文件，并且也是它的临时目录，Sync可能会在同步的过程中，把文件移动到 Archive 目录下，并不是被它删除了，过一段时间，Sync 会自动把文件恢复原样的。 而更为严重的是，如果你把 .sync 目录下的零字节文件不小心移动回了你的共享目录下的话，那么你的文件就永远无法找回来了，切记！切记！ 每个你创建的BTSYNC共享目录，或者从其他设备上同步过来的目录下面，系统都会自动创建一个隐藏的.sync目录(这个目录在MAC系统上是Archive)，这个目录里面，主要包含着BTSYNC的存档文件。具体结构见下图。 主要包含： .sync 目录，默认是隐藏不可见的。 .DS_Store 目录，（是桌面服务存储的缩写，Desktop Services Store），这是由MAC OSX系统创建的，用来存储例如桌面图标位置或者背景文件，这个目录只有在MAC系统下才有。 一个叫 Archive 目录，里面包含着被删掉的文件，或者是文件的早期版本。 ID，IgnoreList, StreamsList 等三个文件。ID代表着目录的标识符，它允许BTSYNC找到需要同步的文件的正确片段并且进行同步。IgnoreList 允许你指定哪个文件或目录被同步(pro 高级版功能)。如果想知道 IgnoreList 的具体语法，请参见官方说明。StreamsList文件允许你为不同的 streams, xattrs and resource forks 设置“白名单”。更多的信息，可以参考这里。 用户的文件。 .sync 目录的存在对于Resilio Sync来说十分重要，如果这个目录被你删掉了，会引起103错误 这段翻译自BTSYNC的官方博客，具体地址见这里。 软件使用注意事项这个是我使用Resilio Sync小半年的总结，希望别人少走一些弯路吧 像上面说的，.sync目录下的的文件不要轻易移动，尤其是那些零字节的文件 手机的备份目录，不要备份到过多的地方，因为每个peer上的备份，都是独立的，比如你把iphone上的照片备份到了peer A和peer B上，那么你在peer A上删掉了照片，但是peer B上的照片不会删掉，会一直保存在peer B里面，并且在peer A上，看到的这个备份目录的大小，不会是0，而是peer B上的容量。 先写这么多吧 参考资料 INSTALLING BITTORRENT SYNC ON RASPBERRY PI","link":"/2016/07/12/use_btsync_to_sync_files_among_terminals_based_on_raspberry_pi/"},{"title":"使用GITHUB管理开发代码","text":"文章更新 20160713-初次成文 为什么会有这篇文章因为有一些C#和PHP的项目，开始慢慢转移到GITHUB上做代码托管了，所以需要一个系统学习git的文章了。 第一步 建立一个远程仓库直接在GITHUB上建立，选择SSH方式。 第二部 本地仓库1234567mkdir ~/Desktop/randomfiles &amp;&amp; cd ~/Desktop/randomfiles echo \"# randomfiles\" &gt;&gt; README.mdgit initgit add README.mdgit commit -m \"first commit\"git remote add origin git@github.com:tinyvane/randomfiles.gitgit push -u origin master 遇到的问题 问题 123456error: Your local changes to the following files would be overwritten by merge: package.json source/_posts/201607012-树莓派折腾之：BTSYNC同步所有电脑和手机.md source/_posts/20160722-使用SYNCTHING在树莓派上替代BT-SYNC.mdPlease, commit your changes or stash them before you can merge.Aborting 解决办法： 这是典型的代码冲突，其他机器上commit过代码，本机上修改了代码，但是没有事先pull，就会遇到这个问题。 参考文章","link":"/2016/07/13/use_github_to_manage_your_code/"},{"title":"树莓派进入紧急模式的解决办法","text":"文章更新 20160714-初次成文 20170412-更新内容 为什么会有这篇文章最近正在折腾用树莓派架设Resilio Sync服务来同步自己的数据，然而晚上11点左右，发现架设在树莓派上的WEB服务挂了，然后再转过头看房间角落里的树莓派，竟然关机了~！顿时觉得有点惊诧，拔掉电源重新插，灯还亮，说明树莓派硬件还没挂，然后发现ssh无法登录，PING树莓派的IP没有反应。有点慌了，到群里求助，问树莓派是不是挂了？大家有建议重做SD卡，也有说只要树莓派的LED灯还在闪烁，树莓派就问题不大。然后无奈，我只能使用最原始的方法，接HDMI显示器、USB键盘，然后发现树莓派可以进入系统，顿时安心了，但是好像还没完，开始了一系列的折腾。 紧急模式进入系统后，有一些提示，很有意思 123456'Welcome to emergency mode! After logging in, type \"journalctl -xb\" to viewsystem logs, \"systemctl reboot\" to reboot, \"systemctl default\" to try againto boot into default mode.'sulogin: root account is locked, starting shellroot@raspberrypi:~# 看来树莓派是遇到什么问题了，自行进入了紧急模式，系统有几个建议 journalctl -xb 查看日志 systemctl reboot 重启系统 systemctl default 按照默认模式重启系统 使用第一条建议的时候，发现树莓派在开机启动1-2秒内就遇到了错误，关停了所有的服务，准备进入紧急模式。 使用建议2的时候，系统可以重启，但是每次重启后，都进行了一个1分30秒左右的fsck检查，而且检查完了，同样进入紧急模式，没有任何改变. 使用建议3的时候，直接出提示Hangup，同样没有解决。 无奈之下，我就病急乱投医，使用fdisk -l命令，并没有发现什么不妥。但是在使用df -l查看挂载分区和磁盘的时候，发现了奇怪的问题：系统几乎挂载了所有的目录，但是唯独缺少重要的一行 1tmpfs 88280 0 88280 0% /run/user/1000 这个目录，是root用户的根目录，如果这个目录没有挂载的话，说明root用户应该出现问题了。 果然，我发现cd root进入root目录之后，目录里和记忆中不太一样，但是其他/usr、/var目录下并没有发现什么不妥。 莫名其妙的，我使用startx，竟然还能进入GUI环境，但是进入之后，会遇到一个什么GID的错误，我想应该和root目录没加载有关。 试错过程到了这个地步，我心里稍微踏实了一些，毕竟树莓派应该没有什么问题，只是估计系统盘出了问题。 网上根据上面的错误提示，终于遇到了和我一样错误的人，他的帖子见这里。 他提供了两个办法： 办法一（个人失败） 在 emergency mode 下 用root账户登录 执行 umount /dev/mmcblk0p2 命令 再执行 e2fsck -f -y -v -C 0 /dev/mmcblk0p2 命令 reboot 重启 办法二（个人成功） 把树莓派的SD卡拔出来，放到读卡器里面，插到另外一台 LINUX 电脑上，假设树莓派SD是 /dev/sdb sudo umount /dev/sdb1 sudo umount /dev/sdb2 sudo fsck /dev/sdb1 sudo fsck /dev/sdb2 我使用这个办法成功的，但过程中遇到了一个小错误 12345678$ sudo fsck /dev/sdb1dosfsck 3.0.16, 01 Mar 2013, FAT32, LFN0x41: Dirty bit is set. Fs was not properly unmounted and some data may be corrupt.1) Remove dirty bit2) No action? 1 #我选择了选项1，移除脏数据Leaving file system unchanged./dev/sdb1: 3 files, 33/130812 clusters 意思就是分区有错误，定位到了脏脏的数据，你想移除它还是不动它？我选1，删掉他，但是结果却是啥都没有变化。然后继续找解决办法，发现也许这是fsck命令的一个BUG，需要添加参数 -a，来执行 sudo fsck -a /dev/sdb1 ，顺利搞定 峰回路转以为已经搞定了，TF卡放回树莓派中，启动，依然回到了最开始的状态，又进入了紧急模式，心里顿时万千只草泥马呼啸而过！ 此时想想，这次的问题，应该是TF卡出了一些错误，导致树莓派认为系统 “无药可救” 了，所以紧急把自己的服务，能关的都关了，关机了事！ 在之前寻找解决办法的过程中，无意中好像看到了一个人提到关于硬盘UUID加载的导致出现了同样的错误，好吧，抱着试试看的心态，我把之前在 /etc/fstab 中那句按照硬盘UUID加载硬盘的命令删掉了，然后。。。重启竟然正常了！ 想说的话经过2个小时的折腾，我发现遇到问题还是应该先求助于网络，QQ群虽然是高手如云，但是高手不一定在啊，就算群里有2000人，谁能保证这2000人中有遇到过同样问题的呢？就算遇到了，人家也不一定在线啊，所以，还是GOOGLE靠谱。 其实，这个错误，我最后也无法确定为什么启动加载UUID会影响到系统的启动，不过其中有一个细节，就是在我试图执行 sudo umount /mnt/hd250g 的时候，系统说该分区忙，并且给出了3个已经挂载的位置，其中一个位置是 /media/PI/A88ER89D90--8E8R90A-8D8F799-8D88F/ ，另外两个是正常挂载的位置，那个长长的目录，引起了我的兴趣。我进去看了下，硬盘在这个目录下竟然有文件，但是应该正确挂载在 /mnt/hd250g 下的却有错误。 如果遇到挂载盘busy的情况，使用sudo umount -lf /dev/sdb1，或者把 -l -f 分拆到两句命令里执行也可以。 这个真心让我想不通，那个 /media/PI 的位置，我查了自己以往的记录，应该只有在 samba 服务配置文件中提到过，那是samba服务 home 用户的一个目录，但是为什么会突然挂载到这个位置？还是因为挂载到 /mnt/hd250g 失败之后，被挂载到了这个位置？我一直没有想明白。 好了，先这样吧，打算换个比较好的 TF 卡，重新做一次系统看看，因为BT SYCN最近实在是让我火大，如果重新刷系统后，还不能解决这个问题，只能考虑从BT SYNC迁移到SYNCTHING了。 参考文章 fsck.vfat fails to remove dirty bit","link":"/2016/07/14/how_to_solve_the_emergency_mode_of_raspberry_pi/"},{"title":"如何让SHADOWSOCKS在MAC上自动启动","text":"文章更新 20160724-初次成文 为什么会有这篇文章因为发现每次使用shadowsocks的客户端的时候，都需要自己启动，系统不会自动启动。后来网上找了找，原来是使用launchagent这个目录来加载自动启动，就像lantern和php自动启动那种效果。 什么是LaunchD如果在mac上登录了自己的账户，使用iterm登录，利用 cd ~\\LaunchAgnents，然后 ls，你会看到一些xml文件，比如我的系统上，是这样的 以lantern为例，我来看看这里都有什么内容： 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE plist PUBLIC \"-//Apple Computer//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt; &lt;plist version=\"1.0\"&gt; &lt;dict&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;org.getlantern&lt;/string&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;/Applications/Lantern.app/Contents/MacOS/lantern&lt;/string&gt; &lt;string&gt;-startup&lt;/string&gt; &lt;/array&gt; &lt;key&gt;RunAtLoad&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt;1 &lt;/plist&gt; 很简单明白吧，就是自动加载 /Applications/Lantern.app/Contents/MacOS/lantern 这个位置上的lantern程序，并且将其设置为 RunAtLoad 模式。 如果大家想学习更多关于Lanunch的语法，详细的参数配置可以参考 launchd.info 这个教程。我仿照这个格式，写了一个自己启动 shadowsocks的文件。 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE plist PUBLIC \"-//Apple Computer//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt; &lt;plist version=\"1.0\"&gt; &lt;dict&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;shadowsocks&lt;/string&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;/Applications/ShadowsocksX.app/Contents/MacOS/ShadowsocksX&lt;/string&gt; &lt;string&gt;-startup&lt;/string&gt; &lt;/array&gt; &lt;key&gt;RunAtLoad&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; &lt;/plist&gt; 将这个配置文件保存为 ~/Library/LaunchAgents/shadowsocks.plist， 然后使用下面命令加载： 1launchctl load ~/Library/LaunchAgents/shadowsocks.plist 由于配置了 RunAtLoad 参数，所以加载后 Shadowsocks 就会运行。 如果想更方便一些，可以在配置文件里指定的 shadowsocks.stdout 和 shadowsocks.stderr 里看到运行日志。 如果想要停止服务，只需要 ‘unload’ 这个配置即可： 1launchctl unload ~/Library/LaunchAgents/shadowsocks.plist 参考文章 Mac OS 中使用 launchd 自动启动 Shadowsocks","link":"/2016/07/24/how_to_setup_automatic_load_for_shadowsocks_on_mac/"},{"title":"使用SYNCTHING在树莓派上替代BT SYNC","text":"文章更新 20160722-初次成文 20160724-因为BTSYNC可能找到了错误原因，停止使用SYNCTHING 为什么会有这篇文章好久没更新文章了，主要是之前工作上的事情太忙了，要翻译，又要写稿子，忙的时候都没有空去群里看大家聊天了。不过我又回来了，发现之前的命令开始模糊了，果然什么事情要熟练，都需要不断的反复练习和记忆，直到那些技能成为你身体的一部分。 好了，不废话了。BT SYCN在我的树莓派上一直不是很稳定，主要是外接硬盘一直不稳定排除了硬盘盒和硬盘的问题，目前也找不到比较好的解决办法，又懒得重新装一次树莓派系统和应用，所以先用SYNCTHING来感受一下是否稳定。 最近发现因为SAMBA服务可能和BTSYNC在某个地方冲突了，导致BTSYNC运行又正常了。 安装和下载12wget https://github.com/syncthing/syncthing/releases/download/v0.14.0/syncthing-linux-arm-v0.14.0.tar.gztar -zxvf syncthing-linux-arm-v0.14.0.tar.gz /usr/local/sbin/ 然后 运行就一句话 1/usr/local/sbin/syncthing 然后看到一堆输出信息，告知syncthing在监听什么端口，NAT信息之类的。 使用 CTRL+C 来停止运行。 编辑配置文件先来看看他的配置文件， 1sudo vim /home/pi/.config/syncthing/config.xml 1234&lt;gui enabled=\"true\" tls=\"false\"&gt; &lt;address&gt;0.0.0.0:8384&lt;/address&gt; &lt;apikey&gt;VbsKT2fCELYldTI74Tk4BKCbJP8Frlij&lt;/apikey&gt;&lt;/gui&gt; 这里需要改的地方，主要是address，修改为 0.0.0.0:8384，这样就可以外网访问了，并且如果有https连接，需要把tls改为true。 如果是外网访问，就可以通过 http://your_pi_address:8384 来访问了，不过记得在防火墙上做一个 TCP 8384 的端口转发，否则也是打不开 GUI 界面的。 可以访问了之后，第一次运行，会让你设置用户名和密码，不要设置 admin 这样太好猜的用户名，否则也不安全。 设置syncthing自动启动在 /etc/init.d 目录下建立启动文件 1sudo vim /etc/init.d/syncthing 脚本内容如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#!/bin/sh### BEGIN INIT INFO# Provides: Syncthing# Required-Start: $local_fs $remote_fs $network# Required-Stop: $local_fs $remote_fs $network# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: Syncthing# Description: Syncthing is for backups### END INIT INFO # Documentation available at# http://refspecs.linuxfoundation.org/LSB_3.1.0/LSB-Core-generic/LSB-Core-generic/iniscrptfunc.html# Debian provides some extra functions though. /lib/lsb/init-functions DAEMON_NAME=\"syncthing\"DAEMON_USER=piDAEMON_PATH=\"/usr/local/sbin/syncthing-linux-arm-v0.14.0/syncthing\"DAEMON_OPTS=\"\"DAEMON_PWD=\"${PWD}\"DAEMON_DESC=$(get_lsb_header_val $0 \"Short-Description\")DAEMON_PID=\"/var/run/${DAEMON_NAME}.pid\"DAEMON_NICE=0DAEMON_LOG='/var/log/syncthing' [ -r \"/etc/default/${DAEMON_NAME}\" ] &amp;&amp; . \"/etc/default/${DAEMON_NAME}\" do_start() { local result pidofproc -p \"${DAEMON_PID}\" \"${DAEMON_PATH}\" &gt; /dev/null if [ $? -eq 0 ]; then log_warning_msg \"${DAEMON_NAME} is already started\" result=0 else log_daemon_msg \"Starting ${DAEMON_DESC}\" \"${DAEMON_NAME}\" touch \"${DAEMON_LOG}\" chown $DAEMON_USER \"${DAEMON_LOG}\" chmod u+rw \"${DAEMON_LOG}\" if [ -z \"${DAEMON_USER}\" ]; then start-stop-daemon --start --quiet --oknodo --background \\ --nicelevel $DAEMON_NICE \\ --chdir \"${DAEMON_PWD}\" \\ --pidfile \"${DAEMON_PID}\" --make-pidfile \\ --exec \"${DAEMON_PATH}\" -- $DAEMON_OPTS result=$? else start-stop-daemon --start --quiet --oknodo --background \\ --nicelevel $DAEMON_NICE \\ --chdir \"${DAEMON_PWD}\" \\ --pidfile \"${DAEMON_PID}\" --make-pidfile \\ --chuid \"${DAEMON_USER}\" \\ --exec \"${DAEMON_PATH}\" -- $DAEMON_OPTS result=$? fi log_end_msg $result fi return $result} do_stop() { local result pidofproc -p \"${DAEMON_PID}\" \"${DAEMON_PATH}\" &gt; /dev/null if [ $? -ne 0 ]; then log_warning_msg \"${DAEMON_NAME} is not started\" result=0 else log_daemon_msg \"Stopping ${DAEMON_DESC}\" \"${DAEMON_NAME}\" killproc -p \"${DAEMON_PID}\" \"${DAEMON_PATH}\" result=$? log_end_msg $result rm \"${DAEMON_PID}\" fi return $result} do_restart() { local result do_stop result=$? if [ $result = 0 ]; then do_start result=$? fi return $result} do_status() { local result status_of_proc -p \"${DAEMON_PID}\" \"${DAEMON_PATH}\" \"${DAEMON_NAME}\" result=$? return $result} do_usage() { echo $\"Usage: $0 {start | stop | restart | status}\" exit 1} case \"$1\" instart) do_start; exit $? ;;stop) do_stop; exit $? ;;restart) do_restart; exit $? ;;status) do_status; exit $? ;;*) do_usage; exit 1 ;;esac 然后是两句 12sudo chmod +x /etc/init.d/syncthing #加可执行权限sudo update-rc.d syncthing defaults #添加默认启动 如何要取消，一种是图形化的管理界面（略），另外一种则是 1sudo update-rc.d syncthing remove 然后你就有了4句命令 1234sudo service syncthing startsudo service syncthing stopsudo service syncthing restartsudo service syncthing status 一些尝试已经共享的文件夹，即便删掉了共享，文件也依然会存在，我觉得这个功能很贴心，毕竟谁也不想自己辛辛苦苦共享的文件夹因为对方或者自己删除了共享，就真没了呢。不过BTSYNC被删掉或者共享失败的文件，会存在类型 btsync/iphone/.sync 这样的隐藏目录下面，不知道SYNCTHING有没有这个机制。 参考文章 Install Syncthing Raspberry Pi – BitTorrent Sync Alternative","link":"/2016/07/22/use_syncthing_on_raspberry_pi_to_replace_btsync/"},{"title":"关于cron和crontab的那些事","text":"文章更新 20160725-初次成文 为什么会有这篇文章因为目前用的raspbian比较多，其次多的就是centos了，都需要涉及到自动任务的环节，但是有一些自己认识上模糊的地方，还需要好好的系统明确一下。所以才有了这个帖子。 什么是cron和crontab不说废话了，大家可以通过 man cron 和 man crontab 来查看系统文档，但是简单的说，可以这样理解，cron是系统执行循环任务的任务名称，crontab是具体的文件。 但是可以执行的，在树莓派中有3个地方，分别是 /etc/cron.d 目录、 /etc/crontab 文件以及 /var/spool/cron/crontabs 目录下以不同用户账号对应的目录等3个地方。 关于这3个地方执行的区别，可以这样说 /etc/cron.d —&gt; 程序包使用，默认不带环境变量（下文详解） /etc/crontab —&gt; 是系统cron的crontab，这样说不知道能不能理解？并且可以在里面指定具体执行的用户 /var/spool/cron/crontabs —&gt; 是具体用户的crontab 最好不要手动去修改 crontab文件，而使用 crontab -e 命令。 关于上面的具体，从man查询中，还有一个比较重要 cron also reads /etc/crontab, which is in a slightly different format (see crontab(5)). Additionally, cronreads the files in /etc/cron.d: it treats the files in /etc/cron.d as in the same way as the /etc/crontabfile (they follow the special format of that file, i.e. they include the user field). However, they areindependent of /etc/crontab: they do not, for example, inherit environment variable settings from it. Theintended purpose of this feature is to allow packages that require finer control of their scheduling thanthe /etc/cron.{daily,weekly,monthly} directories to add a crontab file to /etc/cron.d. 翻译过来就是 cron也会读取 /etc/crontab 的内容来执行，虽然格式上稍微有一些不同（我觉得就是多了用户名那一项）。除此之外，cron也会读取 /etc/cron.d 目录下的文件，并将其视做与 /etc/crontab 相对的方式对待。尽管如此，/etc/cron.d 与 /etc/crontab 相互独立，此话的意思就是，/etc/init.d 中的人物，不会提供环境变量，这样做的目的，是给予 /etc/init.d 目录下的程序包更好更精确的控制权。 这点区别很重要，如果你想查看当前用户下的环境变量都有哪些，使用 env 命令，然后如果你发现你的脚本在 /etc/crontab 下可以执行，但是到了 /etc/init.d/下就不行了，一般就是环境变量的问题。登录那个账户，然后把环境变量直接加到你的脚本里，一般就可以解决问题。 Cron涉及到的文件这里以REHL系统为例，其他系统大同小异，但是也会有细微差别，我在树莓派上的具体文件和区别标注在括号里。 /usr/sbin/crond - 核心可执行文件（在树莓派下是cron） /etc/crontab - 系统cron的表，指定具体了任务的地方（树莓派相同） /usr/bin/crontab - 用来用来建立和管理cron表的入口可执行文件（树莓派相同）。 /var/spool/cron/* - 不同用户创建的不同的cron任务（树莓派相同）。 /etc/cron.d/* - 不同程序安装包创建的cron任务（树莓派相同）。 /etc/cron.allow - 允许访问的记录 /etc/cron.deny - 禁止访问的记录 /etc/cron.hourly/ - 这里的脚本，每个小时会执行一次。 /etc/cron.daily/ - 这里的脚本，每天会执行一次。 /etc/cron.weekly/ - 这里的脚本，每周会执行一次。 /etc/cron.monthly/ - 这里的脚本，每个月会执行一次。 Crontab的环境变量cron会从用户登录时的HOME目录提取用户的默认环境变量加上默认的shell(/usr/bin/sh)。如果这个用户默认没shell，就没shell。 具体定义是： 1234- HOME=&lt;Users Home Dir&gt;- LOGNAME=&lt;Users Login ID&gt;- PATH=/usr/bin:/usr/sbin:.- SHELL=/usr/bin/sh cron使用图解格式1* * * * * &lt;Command to execute&gt; 不废话，直接上图 编辑crontab12345crontab -e 或者crontab -u foolman -e #root用户通过-u参数可以指定编辑具体用户的crontab文件或者crontab -u foolman foolman_cron.txt #直接导入任务 删除任务123crontab -r #root用户或者其他用户都可以或者crontab -u foolman -r #root用户删除某个用户的任务 列出任务123crontab -l #root用户或者其他用户都可以或者crontab -u foolman -l #root可以列出某用户的任务 启动或者停止cron服务1234service crond startservice crond stopservice crond restartservice crond status 上面是REHL系统的，如果是树莓派，因为没有crond，只有cron，所以命令要变成 1234service cron startservice cron stopservice cron restartservice cron status 关闭邮件提示默认情况下，如果cron遇到错误了，就会给你发一封邮件，默认保存在 /var/mail 下对应的用户名文件中。但是你可以通过在cron任务的默认，加上一句 1&gt;/dev/null 2&gt;&amp;1 来取消邮件的发送。 生成cron日志110 10 * * * rm /home/foolman/tmp/* &gt; /home/foolman/cronlogs/clean_tmp_dir.log 参考文章 Linux Start Restart and Stop The Cron or Crond Service Debian or Ubuntu Linux runlevel configuration tool to start service /etc/crontab vs /etc/cron.d vs /var/spool/cron/crontabs/ Working with “crontab” Scheduler","link":"/2016/07/25/what_you_need_to_know_about_cron_and_crontab/"},{"title":"使用U盘为MBP安装系统","text":"文章更新 20160803-初次成文 20170728-采用了IPLAYSOFT的方法，比较好用 为什么会有这篇文章电脑永久了，总会有各种各样的问题，所以学会重装系统，还是很必要的。这篇帖子的操作系统是EI CAPITAN。 下载系统下载系统一般需要从APP STORE里下载，而且必须是你购买过的，所以，就像我之前买过EI CAPITAN和MAC OS SIERRA，更早的系统YOSIMATE我就下载不到了。 准备U盘打开 “应用程序 → 实用工具 → 磁盘工具”，将U盘「抹掉」(格式化) 成「Mac OS X 扩展（日志式）」格式、GUID 分区图，并将U盘命名为「Capitan」。(注意：这个盘符名称将会与后面的命令一一对应，如果你改了这盘符的名字，必须保证后面的命令里的名称也要一致。) 我这个截图上没有方案这个选择，因为这个U盘已经是安装盘了，为了写帖子截图又插上了而已。 还可以使用命令行方法也抹除U盘（如果你使用的是YOSIMITE）。 1diskutil partitionDisk /dev/disk2 1 GPT JHFS+ iPlaySoft 0b 我想命令没啥可说的，主要是最后一个0b，表示该分区使用全部容量。 方法1刻录打开 “应用程序→实用工具→终端”，将下面的一段命令复制并粘贴进去： 1sudo /Applications/Install\\ OS\\ X\\ El\\ Capitan.app/Contents/Resources/createinstallmedia --volume /Volumes/Capitan --applicationpath /Applications/Install\\ OS\\ X\\ El\\ Capitan.app --nointeraction 下载系统盘并刻录下载好说，找一个Yosimite的下载链接，我找的BT链接，比较容易，因为现在APP STORE里面已经下载不到YOSIMITE的系统镜像文件了。另外，下载的是DMG格式的文件，下载之后，双击，会自动挂载到虚拟分区，具体位置？看磁盘工具就可以了，我这里显示的挂载点是 /Volumes/OS X Base System ，网上一般是让下载到 应用 的位置，然后通过一条命令进行安装盘的制作，我参考的是 iPlaySoft 的教程，地址在这里。 回车并执行该命令这时会提示让你输入管理员密码，便会开始制作过程了： 方法21sudo /Applications/Install\\ OS\\ X\\ Yosemite.app/Contents/Resources/createinstallmedia --volume /Volumes/iPlaySoft --applicationpath /Applications/Install\\ OS\\ X\\ Yosemite.app --nointeraction 上面是英文版的命令，如果是中文版的，需要把里面的 Install 修改成 安装 两个字。并且其中的U盘盘符，如果你的U盘有不同的名字，也要相应修改。 好了，我的命令是 1sudo /Volumes/OS\\ X\\ Base\\ System/Install\\ OS\\ X\\ Yosemite.app/Contents/Resources/createinstallmedia --volume /Volumes/iPlaySoft --applicationpath /Volumes/OS\\ X\\ Base\\ System/Install\\ OS\\ X\\ Yosemite.app --nointeraction 但是这个方法，我无论如何也不能正确的执行，一直说/Volumes/OS\\ X\\ Base\\ System/Install\\ OS\\ X\\ Yosemite.app appear not be a valid OSX installer application. 后来我甚至下载了 DiskMaer X5，但是问题也一样。 我发现如果使用磁盘工具，是无法验证这个安装程序的。网上有人说这是因为在高版本的系统上，无法验证低版本的安装程序，这是苹果出于让用户优先使用最新系统的考虑，也就是无法降级。 这个事情，困扰了我几个小时，终于找到了另外一个办法，成功搞定。 使用磁盘工具刻录ISO或CDR文件在MAC系统里打开 磁盘工具， 把DMG格式转换成CDR格式。 然后在 命令行(Terimal) 下使用命令 1dd if=/Users/wangyi/Downloads/yosemite.cdr of=/dev/rdisk2 bs=32m 进行文件的烧录，但是遇到错误，提示 resource busy。 然后我拔掉U盘再插上，问题依旧。 网上继续搜索，找到了这个办法，地址见这里 即使用命令 df -h 看一下U盘的卷标是哪个，我这里是 /dev/disk2 继续运行命令 1sudo umount /dev/disk2s2 提示不行，继续使用 1sudo diskutil unmount /dev/disk2s2 搞定。注意看两条命令的区别，尤其是umount和unmount两个关键词的区别。 然后，这个时候，再次运行 df -h，就已经看不到这个U盘了，但是其实还在，只是他成为虚拟的一个盘了，使用cat /dev还是可以看到的。 此时，就可以使用dd命令了， 1dd if=/Users/wangyi/Downloads/yosemite.cdr of=/dev/rdisk2 bs=32m 注意，这里使用的rdisk2，而不是disk2s，前面多了一个r，并且后面少了2s，一定要这样写，否则会出错。 这里的参数bs=32m是每次从CDR或者ISO文件一次性读取和写入的缓存容量，如果太小了，时间会变长。 看一下我的结果吧，8g的文件，其实使用16g的盘刻录出来的，因此CDR文件写入的时候，也是按照16G文件的大小来写入的。 123451+1 records in451+1 records out15149785088 bytes transferred in 1599.983077 secs (9468716 bytes/sec) 16g的文件，25分钟左右，烧录的过程中，可以看到U盘的灯在闪烁，这个可以用来帮你判断是否烧录完成。 安装系统备份好你的东西，准备重启，关机。 按住CTRL+R，再按电源键。然后就会让你选择从哪个盘启动了，GAME OVER。 参考文章 Disk Management From the Command-Line, Part 2 简单制作 macOS Sierra 正式版U盘USB启动安装盘方法教程","link":"/2016/08/03/use_udisk_to_burn_and_install_mac_os/"},{"title":"Homebrew的基本用法","text":"文章更新 20160810-初次成文 20170727-丰富内容 为什么会有这篇文章之前因为MBP出了点问题，拿去苹果售后维修，本本回来了硬盘里的内容全部丢失，顺便记录一下Homebrew的用法。 Homebrew介绍Homebrew是Mac OSX上的软件包管理工具，类似ubuntu系统下的apt-get的功能，或者RHEL/HEL下的yum。 安装Homebrew1/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 这条命令可以在homebrew项目的官方网站的首页看到。 安装过程没啥可说的，唯一耗时比较长的就是下载和安装xcode command line tools的地方。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114==&gt; This script will install:/usr/local/bin/brew/usr/local/share/doc/homebrew/usr/local/share/man/man1/brew.1/usr/local/share/zsh/site-functions/_brew/usr/local/etc/bash_completion.d/brew/usr/local/Homebrew==&gt; The following new directories will be created:/usr/local/Cellar/usr/local/Homebrew/usr/local/Frameworks/usr/local/bin/usr/local/etc/usr/local/include/usr/local/lib/usr/local/opt/usr/local/sbin/usr/local/share/usr/local/share/zsh/usr/local/share/zsh/site-functions/usr/local/var==&gt; /usr/bin/sudo /bin/mkdir -p /usr/local/Cellar /usr/local/Homebrew /usr/local/Frameworks /usr/local/bin /usr/local/etc /usr/local/include /usr/local/lib /usr/local/opt /usr/local/sbin /usr/local/share /usr/local/share/zsh /usr/local/share/zsh/site-functions /usr/local/varPassword: 输入一次密码==&gt; /usr/bin/sudo /bin/chmod g+rwx /usr/local/Cellar /usr/local/Homebrew /usr/local/Frameworks /usr/local/bin /usr/local/etc /usr/local/include /usr/local/lib /usr/local/opt /usr/local/sbin /usr/local/share /usr/local/share/zsh /usr/local/share/zsh/site-functions /usr/local/var==&gt; /usr/bin/sudo /bin/chmod 755 /usr/local/share/zsh /usr/local/share/zsh/site-functions==&gt; /usr/bin/sudo /usr/sbin/chown wangyi /usr/local/Cellar /usr/local/Homebrew /usr/local/Frameworks /usr/local/bin /usr/local/etc /usr/local/include /usr/local/lib /usr/local/opt /usr/local/sbin /usr/local/share /usr/local/share/zsh /usr/local/share/zsh/site-functions /usr/local/var==&gt; /usr/bin/sudo /usr/bin/chgrp admin /usr/local/Cellar /usr/local/Homebrew /usr/local/Frameworks /usr/local/bin /usr/local/etc /usr/local/include /usr/local/lib /usr/local/opt /usr/local/sbin /usr/local/share /usr/local/share/zsh /usr/local/share/zsh/site-functions /usr/local/var==&gt; /usr/bin/sudo /bin/mkdir -p /Users/wangyi/Library/Caches/Homebrew==&gt; /usr/bin/sudo /bin/chmod g+rwx /Users/wangyi/Library/Caches/Homebrew==&gt; /usr/bin/sudo /usr/sbin/chown wangyi /Users/wangyi/Library/Caches/Homebrew==&gt; /usr/bin/sudo /bin/mkdir -p /Library/Caches/Homebrew==&gt; /usr/bin/sudo /bin/chmod g+rwx /Library/Caches/Homebrew==&gt; /usr/bin/sudo /usr/sbin/chown wangyi /Library/Caches/Homebrew==&gt; Downloading and installing Homebrew...remote: Counting objects: 6633, done.remote: Compressing objects: 100% (4011/4011), done.remote: Total 6633 (delta 3892), reused 4345 (delta 2414), pack-reused 0Receiving objects: 100% (6633/6633), 3.57 MiB | 59.00 KiB/s, done.Resolving deltas: 100% (3892/3892), done.From https://github.com/Homebrew/brew * [new branch] master -&gt; origin/master * [new tag] 0.1 -&gt; 0.1 * [new tag] 0.2 -&gt; 0.2 * [new tag] 0.3 -&gt; 0.3 * [new tag] 0.4 -&gt; 0.4 * [new tag] 0.5 -&gt; 0.5 * [new tag] 0.6 -&gt; 0.6 * [new tag] 0.7 -&gt; 0.7 * [new tag] 0.7.1 -&gt; 0.7.1 * [new tag] 0.8 -&gt; 0.8 * [new tag] 0.8.1 -&gt; 0.8.1 * [new tag] 0.9 -&gt; 0.9 * [new tag] 0.9.1 -&gt; 0.9.1 * [new tag] 0.9.2 -&gt; 0.9.2 * [new tag] 0.9.3 -&gt; 0.9.3 * [new tag] 0.9.4 -&gt; 0.9.4 * [new tag] 0.9.5 -&gt; 0.9.5 * [new tag] 0.9.8 -&gt; 0.9.8 * [new tag] 0.9.9 -&gt; 0.9.9 * [new tag] 1.0.0 -&gt; 1.0.0 * [new tag] 1.0.1 -&gt; 1.0.1 * [new tag] 1.0.2 -&gt; 1.0.2 * [new tag] 1.0.3 -&gt; 1.0.3 * [new tag] 1.0.4 -&gt; 1.0.4 * [new tag] 1.0.5 -&gt; 1.0.5 * [new tag] 1.0.6 -&gt; 1.0.6 * [new tag] 1.0.7 -&gt; 1.0.7 * [new tag] 1.0.8 -&gt; 1.0.8 * [new tag] 1.0.9 -&gt; 1.0.9 * [new tag] 1.1.0 -&gt; 1.1.0 * [new tag] 1.1.1 -&gt; 1.1.1 * [new tag] 1.1.10 -&gt; 1.1.10 * [new tag] 1.1.11 -&gt; 1.1.11 * [new tag] 1.1.12 -&gt; 1.1.12 * [new tag] 1.1.13 -&gt; 1.1.13 * [new tag] 1.1.2 -&gt; 1.1.2 * [new tag] 1.1.3 -&gt; 1.1.3 * [new tag] 1.1.4 -&gt; 1.1.4 * [new tag] 1.1.5 -&gt; 1.1.5 * [new tag] 1.1.6 -&gt; 1.1.6 * [new tag] 1.1.7 -&gt; 1.1.7 * [new tag] 1.1.8 -&gt; 1.1.8 * [new tag] 1.1.9 -&gt; 1.1.9 * [new tag] 1.2.0 -&gt; 1.2.0 * [new tag] 1.2.1 -&gt; 1.2.1 * [new tag] 1.2.2 -&gt; 1.2.2 * [new tag] 1.2.3 -&gt; 1.2.3 * [new tag] 1.2.4 -&gt; 1.2.4HEAD is now at 24f4797 Merge pull request #2929 from woodruffw/master==&gt; Tapping homebrew/coreCloning into '/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core'...remote: Counting objects: 4489, done.remote: Compressing objects: 100% (4280/4280), done.remote: Total 4489 (delta 36), reused 468 (delta 14), pack-reused 0Receiving objects: 100% (4489/4489), 3.56 MiB | 153.00 KiB/s, done.Resolving deltas: 100% (36/36), done.Tapped 4279 formulae (4,534 files, 11.1MB)==&gt; Cleaning up /Library/Caches/Homebrew...==&gt; Migrating /Library/Caches/Homebrew to /Users/wangyi/Library/Caches/Homebrew...==&gt; Deleting /Library/Caches/Homebrew...Already up-to-date.Warning: /usr/local/bin is not in your PATH.==&gt; Installation successful!==&gt; Homebrew has enabled anonymous aggregate user behaviour analytics.Read the analytics documentation (and how to opt-out) here: http://docs.brew.sh/Analytics.html==&gt; Next steps:- Run `brew help` to get started- Further documentation: http://docs.brew.sh 这个过程大概用了5-6分钟吧，提前安装xcode可以缩短上面的过程。 检查是否安装正确为了系统安全升级，先要让Homebrew检查系统是否可以安装或者更新软件： 1brew doctor 添加homebrew的路径到系统PAHT中。如果使用 echo $PATH 发现这个路径已经在系统路径中，则无需添加。 1export PATH=\"/usr/local/bin:$PATH\" 2017年7月27日更新我的环境是MAC OS 10.11(EI CAPITAN)和XCODE，最近发现安装后通过 brew doctor 命令检查的时候，Homebrew 会显示下面这样一个警告错误 12345678Please note that these warnings are just used to help the Homebrew maintainerswith debugging if you file an issue. If everything you use Homebrew for isworking fine: please don't worry and just ignore them. Thanks!Warning: You have Xcode 8 installed without the CLT;this causes certain builds to fail on OS X El Capitan (10.11).Please install the CLT via: sudo xcode-select --install 意思是缺少开发人员命令行工具，需要单独安装，网上答案说因为xcode 8已经默认不在低于10.12版本的mac os系统上安装这个工具了，需要手动安装，好在命令也不麻烦 1sudo xcode-select --install Homebrew 升级和更新1brew update &amp;&amp; brew upgrade PS:关于sudo的用户权限问题，如果你发现上面命令不行，而强制使用 sudo brew update 的话，会遇到一个错误： 1234Error: Cowardly refusing to 'sudo brew update'You can use brew with sudo, but only if the brew executable is owned by root.However, this is both not recommended and completely unsupported so do so atyour own risk. 意思就是Homebrew绝对不推荐使用 sudo brew update 命令对系统进行强制更新，虽然可以这样使用，但是也最好在确定需要执行的操作属于root用户的情况下才可以这样做，Homebrew不推荐也不支持用户使用sudo来进行homebrew的相关操作。 就算你使用了 sudo -s 切换到 root 用户下，重新执行也不行。 这是因为Homebrew在安装的时候不隶属于root用户，所以，需要执行下面的命令 1sudo chown $(whoami) /usr/local/bin/brew 将Homebrew相关文件的所有权，重新划分到当前用户下，这样Homebrew的主人就变更为了当前用户，再次执行相关的homebrew操作的时候，不需要使用sudo命令。 通过执行 brew doctor，可以诊断系统Homebrew冲突，如果结果显示 1Your system is ready to brew. 则表明Homebrew已经准备就绪，可以进行升级操作了。 说个题外话，在很早的时候我使用 brew doctor 诊断系统冲突，发现有很多Node目录下的文件，这是因为node.js在当时，我并不是使用homebrew进行的安装。因此有很多文件，没有受到Homebrew的监控，而被安装到了不应该的位置上，这里开了个新帖子，专门讨论如何在mac下完整卸载Node.js，并重新使用Homebrew进行安装。 如果上面的命令结果中有warning，需要先分析下问题是什么，然后针对性的去解决之后，再进行下一步。 如何安装软件12brew install git #安装gitbrew install wget #安装wget 如何卸载软件1brew uninstall wget 如何查询软件有时候，你不知道你安装的软件的名字， 那么你需要先搜索下, 查到包的名字。 比如我要安装 1brew search /wge*/ /wge*/是个正则表达式，需要包含在/中 其他brew命令 brew list #列出已安装的软件 brew update #更新brew brew home #用浏览器打开brew的官方网站 brew info #显示软件信息 brew deps #显示包依赖 Homebrew中提示的keg-only是什么意思首先，brew 本身是酿造、酿酒的意思，会用这个字的原因是 Homebrew 的安装方式为下载源代码到本地回来做编译，由于是在自己电脑做本地编译，所以这个工具叫做 brew at Home，自家酿酒。 酿酒需要有配方(formula)，当你需要安装套件时，流程就是使用brew命令去根据配方 formula ，酿造出一桶（keg）酒来。所以 keg 指的是整个编译完成的套件资料夹。 再来，放置套件的位置在 /usr/local/Cellar，Cellar就是地窖，一桶一桶酿好的酒当然要存放在地窖里面了！所以编译完成的套件资料夹 keg 预设目录在 /usr/local/Cellar 。 最后回到「keg-only」这个词，字面上意思现在就很清楚，表示这个套件只会存放在桶里，不会跑出桶外面；实际上的行为是 brew 不会帮你做 symlink 到 /usr/local ，避免你的原生系统内还有一套名称相同的套件，从而引起冲突，所以如果遇到安装或者更新套件后提示某个套件是 keg-only ，那么你就需要自己去做symlink的事情了。 其实这就引出了Homebrew安装套件的两种不同方式了，继续往下看 Homebrew安装的两种方式Homebrew安装软件分为两种情况： 系统没有自带的 这个没什么好说的，因为如果系统没有带，我们安装完相应的软件之后就自动的将编译好的二进制文件软链接到PATH中，这样才会生效。 系统自带的 如果系统自带的有这个软件，那么问题就不好办了，是直接覆盖呢，还是应该给用户一些选择？本着上面说过的原则，尽量少的影响原来的目录树，那么它在安装完二进制文件之后并没有做建软链的那一步操作，这就是所谓的keg-only的意思了。 那么，如果我要更新wget，而OS X发行时本就是带着wget的，应该怎么办呢？当然作者已经替我们想到了这一点， 1brew link wget --force 这样，它就会把需要的二进制链接到PATH中，要注意这时这些路径中是存在相应的二进制文件的，正是homebrew不敢确定是不是要直接帮我们做这些操作，才给我们提供了这个命令。 如何批量建立symlink那么如果你之前已经安装了不少软件了，发现有好几个没有建软链，难道要手工的一个一个执行？当然不用，可以参考下面的脚本 12345ls -1 /usr/local/Library/LinkedKegs | while read line; do echo $LINE brew unlink $LINE brew link $LINE --forcedoneb 上面的脚本是利用了homebrew将LinkedKegs目录设置成了存放所有二进制文件的路径的特点，将其全部取出，删除全部软链，而后重新建立软链。 其实也可以将ls -1 /usr/local/Library/LinkedKegs替换成brew list -1也可。 参考文章 Mac入门（三）使用brew安装软件","link":"/2016/08/10/the_tutorial_101_of_homebrew_on_mac/"},{"title":"/bin /sbin /usr/sbin /usr/bin 目录的简单区别","text":"文章更新 20160817-初次成文 为什么会有这篇文章因为一直不是很明白这几个目录有什么区别，尤其是bin和sbin的区别，因此转载了这篇文章，方便自己记忆。 这些目录都是存放命令的，首先区别下/sbin和/bin： 从命令功能来看，/sbin 下的命令属于基本的系统命令，如shutdown，reboot，用于启动系统，修复系统，/bin 下存放一些普通的基本命令，如ls, chmod 等，这些命令在Linux系统里的配置文件脚本里经常用到。 从用户权限的角度看，/sbin 目录下的命令通常只有管理员才可以运行，/bin 下的命令管理员和一般的用户都可以使用。 从可运行时间角度看，/sbin, /bin 能够在挂载其他文件系统前就可以使用。 而/usr/bin, /usr/sbin 与 /sbin /bin目录的区别在于： /bin, /sbin 目录是在系统启动后挂载到根文件系统中的，所以/sbin, /bin 目录必须和根文件系统在同一分区； /usr/bin, usr/sbin 可以和根文件系统不在一个分区。 /usr/sbin 存放的一些非必须的系统命令；/usr/bin 存放一些用户命令，如led(控制LED灯的)。 转下一位网友的解读，个人认为诠释得很到位： /bin 是系统的一些指令。bin为binary的简写主要放置一些系统的必备执行档例如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar等。 /sbin 一般是指超级用户指令。主要放置一些系统管理的必备程式例如:cfdisk、dhcpcd、dump、e2fsck、fdisk、halt、ifconfig、ifup、 ifdown、init、insmod、lilo、lsmod、mke2fs、modprobe、quotacheck、reboot、rmmod、 runlevel、shutdown等。 /usr/bin 是你在后期安装的一些软件的运行脚本。主要放置一些应用软体工具的必备执行档例如c++、g++、gcc、chdrv、diff、dig、du、eject、elm、free、gnome、 gzip、htpasswd、kfm、ktop、last、less、locale、m4、make、man、mcopy、ncftp、 newaliases、nslookup passwd、quota、smb、wget等。 /usr/sbin 放置一些用户安装的系统管理的必备程式例如:dhcpd、httpd、imap、in.*d、inetd、lpd、named、netconfig、nmbd、samba、sendmail、squid、swap、tcpd、tcpdump等。 如果新装的系统，运行一些很正常的诸如：shutdown，fdisk的命令时，悍然提示：bash:command not found。那么首先就要考虑root 的$PATH里是否已经包含了这些环境变量。可以查看PATH，如果是：PATH=$PATH:$HOME/bin 则需要添加成如下： 1PATH=$PATH:$HOME/bin:/sbin:/usr/bin:/usr/sbin 参考文章 /bin,/sbin,/usr/sbin,/usr/bin 目录之简单区别","link":"/2016/08/17/the_difference_between_bin_sbin_and_those_under_usr_folder_in_linx/"},{"title":"hexo在github部署卡住的奇怪问题","text":"文章更新 20160815-初次成文 20160831-增加了一个检查的步骤 20170222-更新hexo推送到多个github repo的一个小插曲 为什么会有这篇文章最近电脑拿去送修了，修好了之后什么都没有了，重新clone了自己在coding上的hexo源文件，hexo clean, hexo g, hexo d，本以为一切正常，却发现hexo在显示 On branch master nothing to commit, working tree clean 之后就一直卡着不动，经过了小半天的时间查找问题，才解决。 问题描述Hexo deploy的时候卡住，如果使用hexo deploy --debug，则会显示 Error: Permission denied (publickey). fatal: Could not read from remote repository. 但是，key 已经设置正常，并且 ssh -T git@github.com 连接正常。 解决办法步骤1：检查_config.yml先说说我自己的情况，我是github和coding.net两地部署的hexo静态文件，Markdown原始文件保存在了coding.net的私密库中，使用git来管理源文件，使用hexo deploy将生成的静态文件推送到（部署到）github pages和coding.net两个网站的静态空间上去。 那么，我首先就是检查自己hexo网站的_config.yml文件中关于deploy的选项是否正确。 1234567891011# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:- type: git repo: git@github.com:tinyvane/tinyvane.github.io.git branch: master message: \"Github Site updateed: {{ now('YYYY-MM-DD HH:mm:ss') }}\"- type: git repo: git@git.coding.net:tinyvane/tinyvane.git branch: master message: \"Coding.net Site updateed: {{ now('YYYY-MM-DD HH:mm:ss') }}\" 这是我的相关配置，网上也有把两个repo写在一起的情况，其实都是可以的，就好像下面这样 12345deploy: type: git repo: github: git@github.com:tinyvane/tinyvane.github.io.git,master coding: git@git.coding.net:tinyvane/tinyvane.git,master 主要注意2个地方就好了，每个项目之后必须接一个半角的冒号，并且冒号之后接一个半角的空格。这是严格的规定。 最新更新，关于那个host关键字，最近有了新的认识，那个地方并不是简单地一个标志而已，而是可以像ssh -vT git@github1使用，是不是感觉有点意思？为什么我会发现这个区别，因为最近我遇到了一个不大不小的问题，我最近使用hexo来写博客，然后在_config.yml文件中，写了两个repo地址，像如下这样 123456789deploy:- type: git repo: git@github.com:tinyvane/tinyvane.github.io.git branch: master message: \"Github Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }}\"- type: git repo: git@git.coding.net:tinyvane/tinyvane.git branch: master message: \"Coding.net Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }}\" 这样看似没什么问题，但是如果使用ssh -vT git@githbu.com就会显示连接错误，如果使用ssh -vT github就会显示连接正确，是不是发现问题了？对了，那个host的关键字，并不是简单区别不同ssh连接的关键字而已，而是可以像上面那样使用简称，所以，我就在_config.yml中稍微修改了一下repo的地址，变成了下面这样 1repo: git@github:tinyvane/tinyvane.github.io.git 这样就OK了，感觉又学了一招。 步骤2：检查.ssh目录配置因为使用的git的推送方式，这种方式不需要每次部署的时候都键入账号密码，所以比较方便。因此就要好好的检查下.ssh目录下的文件内容和权限配置。 文件内容配置使用ssh-keygen -t RSA 的命令来生成公钥和私钥，主要文件名要起得有意义一些，否则默认都是id_rsa，比如，我采用了网站+用户名的组合，比如我的树莓派有root和pi这2个账户，对应的用户名就分别是raspberry_root和raspberry_pi。 然后，多个不同的公钥和私钥文件，以及对应的ssh端口，都需要通过config文件来妥善指定。关于这个话题，请看我的另外一个帖子，《关于ssh免密连接的那些事》，里面给出了详细的说明和例子。 密钥文件权限这个地方，其实并不容易出问题，经常在git链接的时候，会遇到提醒，说你的ssh密钥文件权限过大，存在不安全因素。这里就顺便说一下。 1234sudo chmod 600 ~/.ssh/id_rsa #更改私钥文件权限为600sudo chmod 600 ~/.ssh/id_rsa.pub #更改公钥文件权限为600sudo chmod 644 ~/.ssh/known_hosts #更改known_hosts文件权限为644（这个文件存在被需要连接的服务器上）sudo chmod 755 ~/.ssh #更改.ssh目录权限为755 并且，需要注意这些目录的拥有者是不是当前用户，如果是非管理员想使用root的文件，也会遇到错误。 步骤3：检查git版本在网上google了几个小时，也没有解决这个文件，最终在很多条回复中发现有人提到了git自身可能存在问题。经过试验，我遇到的问题应该也是git的问题，经过升级git到比较新的版本，解决了问题。 我的系统是OSX EI CAPITAN，通过git --version，发现自己的版本是2.7.3，有点老了，如何升级呢？ 当然是建议用brew安装了，目前我装的是2.9.3 1brew install git 然后，2.7.3的老版本git需要删掉么？如何让新装的git覆盖老的git？ 我这里建议是在 ~/.bash_profile 文件中，加入以下内容： 1export PATH=/usr/local/bin:/usr/local/sbin:${PATH} 这样可以让bash优先搜索 /usr/local 下的指令，而且不会覆盖老文件，比较安全。 步骤4：检查’git remote -v’这个步骤，也是我最近发现的，而且严格来说，因为hexo d和git push并没有什么关系。 而且目前也不能确定WIN10导致的这个问题，在另外一台WIN10的PC上，虽然ssh -T git@git.coding.net可以顺利得到欢迎信息，但是每次git push的时候，依然会问我账号密码，所以我觉得应该是哪里设置有问题。 直到我从网上的一个帖子《git使用ssh密钥》，获得了一点灵感，在这个帖子里，介绍了如何使用git remote set-url来修改仓库的push是使用git还是https方式。具体方法如下： 查看目前的远程仓库推送和拉取方式 1git remote -v 如果返回值为空，说明你的.git/config文件缺少 [remote &quot;origin&quot;] 内容，需要使用下列的命令进行添加 1git remote add origin [url] 这是最简单的，如果返回值不是空，你想修改remote库的链接的话，可以使用 12git remote rm origin 先删掉git remote add origin [url] 再添加 或者用另外一个办法 git remote set-url origin [url] 这样也可以修改。 一个小技巧，如果你不想每次都输入git pull origin master或者push origin master的话，可以用下面的命令，让git默认推送或者拉取特定的分支 12git config branch.master.remote origingit config branch.master.merge refs/heads/master 这样就可以用简化的git push或者git pull来推送或者拉取内容了。 这样就有了内容，如果你发现git remote -v返回的是https方式，那么需要修改为git方式 从https修改为git方式 1git remote set-url origin git@git.coding.net:tinyvane/hexo.git 这样再次运行git pull/push就不会在要你密码了。 也可以通过下面的命令，从git修改为https方式 1git remote set-url origin https://git.coding.net/tinyvane/hexo.git 另外，还有一个比较奇怪的问题是，我在rMBP下，无论是hexo deploy还是git push，都不需要输入密码，而且git remote -v显示的也是https方式。所以，就更让我纠结了。 顺便说一下，虽然没有哪个文件记录remote的通信方式，但是这个确实在第一次git clone的时候就定下来了，git clone的时候使用的https的话，就会默认使用https来负责remote仓库的push和fetch。如果想手动该修改，去你本地仓库下.git目录下修改 config文件，其中有一段[remote]记录了这个方式。 其他：如何查看密钥对应的md5码这算是题外话了，写下来放着留着以后看。 错误：Github permission denied: ssh add agent has no identities 使用 ssh-add l（openssh 版本6.7及以下，如果更新的版本，请使用 ssh-add -l -E md5命令）想查看公钥对应的md5码，但是遇到了上面的错误，就要使用 ssh-add /path/to/my-ssh-folder/id_rsa，把对应的私钥文件添加到ssh agent中去，然后就可以了。 PS：目前还不是很明白ssh agent是干嘛用的。 参考文章 Mac OS X Lion 下 Git 如何升级？ Fixing “WARNING: UNPROTECTED PRIVATE KEY FILE!” on Linux hexo官方网站上的一个类似问题的解决过程 git使用ssh密钥","link":"/2016/08/15/the_lag_problem_for_hexo_deploying_on_github/"},{"title":"linux下的移动和合并以及星点星那些破事","text":"文章更新1.201608017-初次成文，稍晚加入了关于. * 以及*.*的说明 为什么会有这篇文章因为使用btsync，刚开始的时候，经常崩溃，然后每次重新安装，btsync就会放弃之前的同名目录，重新建一个文件夹，并在文件夹名字后面加上一个郁闷的（1）或者（2），因此就有很多闲置文件夹放在那占着空间。由于总担心会不小心覆盖错了文件，因此就想好好研究下linux下的文件移动和覆盖以及合并文件的问题。 方法1:使用cp命令比如，有两个目录test和new，test目录下有目录和文件，new目录下有更改过的一些test下的目录和文件，以及一些新增的文件，现在对两个目录进行合并以及覆盖test下的旧文件 1cp -fRap new/* test/ 命令参数 f 强制覆盖，不询问yes/no（-i的默认的，即默认为交互模式，询问是否覆盖） R 递归复制，包含目录 a 做一个备份，这里可以不用这个参数，我们可以先备份整个test目录。该选项通常在拷贝目录时使用，它保留链接、文件属性，并递归地拷贝目录，其作用等于dpR选项的组合。 p 保持新文件的属性不变。 d 拷贝时保留链接。 i 和f选项相反，在覆盖目标文件之前将给出提示要求用户确认。回答y时目标文件将被覆盖，是交互式拷贝。 p 此时cp除复制源文件的内容外，还将把其修改时间和访问权限也复制到新文件中。 r 若给出的源文件是一目录文件，此时cp将递归复制该目录下所有的子目录和文件。此时目标文件也必须为一个目录名。 需要说明的是，如用户指定的目标文件名是一个已存在的文件名，用cp命令拷贝文件后，这个文件就会被新拷贝的源文件覆盖。为防止用户出现这种意想不到的情况，建议在使用cp命令拷贝文件时，最好使用i选项。 命令实例1234cp -r /usr/xu/ /usr/liu/ #将/usr/xu目录中的所有文件及其子目录拷贝到目录/usr/liu中。cp -fRp new/* test/ #将new目录下的所有文件和目录复制到test目录下面cp -r dir1 dir2 #dir2不存在，能将dir1下所有文件复制到dir2下cp -r dir1/. dir2 #如果dir2目录已存在，则需要在dir1后面加上 /. 因为如果使用cp -r dir1 dir2,则也会将dir1目录复制到dir2中，明显不符合要求。 方法2:使用mv命令命令格式mv [选项(option)] 源文件或目录 目标文件或目录 如 1mv webdata /bin/usr/ 命令说明 视mv命令中第二个参数类型的不同（文件还是目录？），mv命令将文件重命名或将其移至一个新的目录中。 当第二个参数类型是文件时，mv命令完成文件重命名，此时，源文件只能有一个（也可以是源目录名），它将所给的源文件或目录重命名为给定的目标文件名。 当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，mv命令将各参数指定的源文件均移至目标目录中。在跨文件系统移动文件时，mv先拷贝，再将原有文件删除，而链至该文件的链接也将丢失。 参数说明 i 交互方式操作。如果mv操作将导致对已存在的目标文件的覆盖，此时系统询问是否重写，要求用户回答”y”或”n”，这样可以避免误覆盖文件。 f 禁止交互操作。mv操作要覆盖某个已有的目标文件时不给任何指示，指定此参数后i参数将不再起作用。 r 指示mv将参数中列出的全部目录和子目录均递归地移动。 b 若需覆盖文件，则覆盖前先行备份。 u 若目标文件已经存在，则比较原文和目标文件哪个更新，如果源文件最近修改了，才会进行移动，否则就忽略。 命令实例123456mv /usr/lib/* /zone #是将 /usr/lib 下所有文件移到 /zone 目录下。mv /usr/lib/*.txt /zone #是将 /usr/lib 下以txt结尾的所有文件移到 /zone 目录下。mv zhidao.txt baidu.txt #将文件zhidao.txt重命名为baidu.txtmv log1.txt log2.txt log3.txt test3 #将文件log1.txt,log2.txt,log3.txt移动到目录test3中。mv /usr/local/arm/arm/* /usr/local/arm/ #移动 /usr/local/arm/arm 目录下的全部东西到 /usr/local/arm/，而不是移动 /usr/local/arm/arm 这个目录到他处mv -u dir1/* dir2/ #将dir1下的全部东西移动到dir2下，使用u参数是怕覆盖到新修改的文件，但是这个命令不会移动0字节的隐藏文件，或者0自己的可见文件。 关于. * 以及*.*比如，下面这个问题 123cp -r dir1/. dir2 cp -r dir1/* dir2 cp -r dir1/*.* dir2 这三个命令有区别么？再深一步，如果没有参数r，区别又是什么？ 经过实践，大概缕清了头绪。 实例1先上图，我建立了两个目录，一个dir1，一个dir2，dir1下有文件，有带.的文件，有不带扩展名的文件，也有隐藏的文件和目录 首先，先说 dir1/.，在这里 . 并不能代表全部文件。 如果使用 cp dir1/. dir2，会遇到 cp: omitting directory ‘dir1/.’ 的错误，但是进去dir2会发现，cp把隐藏的目录复制过去了，但是隐藏的文件，以及其他目录和文件都没有复制过去。 更正，什么都不会复制过去。 但是！我说但是，神奇的事情发生了，如果带着参数r，那么情况就完全不同了，具体请参考下面的 实例3。 使用rm -rf dir1/. ，会遇到 rm: refusing to remove ‘.’ or ‘..’ directory: skipping ‘dir1/.’ 的错误。并不会像cp命令那样，还删掉隐藏的文件夹或者其他什么内容。 实例2 rm -rf dir2/. 报错 rm -rf dir2/*.* 或者 rm -rf dir2/* 都没有删掉dir2下的隐藏目录 .hiddendir1 但是使用 rm -rf dir2/.* 却删掉了，虽然也遇到了错误 12rm: refusing to remove ‘.’ or ‘..’ directory: skipping ‘dir2/.’rm: refusing to remove ‘.’ or ‘..’ directory: skipping ‘dir2/..’ 看来.*,在linux看来可以表示. 和 ..以及所有的隐藏目录和文件。 如果想彻底删掉目录下的所有文件（包括隐藏文件或隐藏目录）,同时保留这个目录，目前看来是没有一步到位的方法，需要两条命令结合使用 12rm -rf dir2/*rm -rf dir2/.* 当然了，如果你连dir2都不要了，那么用一条命令就可以搞定 rm -rf dir2。 如果你在dir2目录下面，那么相应的命令就变成了 12rm -rf ./*rm -rf ./.* 是不是看着特别绕？想明白就好了。./* 并不包括隐藏目录和文件，因为只是恰巧.在linux既代表当前目录，又是隐藏文件的标识符，就比较有意思了。 实例3 我的结果是 12cp -r dir1/. dir2/cp -r dir1/* dir2/（这条的效果，我并没有亲自验证） 这俩个效果一样（待查） cp dir1/. dir2/ 则什么都不会复制过去。 特别感谢 树莓派贴吧官方群 QQ群里的 萌萌哒 同学的大力支持，他亲自实践了好多内容，没有他就没有这篇文章的最终出炉。 参考文章 Linux下目录的合并以及文件的覆盖 linux实用命令之如何移动文件夹及文件下所有文件","link":"/2016/08/17/move_and_merge_files_with_cp_and_mv_in_linux/"},{"title":"使用Synerge在两台电脑间共享鼠标键盘","text":"文章更新 20160818-初次成文 为什么会有这篇文章因为我有一台装了WINDOWS 10的PC和一台MBP，回到家在两台电脑之间切换总是比较麻烦，所以才想能否用一套键盘鼠标控制两台电脑。synergy是个不错的选择。 Synergy介绍Synergy是鼎鼎大名的一款键盘鼠标共享软件，而且开源、跨平台，也能复制剪切版和拖拽文件，据说它是谷歌工程师标配，因为他们也有在多台主机间控制电脑困扰。 但synergy公司也很奇葩，工具开源，但最新版的下载不免费，你要支付之后才能看到新版下载页面（旧版本免费开放，但是却存在bug而且没有解决）。我想原因大概是synergy既要遵守开源协议，但又要维持收入吧。奇怪的是网上竟然很少有人把它共享下载。当然，如果你不嫌麻烦，可以去 这个官方地址 下载源码，自己编译，synergy还很友好的提供了编译指南… 无奈我自己的水平还不够… 好了，话题继续回到软件的使用介绍。 这里分享v1.7.4版本下载，链接: http://pan.baidu.com/s/1mhbaLza 密码: m4d7 我现在一直使用的是synergy，鼠键接在Windows主机，但有一个问题没解决：synergy即使加入了Mac mini（用户）开机启动，但用户没输密码登陆之前，是不会启动synergy的，所以还是要另外接一套鼠键来输密码，随后synergy接管，衰，不知谁有更好的办法？ 配置过程Windows作服务端synergy要求鼠键在Server，需要鼠键的其它电脑可以没有。 勾选 【Server】，可以看到当前电脑的ip地址 点击 【设置服务端】，默认最中间显示器代表当前电脑 从右上角拖一个到你想要展示的相对位置，双击编辑 【屏幕名】（即其它电脑的主机名） mac做客户端在mac【设置】里选择【安全与隐私】，点击【隐私】选项卡，【辅助功能】，勾选右边的 Synergy。 勾选【Client】，输入上一节看到的服务端ip。 同时注意 screen name 就是上一节要填入的屏幕名，也是主机名啦。不要忘了 start，看到 。。。。 就正常了，享受 “一键” 的快感吧。 后记用了一个晚上，很流畅，不过后来我用了mbp的键盘和trackpad，就是把mbp当做了主机，把pc当成了client，因为一直觉得苹果电脑的trackpad实在是太好用了。 不过第二天，再次重启机器的时候，无论如何也用不了了… 跨平台共享鼠标键盘-synergy","link":"/2016/08/18/use_synergy_to_share_mouse_and_keyboard_between_2_computers/"},{"title":"在WINDOWS平台安装Xamarin的步骤","text":"文章更新1.20160706-初次成文 为什么会有这篇文章最近想做一个APP统计自己花在工作写代码、工作以及其他上的时间，所以一个手机上的APP是最适合不过的。不过看了下IOS开发的XCODE，有点头大，还是先从自己熟悉的C#开始吧。 下载Xamarin参考文章","link":"/2016/08/29/install_Xamarin_on_windows/"},{"title":"Shell编程之简单的条件判断和检测","text":"文章更新 20160819-初次成文 为什么会有这篇文章因为我使用的树莓派一直存在IO过高的时候就自动断开连接的问题，原来并不是简单断开而已，而是系统自动又挂载了一个名为/media/pi/xxx的（xxx是该外接硬盘的UUID）挂载点，而原来为btsync设定的默认挂载点并没有umount，经过试验知道了如何把两个挂载点都清除掉，并且重新挂载的方法，唯一的问题就是，如何检测？之前采用的[ -d ]判断目录是否存在的方法，然而这个方法并不可靠，而检测df -l中的新UUID则更为可靠。借着更新我的检测脚本的机会，正式总结一下shell编程的条件判断和检测，并且也学习了一下grep -v grep这种方法。 不废话，上代码用shell脚本监控进程是否存在 不存在则启动的实例： 12345678#!/bin/shps -fe | grep processString | grep -v grepif [ $? -ne 0 ]then echo \"start process.....\"else echo \"runing.....\"fi 其中，processString 表示进程特征字符串，能够查询到唯一进程的特征字符串 $? -ne 0 表示查找的字符串不存在 $? -eq 0 表示查找的字符串存在 条件判断 if elif then else fi条件判断的基本结构 1234567if ....; then ....elif ....; then ....else ....fi 如果要把 if 和 then 写在一行，就需要加一个; 否则 then 和 if 就要换行对齐。 条件检测[ ]大多数情况下，可以使用测试命令来对条件进行测试。比如可以比较字符串、判断文件是否存在及是否可读等等。通常用[ ]来表示条件测试。注意这里的空格很重要。要确保方括号左右各有一个半角的空格。 [ -f “somefile” ] 判断是否是一个文件 [ -x “/bin/ls” ] 判断/bin/ls是否存在并有可执行权限 [ -n “$var” ] 判断$var变量是否有值 [ “$a” = “$b” ] 判断$a和$b是否相等 更多参数方法见下面 -r file 用户可读该文件（true） -w file 用户可写该文件（true） -x file 用户可执行该文件（true） -f file 文件为正规文件为真 -d file 文件为目录为真 -c file 文件为字符特殊文件为真 -b file 文件为块特殊文件为真 -s file 文件大小非0时为真 -t file 当文件描述符(默认为1)指定的设备为终端时为真 含条件选择的shell脚本对于不含变量的任务简单shell脚本一般能胜任。但在执行一些决策任务时，就需要包含 if/then 的条件判断了。shell脚本编程支持此类运算，包括比较运算、判断文件是否存在等。基本的 if 条件命令选项有： -eq 比较两个参数是否相等（例如，if [ 2 –eq 5 ]） -ne —比较两个参数是否不相等 -lt —参数1是否小于参数2 -le —参数1是否小于等于参数2 -gt —参数1是否大于参数2 -ge —参数1是否大于等于参数2 -f —检查某文件是否存在（例如，if [ -f &quot;filename&quot; ]） -d —检查目录是否存在 几乎所有的判断都可以用这些比较运算符实现。脚本中常用 -f 命令选项在执行某一文件之前检查它是否存在。 判断文件是否存在123456789#!/bin/shtoday=`date -d yesterday +%y%m%d`file=\"apache_$today.tar.gz\"cd /home/pi/shellif [ -f \"$file\" ];then echo \"OK\"else echo \"error $file\" &gt; error.logfi shell基本命令 ps aux #显示系统全部进程，一行一个 grep “abc” #从标准输入读取字符流，输出包含字符串“abc”的行 grep -v “acb” #从标准输入读取字符流，输出不包含字符串“abc”的行 wc -l #从标准输入读取字符流，输出行数 例如需要检测进程httpd是否存在，操作流程如下： 读取系统所有进程 判断包含指定进程名字的信息是否存在 通过管道连接，命令如下： 1ps axu | grep \"httpd\" | grep -v \"grep\" | wc -l 所有进程–&gt;获取包含“httpd”的行–&gt;删除grep进程信息–&gt;输出最后的行数 通过判断命令的执行结果是否为 0 ，可以知道进程是否存在。 脚本如下: 1234567891011#!/bin/shwhile true;do count=`ps -ef | grep http | grep -v grep` if [ \"$?\" != \"0\" ];then echo \"&gt;&gt;&gt;&gt;no httpd,run it\" service httpd start else echo \"&gt;&gt;&gt;&gt;httpd is runing...\" fi sleep 5done 关于 grep -v grep 这种用法，网上也有人指出这种方法比较浪费资源，所以如果不想在ps 的管道中显示出来grep命令自身，直接使用 ps grep | grep &quot;http&quot; | grep '[h]ttp' 的方式就好。 参考文章 用shell脚本监控进程是否存在 不存在则启动的实例","link":"/2016/08/19/simple_comparation_and_detection_by_shell_under_linux/"},{"title":"cygwin在windows上的初体验","text":"文章更新 20160826-初次成文 20160928-更新了cygwin的坑 20170313-更新了git的更新内容 为什么会有这篇文章之前用过BABUN，也用过GIT+NODE.JS的组合来使用GIT，都不是特别满意，发现很多人都推荐在Windows上使用cygwin来获得linux体验。PS:不小心改动cygwin下的text编码，导致github上的文件名全部乱码了，所以就卸载了cygwin, git for windows还有node.js等等一系列东西，全部重装一次，记录一下。 如何安装cygwin在安装之前，网上查了一下cygwin和msysmin？的区别，还是选用了cygwin，一个是之前用的就是这个程序，另外一个是这个比msysmin要好一些？程序的下载地址。 值得一说的就是cygwin的package的安装方式，全部依靠setup.exe来完成，不过初次安装的时候，建议带着git, wget和vim。 我的cygwin自带的git版本是2.8，此时官方git的版本是2.12.0，如果大家想升级cygwin下的git，需要手动编译升级，可以参考这篇文章。 cygwin下的git设置JiangXin的这篇文章，对cygwin以及git设置讲解的比较实用，大家可以参考一下。我从里面摘录了几个： 设置用户主目录，修改Cygwin启动的批处理文件（如：C:\\cygwin\\Cygwin.bat），在批处理的开头添加如下的一行，就可以清除其他软件为Windows引入的HOME环境变量。 1set HOME= 忽略文件权限的可执行位 1git config --system core.fileMode false 支持中文 1git config --global core.quotepath false 安装node.js因为我装cygwin目的之一是为了hexo，所以当我发现在hexo目录下，实用hexo new命令说找不到，发现缺少node和npm，网上google了一番，没啥说的，也不指望原生编译安装了， 直接去官网下了一个LTS版本，也没有网上说的需要手动添加环境变量的问题，装好了，重开一个cygwin窗口，搞定了。 如何用命令管理package推荐apt-cyg来管理，命令也比较简单（这里至少需要wget或者lynx） 1234wget rawgit.com/transcode-open/apt-cyg/master/apt-cygchmod +x apt-cygmv apt-cyg /usr/local/bin/apt-cyg install vim 或者 123lynx -source rawgit.com/transcode-open/apt-cyg/master/apt-cyg &gt; apt-cyginstall apt-cyg /binapt-cyg install vim 上面两种方式都可以。我发现如果直接在shell下运行 apt-cyg 命令是不行的，必须用 /bin/apt-cyg install vim 的形式，说明cygwin下的PATH应该是缺少/bin目录，果然通过运行 echo $path，返回结果为空。 apt-cyg的参数具体可以参考他的github官方说明 这里大概总结一下 install 安装package(s). remove 删除某个package update 升级setup.ini文件中所有package到最新版本。服务器地址由setup.rc定义。 download 下载package，但是并不安装，也不升级。 show 显示某个package的信息 depends 生成某个package的依赖包信息 rdepends 以树形式，生成某个package的依赖包信息 list 可以通过正则表达匹配列出符合的package，如果直接list，则列出所有安装的package信息 listall 列出所有package. category 根据目录名称列出所有下面的package listfiles 列出某个package的所有文件。可以给出多个package的名字。 search 搜索某个package searchall 从cygwin.com提取某个package的包信息 安装oh-my-zsh1apt-cyg install zsh curl git 为了zsh准备的三个package，如果你在安装cygwin的时候已经默认安装了这些，上面的命令可以忽略。 1sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" 遇到了错误 1C:/cygwin64/bin/curl.exe: error while loading shared libraries: cygmetalink-3.dll: cannot open shared object file: No such file or directory 说明curl少一个文件，这里可以用一个比较有用的命令 cygcheck，来了解curl到底缺少了什么文件。 1cygcheck /usr/bin/curl #路径换成/bin/curl也可以 结果发现是 cygmetalink-3.dll，这个文件，GOOGLE了一下，发现网易的镜像有这个文件，地址在这里 12345mkdir /usr/local/tmpcd /usr/local/tmpwget http://mirrors.163.com/cygwin/x86/release/libmetalink/libmetalink3/libmetalink3-0.1.2-1.tar.bz2tar -xf libmetalink3-0.1.2-1.tar.bz2mv /usr/local/tmp/usr/bin/cygmetalink-3.dll /bin 好了，再次运行sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 估计是因为环境PATH的设置问题，上面这条没有任何回应，好了，死马当活马医，把命令拆了 123cd ~wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O ../install.sh 这样有点费劲，把一句拆成了3句，不过成功了，见下图。 直接打开cygwin进入zsh直接执行命令 zsh，就会从bash切换到 oh-my-zsh 。 但当我们开启第二个 Cygwin 窗口或者重启 Cygwin 的时候，默认使用的依然是 bash。那怎么样才能默认就使用 zsh 呢？ 有两个方法可以做到： 在 .bashrc 文件最后添加代码 exec /bin/zsh，让 zsh 来替代 bash，就跟刚才我们直接执行 zsh 的操作一样 右键点击 Cygwin 启动图标查看属性，更改其目标为 c:\\cygwin64\\bin\\mintty.exe /bin/zsh -l(具体路径要根据你自己的情况)。当然其中的路径需要修改成 Cygwin 的安装路径。 这样在 Windows 下就可以爽快得使用 oh-my-zsh 了。 注意在安装 zsh 之后，cygwin 的 bin 目录下会多一个 mkzsh 脚本。执行此脚本会在 Cygwin 的安装根目录下生成一个 zsh.bat 文件。执行此文件也可以使用带 zsh 登录的命令行界面。只不过……这个脚本开启的是 Windows 的 cmd.exe……比起 Mintty 的界面丑多了……所以还是推荐使用之前说的第二种方法。 添加一些别名因为我喜欢VIM和SUBLIME两个结合着使用，所以我在.zshrc里面添加了subl作为sublime text 3的别名，其实也很简单，但是路径写起来比较费劲，所以这里留个参考 1alias subl=&quot;C:/Program\\ Files/Sublime\\ Text\\ 3/sublime_text.exe&quot; 一些需要习惯的用法 更强大的tab补全，当你切换目录敲两下tab，他可以列出当前目录下面的所有目录，并且可以使用键盘上下左右键来选择要进入的目录。 更智能的切换目录，比如你要进入一个很深的目录，like this /var/log/nginx/error/lastyear/may/first/monday, 用zsh可以这样输入cd /v/l/n/e/l/m/f/m，然后按tab即可补全整个路径。或者你实现知道当前目录名称，可以直接输入目录，即可进去目录。bash下cd - 可以切换到刚才进入的目录，在zsh下可以记录最近进去过的10个目录，只需要输入d,然后看到对应的0-9的目录，输入对应的数字，即可进入对应的目录（感谢 @JayXon 的提示）。或者直接输入cd -然他后TAB一下，你会发现有最近使用过的31个目录等候你选择。 命令选项补齐，比如输入docker，然后按tab，即可显示出docker都有哪些命令选项。 命令参数补齐，比如要kill一个进程，直接输入kill 进程名，会自动显示出进程的process id，如果用ssh，则会输出最近用ssh 连接过的主机名，配合.zshrc还可以实现自定义ping命令自动补齐的命令参数。zstyle ‘:completion::ping:‘ hosts 192.168.1.{1,50,51,100,101} www.google.com 大小写字母自动更正，比如我们要cat一下README.txt，直接输入cat readme.txt TAB,之后zsh就会把小写的readme改成大写的。 有着丰富多彩的主题，如果你使用我的脚本安装oh-my-zsh的项目的话，在/.oh-my-zsh/themes里会找到多达142个主题，看中哪个主题直接在/.zshrc 里面更改. 更强大的alias命令,比如下面命令，当你在zsh环境下输入hello.py即可直接用vim打开文件编辑，一个tgz的文件即可自动解压缩。 123alias -s py=vimalias -s html=vimalias -s tgz='tar zxvf' 智能命令错误纠正，比如输入apt-gte install somefile,回车后，zsh会提示你是否纠正apt-gte 为apt-get?输入y，后即是正确命令执行。在配合一下zshrc的profile的sudo命令设置，按两下ESC，即可在命令的前面自动加上sudo。 1234567891011##在命令前插入 sudo {{{#定义功能sudo-command-line() { [[ -z $BUFFER ]] &amp;&amp; zle up-history [[ $BUFFER != sudo\\ * ]] &amp;&amp; BUFFER=\"sudo $BUFFER\" zle end-of-line #光标移动到行末}zle -N sudo-command-line#定义快捷键为： [Esc] [Esc]bindkey \"\\e\\e\" sudo-command-line#}}} 最最强大的优点是可以集成各种类型的插件，比如切换目录的可以继承autojump,想跳转到哪里，直接j 加目录名称，真的非常强大，非常便利，这个bash也可以使用。比如想要去nginx目录，可以直接输入j nginx，他会搜索使用率最高的nginx的路径，如果想要去/var/log/下的nginx呢，直接输入j v ng 在cygwin上安装hexonpm就不要纠结是否用apt-cyg安装了，直接去node.js的官网下载windows 64位版本安装，node.js自带npm，安装后就可以在cygwin下使用npm了。 三句话 123npm install -g hexo-clinpm install Hexo-deployer-git --save npm install hexo-asset-image --save 然后就可以继续写文章了。 cygwin文件权限的坑坑洼洼这个问题也是最近才发现的，在cygwin下创建的文件，无法在vscode中打开，甚至用cd命令都进不去建立的文件夹。需要的，给cygwin的运行程序建立快捷方式，然后勾选“使用管理员权限运行程序”，这是第一步。 cygwin将Windows系统的文件权限实现成POSIX的文件权限，而POSIX文件是以ACL来管理文件权限的。POSIX的文件、目录权限是被mount选项来控制的，默认设置为acl。这样做，会导致Windows系统中应用程序的文件权限产生混乱，为了解决这个问题，需要添加noacl参数，将/etc/fatab改为： 1none /cygdrive cygdrive binary,user,noacl,posix=000 但是上面的改动仅仅是修改了/cygdrive目录，也就是windows系统中的所有的磁盘（C:、D:、E:、F:等），而cygwin本身的/并未修改，同样会存在上述的权限问题，因此需要一并修改，最终完整的/etc/fatab文件内容如下： 1234none /cygdrive cygdrive binary,user,noacl,posix=000C:\\cygwin64 / ntfs binary,noacl,override00C:\\cygwin64\\bin/usr/bin ntfs binary,noacl,override00C:\\cygwin64\\lib /usr/lib ntfs binary,noacl,override00 这样设置后，无论是mkdir还是ls或者cd，都可以正常执行了，但是还有一个问题，就是这样建立之后的目录，进入之后，无法启动windows的原生二进制程序，比如笔者通过alias设置的vscode，就无法在新建的目录中启动，但是其他目录是可以的。错误提示如下 123Error: Current working directory has restricted permissions which render itinaccessible as Win32 working directory.Can't start native Windows application from here. 虽然可以通过在上层目录运行，然后再切换到新建的目录下，毕竟很不方便，经过测试，发现上面这样更改后，mkdir后的文件夹(注意一定要关闭cygwin所有终端之后，重启cygwin才可以)，可以直接运行比如vscode这样的程序，但是之前旧时建立的文件夹则不行，通过查看windows的目录权限，发现新旧两个文件夹主要的区别就是windows账户登录的账户名，是否拥有完全的控制权限。而一旦更改的话，则会遇到Failed to enumerate objects in the container.的错误，就是无法枚举容器中的对象,访问被拒绝这个错误，网上也没有找到特别好的解决办法，所以我就暂时不想解决了，直接新建了个目录，把文件复制过去了。 123mv ./dir1/* ./dir2rmdir ./dir1mv dir2 dir1 这个算是权宜之计吧。因为dir1目录已经无法操作了，应该是之前cygwin留下的后遗症，只能把里面的文件暂时搞到其他地方去了。 如果有哪位同学了解cygwin和windows文件系统权限冲突的解决办法，或者可以稍微解释下这个文件，请尽管赐教，在这里先谢谢了。 其他唠叨几句卸载cygwin的方法，如果你是删掉了整个cygwin64的目录，那么你的个人root主目录也会一起没了，里面的.ssh目录下的文件，也一起没了啊，这个请一定要注意-_-!!! 参考文章 Cygwin 上安装 Oh-My-Zsh mac 装了 oh my zsh 后比用 bash 具体好在哪儿？ cygwin的坑坑洼洼 Windows下安装和使用Git（Cygwin篇）","link":"/2016/08/26/use_cygwin_as_linux_shell_on_windows_10/"},{"title":"在树莓派上安装赚钱宝云监工","text":"文章更新 20160831-初次成文 为什么会有这篇文章因为自己之前入手了几个赚钱宝，发现在PC上运行监控程序总要开机，不HAPPY，发现”云监工在github上有代码，就clone了在树莓派上安装一个玩。 参考文章","link":"/2016/08/31/install_crysadm_on_raspberry_pi/"},{"title":"树莓派折腾之防火墙","text":"文章更新 20160907-初次成文 为什么会有这篇文章随着使用Resilio Sync，发现5-6个不同的客户端之间的通信总是有一些问题，尤其是处于内网的树莓派和另外一台笔记本，这两台与本地网络内的台式机通信没问题，但是和外网的阿里云服务器，以及我在公司上班时候的MBP就经常在都开机的时候，也无法有效通信。 现在突然发现，基本除了WINDOWS之外，LINUX服务器的防火墙真的不得不好好设置的一个任务。 树莓派防火墙ufw123456sudo apt-get install ufw #安装sudo ufw enable #开启防火墙sudo ufw allow 80 #允许外网访问80端口sudo ufw allow from 192.168.1.0/24 #允许局域网内的全部访问请求sudo ufw allow 22 #允许ssh的访问sudo ufw status #查看防火墙状态 你会看到类似的结果 123456789Status: activeTo Action From-- ------ ----80 ALLOW Anywhere22 ALLOW AnywhereAnywhere ALLOW 192.168.1.0/2480 ALLOW Anywhere (v6)22 ALLOW Anywhere (v6) 看网上的文章，说还有一个图形版的ufw，名字是gufw，大家可以自己试试。 另外还有一个问题，就是在使用ufw allow的时候，默认是ipv4和Ipv6一起允许了，这样也有一些安全问题，如果你在意，可以寻找办法只允许ipv4访问，而不要同时允许ipv6访问。 参考文章 Setting up a simple firewall for use in the DMZ 玩转树莓派－Raspberry，内置的防火墙ufw设置和启用","link":"/2016/09/07/the_firewall_on_raspberry_pi/"},{"title":"CentOS 7的网络配置","text":"文章更新 20160901-初次成文 为什么会有这篇文章最近发现随着共享文件的增多，树莓派的IO问题暴露出来了，而且用了新版本的Resilio Sync，CPU占用非常的高，也许他们版本更新会解决这个问题，但是工作不能等，还是的找个方法继续做共享。正好自己有一台笔记本放着也是放着，用来当服务器了，接个外接硬盘，这样即便是以后换其他客户端，里面的文件也可以拔下来硬盘就换主机。因为笔记本用的CENTOS7系统，所以还是有很多地方和CENTOS6不大一样的，记录一下也有好处。 准备工作：关掉桌面GUI也许是最近LINUX用的多了，所以觉得除了WINDOWS其他的桌面用着非常不习惯，尤其是有命令行的时候，用鼠标点来点去的感觉有点隔靴搔痒的感觉，索性启动直接进入命令行就好了。 命令也简单 12systemctl set-default multi-user.target #命令模式systemctl set-default graphical.target #图形模式 如果问为什么，可以稍微多了解一些，如果查看 /etc/inittab 这个文件，会看到下面的内容 123456789101112131415# inittab is no longer used when using systemd.## ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.## Ctrl-Alt-Delete is handled by /etc/systemd/system/ctrl-alt-del.target## systemd uses 'targets' instead of runlevels. By default, there are two main targets:## multi-user.target: analogous to runlevel 3# graphical.target: analogous to runlevel 5## To set a default target, run:## ln -sf /lib/systemd/system/&lt;target name&gt;.target /etc/systemd/system/default.target# 提示说inittab文件已经不被使用，现在CentOS7使用systemd作为新的init系统，而systemd系统使用 target 来代替 runlevel，默认有两个主要的target： multi-user.target：相当于runlevel 3[命令行界面]，graphical.target：相当于runlevel 5[图形界面] 设置默认的target则使用命令： 1ln -sf /lib/systemd/system/&lt;target name&gt;.target /etc/systemd/system/default.target 我这里要将CentOS7开机默认进入命令行界面，则运行命令： 1ln -sf /lib/systemd/system/multi-user.target /etc/systemd/system/default.target 如果要改回图形界面，则运行命令： 1ln -sf /lib/systemd/system/graphical.target /etc/systemd/system/default.target 我得承认，上面的两种命令，具体的异同，我还不是很明白。 设置本地连接因为要用这个电脑做NAS的功能，所以还是用有线连接更为可靠一些。CentOS 7默认是没有开启本地连接的，意思就是你就算插上了网线，也不会自动分配上网的IP地址，需要自己手动配置。 初始条件下，CentOS 7没有带 ifconfig 命令，而是有了新的 ip 命令，所以先输入 ip addr，会列出当前的网络配置情况。 有意思的事，在CentOS 7，本地连接从eth0，改名为一个奇怪的名字，我的是enp9s0。 然后你会发现这个enp9s0，并没有得到IP地址，好了，自己改吧。 先去 /etc/sysconfig/network-scripts 目录下，看看网卡的配置文件名。 1ls /etc/sysconfig/network-scripts/ 就是图片上那个第一个文件就是本地网卡的配置文件。 好了，编辑 1vim /etc/sysconfig/network-scripts/ifcfg-enp9s0 将其中的 ONBOOT=no 改为 ONBOOT=yes，然后重启电脑 shutdown -r，或者重启网络/etc/init.d/network restart。(网上还有再使用 service network restart 两条一起来的，应该是有所不同，不过目前先不是深究了）。 使用静态IP地址重启之后，再次使用 ip addr，可以看到 enp9s0 已经有了IP地址，但是NAS一般要使用静态地址，所以，继续在ifcfg-enp9s0文件上进行修改。 添加下面几行 1234IPADDR0=192.168.10.173PREFIX0=24GATEWAY0=192.168.10.1DNS1=192.168.10.1 然后把 BOOTPROTO=dhcp 这行给注释掉。再次重启，会看到IP地址已经变了。 CentOS 7的防火墙在CentOS 7上安装了Resilio Sync，然后路由器上也做了端口转发，但是其他客户端都无法使用本地地址打开Sync的WEB界面，才想到，这台客户端使用的是牛逼哄哄的CentOS 7啊，还有恶心的 iptable 防火墙要配置呢。 不过别担心，其实也不是很麻烦。 CentOS 7默认没有使用 iptable 而是用了新的命令 firewall-cmd 来管理防火墙。 使用命令 firewall-cmd --list-all-zones，会看到列出所有的区域信息，其中 public是默认使用且处于活动状态，见下图： 所以，还是需要自己手动添加端口 123firewall-cmd --add-port=8080/tcp #添加例外端口firewall-cmd --remove-port=8080/tcp #删除例外端口firewall-cmd --query-port=8080/tcp #查看例外端口 如果想永久添加，加上 permanent 参数，如： 1firewall-cmd --permanent --add-port=8080/tcp 另外想设置端口范围的可以这样使用： 1firewall-cmd --add-port=80-8080/tcp 如果想使用iptables可以参考下面例子： 停用firewall： 12systemctl stop firewalldsystemctl mask firewalld 安装 iptables-services 1yum install iptables-services 设置 iptables 开机启动 1systemctl enable iptables iptables 控制 1systemctl [stop|start|restart] iptables 或者 1service iptables [stop|start|restart] 保存 iptables 设置 1service iptables save 或者 1/usr/libexec/iptables/iptables.init save 值得注意的是，在使用 man firewall-cmd 查看官方使用说明的时候，提到了如果要使某个动作立即生效并且重启之后继续生效，需要两条连续的命令 12firewall-cmd --add-port=8888/tcp #让这个端口立即生效firewall-cmd --permanent --add-port=8888/tcp #让这个端口在系统重启后依然生效 所以，有问题多使用 man 命令是个好习惯。 GAME OVER. 参考文章 CentOS 7 网络配置 CentOS 7 设置开机直接进入命令行界面 CentOS 7 命令行版初次安装网络配置","link":"/2016/09/01/the_network_config_in_centos_7/"},{"title":"使用 RESILIO SYNC + GIT 管理代码","text":"文章更新 20160907-初次成文 20161009-更新内容 为什么会有这篇文章之前一直使用git pull/push来同步代码，因为自己总在两台电脑之间来回切换，有的时候不能及时在一台电脑使用结束的时候及时 git push的话，在另外一台电脑上，就没有最新的代码了。如果结合使用Resilio Sync和Git，发现可以相对完美的解决这个问题，当然，你也可以使用百度网盘或者微云这样的文件同步工具，但是因为Resilio Sync是私有云，没有隐私泄露的风险（不是绝对的），所以还是用了这个方法。 2016年10月9日更新，后来发现这个办法的弊端，就是无法做到实时更改，比如A电脑上的FILEA.C增加了一行，那么B电脑上的同样的文件，如果那边开着电脑，并不会直接更改FILEA.C文件，而是会放到.sync目录下面去，有一个办法就是找一台闲置的机器C充当24小时开机的角色，然后A电脑更新到C上去，然后B开机，B把C上的内容同步过来。是不是感觉很蛋疼？我也觉得是。 方法方法并不难，首先搭建好Resilio Sync，把所有你需要管理的代码扔进去这个目录，然后在另外一台电脑上，添加这个共享的目录即可。经过试验，在一台电脑上建立一个新文件之后，几秒钟之后，就会出现在另外一台电脑的相应位置上。 你问我这样做有什么好处？不用记得push/pull了呗，之前甚至想使用git当云盘，但是如果编辑了超过1个GIT REPO，那么每次离开一台电脑之前，每个REPO都要PUSH，实在是影响体验。最理想的状态，还是像以前看到过的一篇文章里描述的MIT还是斯坦福大学的公共电脑，插上你的电子ID卡使用，拔掉之后，电脑锁定，然后将卡插到任何一台其他电脑上，电脑恢复到你在另外一台电脑上离开的状态。这才是我心中的理想状态，不过有使用云盘来同步代码，只要网络畅通的情况下（在目前的条件下，并不是太大的问题），所有的文件都能在几秒之中被同步，而且因为主要改变的都是代码文件，生成的那些文件，可以忽略掉，也缩短了同步的时间，提高了体验。 就像上面说的那样，如果是用来同步没有存在的照片或者电影，Resilio Sync很适合，但是对于代码这种变化非常细微的文件来说，我还是最终选择了VSCODE自带的GIT管理功能，省去了我在命令行界面下频繁的敲。说白了，又回到了GIT的路上来，现在就是每次切换到一台电脑上的时候，先点PULL，然后噼里啪啦，然后写更改理由，然后CTRL+ENTER，再然后点PUSH，这样3个步骤，就完成了代码的云端化。而且图形化界面，心理要踏实一些。 其他实时同步工具在GOOGLE上搜索的时候，发现了一个项目，名字是GUT，项目地址戳这里，从说明可以知道，这个作者就是为了方便自己在家编程的时候，可以实时同步两台开着的电脑而写的这个小项目。应该值得一些人尝试。 参考文章 BTSYNC同步所有电脑和手机","link":"/2016/09/07/codind_with_resilio_sync_and_git/"},{"title":"Linux下tar命令使用心得","text":"文章更新1.20160706-初次成文 为什么会有这篇文章linux的程序包，很多都是tar.gz2格式压缩包，不像是自己熟悉的rar或者zip，所以每次遇到这种文件的时候，都需要google下解压缩命令到底是什么。觉得找个机会，做一下总结也不错。当然了，其实每次都要看man命令，也是醉了。 基本使用其实说起来，tar并不是压缩命令，而是打包命令。使用tar程序打出来的包我们常称为tar包，tar包文件的命令通常都是以.tar结尾的。生成tar包后，就可以用其它的程序来进行压缩，比如gzip，所以才有了tar.gz2这种扩展名，表示压缩包。 参数c，压缩。tar -cf all.tar *.jpg ，这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。 参数r，追加。tar -rf all.tar *.gif，这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。 参数u，更新。tar -uf all.tar logo.gif，这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。 参数t，查看。tar -tf all.tar，这条命令是列出all.tar包中所有文件，-t是列出文件的意思。 参数x，解压缩。tar -xf all.tar，这条命令是解出all.tar包中所有文件，-x是解开的意思。 以上就是tar的最基本的用法，这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。 -z：有gzip属性的 -j：有bz2属性的 -Z：有compress属性的 -v：显示所有过程，verbose的缩写。 -O：将文件解开到标准输出 而参数-f是必须的，后面接档案名，切记，这个参数是最后一个参数，后面只能接档案名。 所以，在各种教程中常见的tar -zcvf或者tar -zxvf就是表示压缩或者解压缩一个gzip的tar包。 进阶：压缩解压缩为了方便用户在打包解包的同时可以压缩或解压文件，tar提供了一种特殊的功能。这就是tar可以在打包或解包的同时调用其它的压缩程序，比如调用gzip、bzip2等。 tar调用gzipgzip是GNU组织开发的一个压缩程序，.gz结尾的文件就是gzip压缩的结果。与gzip相对的解压程序是gunzip。tar中使用-z这个参数来调用gzip。下面来举例说明一下： tar -czf all.tar.gz *.jpg，这条命令是将所有.jpg的文件打成一个tar包，并且将其用gzip压缩，生成一个gzip压缩过的包，包名为all.tar.gz。 tar -xzf all.tar.gz，这条命令是将上面产生的包解开。 tar调用bzip2bzip2是一个压缩能力更强的压缩程序，.bz2结尾的文件就是bzip2压缩的结果。与bzip2相对的解压程序是bunzip2。tar中使用-j这个参数来调用gzip。下面来举例说明一下： tar -cjf all.tar.bz2 *.jpg，这条命令是将所有.jpg的文件打成一个tar包，并且将其用bzip2压缩，生成一个bzip2压缩过的包，包名为all.tar.bz2。 tar -xjf all.tar.bz2，这条命令是将上面产生的包解开。 tar调用compresscompress也是一个压缩程序，但是好象使用compress的人不如gzip和bzip2的人多。.Z结尾的文件就是bzip2压缩的结果。与 compress相对的解压程序是uncompress。tar中使用-Z这个参数来调用compress。下面来举例说明一下： tar -cZf all.tar.Z *.jpg，这条命令是将所有.jpg的文件打成一个tar包，并且将其用compress压缩，生成一个uncompress压缩过的包，包名为all.tar.Z。 tar -xZf all.tar.Z，这条命令是将上面产生的包解开。 实例有了上面的知识，你应该可以解开多种压缩文件了，下面对各种不同拓展名的压缩文件作一个小结： 对于.tar结尾的文件，tar -xf all.tar 对于.gz结尾的文件，gzip -d all.gz、gunzip all.gz 对于.tgz或.tar.gz结尾的文件，tar -xzf all.tar.gz、tar -xzf all.tgz 对于.bz2结尾的文件，bzip2 -d all.bz2、bunzip2 all.bz2 对于tar.bz2结尾的文件，tar -xjf all.tar.bz2、 对于.Z结尾的文件，uncompress all.Z 对于.tar.Z结尾的文件，tar -xZf all.tar.z rar和zip格式压缩包另外对于Window下的常见压缩文件.zip和.rar，Linux也有相应的解压命令或程序： 对于.ziplinux下提供了zip和unzip程序，zip是压缩程序，unzip是解压程序。它们的参数选项很多，这里只做简单介绍，依旧举例说明一下其用法： 1zip all.zip *.jpg 这条命令是将所有.jpg的文件压缩成一个zip包 unzip all.zip 这条命令是将all.zip中的所有文件解压出来 对于.rar 要在linux下处理.rar文件，需要安装RAR for Linux，可以从网上下载，但要记住，RAR for Linux 不是免费的；可从这里，下载RARfor Linux最新版本的程序。然后安装： 123tar -xzpvf rarlinux-3.2.0.tar.gz rarcd rar ./make 这样就安装好了，安装后就有了rar和unrar这两个程序，rar是压缩程序，unrar 是解压程序。它们的参数选项很多，这里只做简单介绍，依旧举例说明一下其用法： 1rar a all *.jpg 这条命令是将所有.jpg的文件压缩成一个rar包，名为all.rar，该程序会将.rar扩展名将自动附加到包名后。 1unrar e all.rar 这条命令是将all.rar中的所有文件解压出来 参考文章 linux下tar.gz、tar、bz2、zip等解压缩、压缩命令小结","link":"/2016/09/02/how_to_comprass_and_uncomprass_files_under_linux/"},{"title":"在Windows下进行PHP开发","text":"文章更新 20160415-初次成文 20160923-增加了XAMPP的配置内容 为什么会有这篇文章之前零零散散的写过2-3篇文字，终于整合到了一起 XAMPP配置注意关闭WINDOWS自带的IIS服务，这个需要打开控制面板（WIN+X，选择控制面板），依次选择程序-开启或关闭WINDOWS功能，然后把INTERNET INFORMATION SERVICE服务前面的勾勾掉，然后再启动APACHE就不会报错了。 hosts文件修改在自己机器上开发，肯定不是一个PHP网站的，所以要建立多个网站的别名访问 先到WINDOWS的安装盘，依次进入WINDOWS-SYSTEM32-DRIVERS-ETC目录，找到HOSTS文件 基本上就是这样一个路径C:\\Windows\\System32\\drivers\\etc。 添加几行 123127.0.0.1 xiaowei.com127.0.0.1 peipei.com127.0.0.1 meimei.com APACHE多域名找到你的XMAPP目录，依次进入apache-conf-extra目录，编辑httpd-vhosts.conf文件。 添加下面这样几行 123456789101112131415&lt;VirtualHost *:80&gt; ServerAdmin webmaster@dummy-host.example.com DocumentRoot &quot;D:/Sync Projects/php/peipei.com&quot; ServerName peipei.com ErrorLog &quot;logs/peipei.com-error.log&quot; CustomLog &quot;logs/peipei.com-access.log&quot; common &lt;Directory &quot;D:/Sync Projects/php/peipei.com&quot;&gt; # AllowOverride All # Deprecated # Order Allow,Deny # Deprecated # Allow from all # Deprecated # --New way of doing it Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt; 然后在xmapp目录下的htdocs目录（这个是在apache.conf文件中定义的，你网站的默认位置路径），建立和上面的peipei.com想对应的目录即可。 另外，最近还有一个地方也最好一起修改了，就是在xampp-apache-conf下的httpd.conf文件中的默认htdocs目录，也修改一下权限，将Require all deined修改为Require all granted。 然后，打开chrome浏览器，输入http://peipei.com，就可以访问你本地的虚拟目录了，很方便。 安装Visual Studio Code微软官方下载地址 下载安装后，然后设置autosave（自动保存） 英文版VSC从file-&gt;preference-&gt;user setting里，用Ctrl+F找到的”files.autoSave”: “off”, 然后粘贴到右边，粘贴为”files.autoSave”: “afterDelay”，保存，延迟时间可以自己修改。 安装PHP集成开发环境XAMPP下载地址 我自己使用的XAMPP，装在了E盘根目录下。主要是因为C盘是一个128G的SSD，空间十分吃紧。 写这个记录的时候，版本是5.6.19。 如果80端口被占用，就使用8080端口，关于XAMPP的调试和错误，我回来打算另开一个帖子记录一下，并且MAC下就不打算用XAMPP了，而是用vagrant+box的组合，装个centos和自己的云服务器配置一样，因为云服务器确实装一次挺折腾的。后话不说。 为VS Code安装php开发环境打开VSC，按ctrl+shift+p（这个快捷键和sublime的一样），输入ext install php， 我这里装的是中文版，可以直接看到安装扩展的选项。 可以看到php先关的扩展有不少，大家可以按照自己的需求安装。 我主要装了debug和format。 然后vsc提示安装成功，重启vsc便可以启用相关扩展。 添加php调试参数重启了vsc，打开一个Php,会看到vsc的一个提示。 需要在用户设置里添加一个php.validate.executablePath，让php插件可以找到php.exe的路径。 按照上面找到autosave的方式，打开用户设置，在右侧添加一句 &quot;php.validate.executablePath&quot;: &quot;E:/xampp/php/php.exe&quot; 记住如果仅有一条配置，最后一个json，不需要逗号。 不解释，直接上图。 下载xDebug从打开中，选择打开文件夹，然后切换到DEBUG模式，通过点击绿色小箭头，会弹出一个提示，让你设置xDebug的参数。这是因为vsc使用的php debug插件用到了xDebug，xDebug的下载地址和说明，见下文章节。 概念解释什么是xDebug Xdebug是一个开放源代码的PHP程序调试器(即一个Debug工具)，可以用来跟踪，调试和分析PHP程序的运行状况。Xdebug现在的最新版本是Xdebug 2.4.0RC4,release日期 2016-01-25，添加了对PHP7的支持。 所以，我们需要先花一点时间来下载和安装xDebug，下载地址，有两个版本带有Non-thread-safe和不带有Non-thread-safe，主要是看你的php版本是否线程安全版本。Windows下需要下载非线程安全的32位版本。 上图说话。 图片中第一个红框中，是按照你所安装的php.exe的版本选择，什么？你不记得你安装的php版本了？去你的集成开发环境包中看都集成的appache php和mysql分别是什么版本吧。什么？你也觉得费劲？那就来个更省事的，直接localhost/phpinfo.php来看吧，什么？你这个文件没了？那么，自己建立一个吧，什么？你不知道基本语法是什么？ 我。。。 下面是一个最基本的phpinfo()。 12345678910&lt;?php// 显示所有信息，默认显示 INFO_ALLphpinfo();// Show just the module information. 仅仅显示PHP模块信息，// phpinfo(8) 返回同样的结果。phpinfo(INFO_MODULES);?&gt; 这个文件的格式，可以参考PHP的官方说明，地址在这里。创建一个文件phpinfo.php然后把上面的内容写进去，然后放在你的localhost路径下，浏览器中打开http://localhost/phpinfo.php，就可以看到执行效果了。 可以看到自己电脑上安装的php版本号是5.6。 PHP的大版本主要分支：PHP4/PHP5/PHP7(PHP6官方没有） 其中，PHP4由于太古老、对OO支持不力已基本被淘汰，请无视PHP4。 PHP6/PHP7由于基本没有生产线上的应用，还基本只是一款概念产品，很多功能已在PHP5.3.3上实现，所以也不详述，请无视PHP6/7。 PHP5的版本主要分四支：PHP5.2之前的版本、PHP5.2.X、PHP5.3和日前发布的PHP5.4。 那我们应该如何选择适用自己项目的版本呢？ PHP5.2之前的版本不值得考虑，因为某些功能缺陷或者BUG，PHP5.2之前的版本。PHP5.4还处于Beta试用的版本号，非稳定版本，请无视PHP5.4。 主流PHP程序对PHP5.2.X的兼容性最好，而每次版本号的升级带来的都是安全性和稳定性的改善，所以宜挑选最新的版本。目前PHP5.2系列最新的是PHP5.2.17。 而如果产品是自己开发自己使用，PHP5.3在某些方面更具优势，在稳定性上更胜一筹，增加了很多PHP5.2所不具有的功能，比如内置php-fpm、更完善的垃圾回收算法、命名空间的引 入、sqlite3的支持等等，是部署项目值得考虑的版本，强烈推荐PHP5.3.29。（这是5.3 的最后一个版本) 上面这段文件是转载别人博客上的，大家参考就好。 如何选择VC9/VC11/VC14？php 7.0对应vc14，php 5.5 和 5.6 对应vc11，php 5.4对应vc9。 TS是什么意思？TS指Thread Safety，即线程安全，一般在IIS以ISAPI方式加载的时候选择这个版本。 NTS即None-Thread Safe，一般以fast cgi方式运行的时候选择这个版本，具有更好的性能。 从2000年10月20日发布的第一个Windows版的PHP3.0.17开始的都是线程安全的版本，这是由于与Linux/Unix系统是采用多进程的工作方式不同的是Windows系统是采用多线程的工作方式。如果在IIS下以CGI方式运行PHP会非常慢，这是由于CGI模式是建立在多进程的基础之上的，而非多线程。一般我们会把PHP配置成以ISAPI的方式来运行，ISAPI是多线程的方式，这样就快多了。但存在一个问题，很多常用的PHP扩展是以Linux/Unix的多进程思想来开发的，这些扩展在ISAPI的方式运行时就会出错搞垮IIS。因此在IIS下CGI模式才是 PHP运行的最安全方式，但CGI模式对于每个HTTP请求都需要重新加载和卸载整个PHP环境，其消耗是巨大的。 为了兼顾IIS下PHP的效率和安全，微软给出了FastCGI的解决方案。FastCGI可以让PHP的进程重复利用而不是每一个新的请求就重开一个进程。同时FastCGI也可以允许几个进程同时执行。这样既解决了CGI进程模式消耗太大的问题，又利用上了CGI进程模式不存在线程安全问题的优势。 因此，如果是使用ISAPI的方式来运行PHP就必须用Thread Safe(线程安全)的版本；而用FastCGI模式运行PHP的话就没有必要用线程安全检查了，用None Thread Safe(NTS，非线程安全)的版本能够更好的提高效率。 上面看完了，按照你的PHP版本，下载对应的xDebug文件，下载之后，是一个dll文件，把这个文件，复制到你的php集成开发环境的目录的位置。 我使用的XMAPP，放在了E盘，所以，我把这个dll文件复制到了e:\\xmapp\\php\\etc目录下，这个目录是Php的拓展目录。 修改php.ini在e:\\xmapp\\php目录下，找到你的php.ini文件，在文件的末尾，添加如下代码： 1234[XDebug]zend_extension = E:\\xampp\\php\\ext\\php_xdebug-2.4.0-5.6-vc11.dllxdebug.remote_enable=1xdebug.remote_autostart=1 这里，有几个需要注意的地方，先说zend_extension，如果你下载的是TS版本，这个参数需要改为zend_extension_ts。 并且，由于xDebug和Zend有冲突，所以请把zend的相关参数要注释掉。 典型就是如下几条： 123456[Zend];zend_extension_ts = &quot;C:\\Program Files\\xampp\\php\\zendOptimizer\\lib\\ZendExtensionManager.dll&quot;;zend_extension_manager.optimizer_ts = &quot;C:\\Program Files\\xampplite\\php\\zendOptimizer\\lib\\Optimizer&quot;;zend_optimizer.enable_loader = 0;zend_optimizer.optimization_level=15;zend_optimizer.license_path = 我使用的XMAPP 2015年11月12日的版本，发现上述修改在我这里是不需要的，直接添加xDebug的三行代码，保存PHP.INI，然后回到XMAPP的控制面板，把APACHE先STOP然后再START，就可以了。 如何测试呢？用浏览器打开http://localhost/phpinfo.php 如果看到配置里面，有xDebug的项目，就说明配置成功了，最简单的就是直接CTRL+F搜索XDEBUG，没有就说明失败。 我在网上学习的过程中，找到了一篇非常有参考价值的博文，里面介绍了XDEBUG官方的一种”贴心”的配置php.ini的方式，博文原文地址在这里，我这里引用其中一段即可。 再次浏览 Xdebug 官网，发现有一个贴心的服务，就是：提取用户的 phpinfo 信息，提交给 Xdebug 官网的一个程序，它立即分析 PHP 环境的信息，即刻给出下载 Xdebug 某个版本的建议。立等可取，有点意思！ 于是提交我的 phpinfo 信息，从 http://www.xdebug.org/find-binary.php 页面提交，得到提示信息： 下面用我自己返回的配置复制黏贴到上文中的官方地址。 然后就看到了官方给出的建议： 按照这个指导，圆满的完成了我的xDebug配置，真是非常贴心！这个办法，对于开发者也非常给力。 下面继续回到VSCode。 修改VSC DEBUG设置直接上图 点左侧的DEBUG按钮（虫子那个） 在绿色箭头右侧，选择LISTEN FOR XDEBUG 在右侧你的PHP的代码上，随便某一行打上个断点 点F5，会看到VSC编辑器上方，出现了熟悉的”继续”、”单步跳过”等微软风格的调试按钮。 然后，请到你的浏览器里面，输入http://localhost，或者http://127.0.0.1进行调试你在VSC中打了断点的php程序。 你会发现，浏览器直接切换回到VSC，并且停留在了你的断点位置。 GAME OVER~ 再上个图 好了，终于搞完了WINDOWS下的PHP环境搭建，有啥问题或者博客中的问题，麻烦小伙伴直接恢复吧，有问必回，下班~ 参考资料 PHP与VC对应关系、TS和NTS的区别 xDebug百度百科词条 NETBEANS官方出的XMAPP配置XDEBUG说明 这里提供了XDEBUG官方一种贴心的配置方法","link":"/2016/04/15/php_development_on_windows/"},{"title":"XAMPP在Windows平台的配置流程","text":"文章更新 20160923-初次成文 20161009-补充内容，基本完成。 为什么会有这篇文章因为自己总忘记一些最基本的东西，所以还是写个笔记吧。 安装去官方网站下载XAMPP的安装程序，链接猛戳这里，才发现原来XAMPP不单有WINDOWS版本，还有LINUX和MAC版本。 安装过程没啥说的，个人建议，最好装在硬盘的根目录下的d:\\xampp目录下。 无法启动相关服务启动APAPCHE和MYSQL，主要的问题是经常会遇到80端口被IIS占用，从而导致APACHE无法顺利启动。 表现就是点击XAMPP Control Panel程序的APACHE服务的start按钮的时候，下方状态栏会显示 1busy apache started [port 80] 解决方法1：查找占用的程序 Win+r,输入cmd，在控制台输入netstat -ano，回车 查看结果中包含xx.xx.xx.xx:80的那一行的pid，为几个数字，把这几个数字记下来； 启动任务管理器——进程，在工具栏——选择列前面的框打上勾； 然后查看与刚才那个pid对应的是哪个程序，很容易就会找到，就是它占用了80端口； 直接将其停止即可。 解决方法2：更换端口可以将apache的默认80端口修改为8081(随便其它的只要不被占用就可以了) 到xampp的安装目录下，点击进入apache\\conf下，可以看到“httpd.conf”文件，用文本编辑器打开，将所有的80修改为8081， 12Listen 8081ServerName localhost:8081 然后在XAMPP Control Panel中重新启动apache。 多域名配置hosts文件修改在自己机器上开发，肯定不是一个PHP网站的，所以要建立多个网站的别名访问 先到WINDOWS的安装盘，依次进入WINDOWS-SYSTEM32-DRIVERS-ETC目录，找到HOSTS文件 基本上就是这样一个路径C:\\Windows\\System32\\drivers\\etc。 添加几行 123127.0.0.1 xiaowei.com127.0.0.1 peipei.com127.0.0.1 meimei.com APACHE多域名找到你的XMAPP目录，依次进入apache-conf-extra目录，编辑httpd-vhosts.conf文件。 添加下面这样几行 1234567891011121314151617181920212223&lt;VirtualHost *:80&gt; ServerAdmin webmaster@dummy-host.example.com DocumentRoot &quot;E:/xampp/htdocs/peipei.com&quot; ServerName peipei.com ErrorLog &quot;logs/peipei.com-error.log&quot; CustomLog &quot;logs/peipei.com-access.log&quot; common&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt; ServerAdmin webmaster@dummy-host2.example.com DocumentRoot &quot;E:/xampp/htdocs/xiaowei.com&quot; ServerName xiaowei.com ErrorLog &quot;logs/xiaowei.com-error.log&quot; CustomLog &quot;logs/xiaowei.com-access.log&quot; common&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt; ServerAdmin webmaster@dummy-host2.example.com DocumentRoot &quot;E:/xampp/htdocs/meimei.com&quot; ServerName meimei.com ErrorLog &quot;logs/meimei.com-error.log&quot; CustomLog &quot;logs/meimei.com-access.log&quot; common&lt;/VirtualHost&gt; 写完才发现，其实有很大一部分内容，和我的另外一个帖子《在Windows下进行PHP开发》内容是重复的，怎么办呢？就这样招吧，谁让重复就是力量呢。","link":"/2016/09/23/the_note_of_config_xampp_on_windows_10/"},{"title":"使用COW以便让IE和EDGE支持SOCKSS代理","text":"文章更新 201609012-初次成文1 为什么会有这篇文章突然想用GOOGLE PHOTOS，下载了GOOGLE PHOTOS BACKUP，但是却发现无法登录。经过搜索发现，GOOGLE PHOTO使用的IE或者EDGE的代理通道，也就是说，如果IE无法翻墙，那么GOOGLE PHOTOS就用不了。我使用的是SHADOW SOCKS QT5的版本，在使用SHADOWS SOCKS代理的时候，只能在HTTP和SOCKS5两者二选一，如果选了HTTP，那么在CHROME下使用HTTP没有SOCKS5那么流畅，所以需要寻找一种方式，让IE和EDGE走HTTP，让CHROME继续使用SOCKS5通道，两全其美。而COW就是这个完美的解决方案。 如何使用COW需要准备的 shadow socks服务器，我是在搬瓦工处购买的20刀一年的服务器，一个月500G流量，足够用了。 cow客户端，下载地址https://github.com/cyfdecyf/cow cow的设置windows版本，配置文件是那个rc.txt，我曾经也觉得奇怪，确实有点奇葩的配置文件名字，竟然是txt的扩展名。 rc.txt就需要两句，其他都没用。 12listen = http://127.0.0.1:7777 proxy = ss://aes-256-cfb:PASSWORD@ss_server_ip.com:8388 Windows IE和EDGE的选项设置连接选项卡 -&gt; 局域网设置 -&gt; 勾选了(自动检测设置，使用自动配置脚本: http://127.0.0.1:7777/pac) -&gt; 为LAN使用代理服务器 -&gt; 高级 -&gt; (HTTP/安全 127.0.0.1 : 7777) 然后，IE和EDGE就可以翻墙了，GAME OVER。 参考文章 cow 到底怎么用的？ COW项目地址","link":"/2016/09/13/use_cow_under_windows_10_to_make_ie_and_edge_to_support_socks5/"},{"title":"thinkphp学习笔记","text":"文章更新 20160923-初次成文 为什么会有这篇文章没啥可说的. 安装我主要是利用了小微OA的程序来当做目标，放在了自己htdocs下xiaowei.com来当做目录，项目官方网址是小微OA，下载地址是https://git.oschina.net/smeoa/xiaowei.git，直接`git clone https://git.oschina.net/smeoa/xiaowei.git xiaowei.com`即可。 THINKPHP 3.23基本文件下载地址，点开就自动下载了，我放在了peipei.com目录下，教程主要参考了THINKPHP官方的3.23快速入门，地址。 关闭MYSQL数据库的严格模式1SET @@GLOBAL.sql_mode=\"NO_AUTO_Create_USER,NO_ENGINE_SUBSTITUTION\"; URL-MODE的影响这个发现还是挺重要的，比如小微OA使用的URL_MODE=1，同样的文件结构，如果使用0的话，就无法正确访问。 心得小微OA的Controller和Model两个模块，都复用了各自的基类，比如VIEW是复用了HomeController类，而Model则是复用了CommonModel类。 写法也比较典型 基本的Controller类，名字是HomeController.class.php， 12345678&lt;?phpnamespace Home\\Controller;use Think\\Controller;class HomeController extends Controller{ ...}?&gt; 其他复用类，就会从这个HomeController派生出来，比如IndexControoler.class.php 1234567&lt;?phpnamespace Home\\Controller;class IndexController extends HomeController{ ...}?&gt; 需要注意的是，派生出来的Controller，不再有use Think\\Controller这句话 遇到的一些错误非法操作:login1234567891011错误位置FILE: /Users/wangyi/BitTorrent Sync/Sync Gits/php/peipei.com/ThinkPHP/Library/Think/Controller.class.php LINE: 170TRACE\\#0 /Users/wangyi/BitTorrent Sync/Sync Gits/php/peipei.com/ThinkPHP/Library/Think/Controller.class.php(170): E('\\xE9\\x9D\\x9E\\xE6\\xB3\\x95\\xE6\\x93\\x8D\\xE4\\xBD\\x9C:lo...')\\#1 [internal function]: Think\\Controller-&gt;__call('login', '')\\#2 /Users/wangyi/BitTorrent Sync/Sync Gits/php/peipei.com/ThinkPHP/Library/Think/App.class.php(114): ReflectionMethod-&gt;invokeArgs(Object(Home\\Controller\\PublicController), Array)\\#3 /Users/wangyi/BitTorrent Sync/Sync Gits/php/peipei.com/ThinkPHP/Library/Think/App.class.php(204): Think\\App::exec()\\#4 /Users/wangyi/BitTorrent Sync/Sync Gits/php/peipei.com/ThinkPHP/Library/Think/Think.class.php(120): Think\\App::run()\\#5 /Users/wangyi/BitTorrent Sync/Sync Gits/php/peipei.com/ThinkPHP/ThinkPHP.php(97): Think\\Think::start()\\#6 /Users/wangyi/BitTorrent Sync/Sync Gits/php/peipei.com/index.php(27): require('/Users/wangyi/B...')\\#7 {main} 解决办法 检查 ThinkPHP/Library/Think/Cache 目录下，是否存在Driver目录，我下载的3.23版本的THINKPHP这个目录下没有对应的缓存类型文件，奇怪。 参考文章1.2.","link":"/2016/09/23/study_note_of_thinkphp/"},{"title":"斗鱼弹幕获取程序C#.NET CORE版本","text":"文章更新 20160919-初次成文 为什么会有这篇文章之前有一阵子对斗鱼的弹幕比较感兴趣，就参考网上其他大神的办法，用C#实现了一个控制台程序，很简陋，但是效果很不错，有需要的可以拿去扩展功能。我最希望的就是实现登录功能，比如和用户的反馈，程序可以自动根据用户发送的消息进行反馈，比如输入 签到，程序就会说一句‘xxx签到成功，金钱增加10’这样的。不过这样看来，和QQ群内的程序也是一个思路。 直接上代码之前是基于.net 4.5写的，因为最近在学习.net core，所以就改写了一下，这样在pc或者mac下都可以用了，甚至在linux也可以做成一个服务让它24小时的跑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361using System;using System.Collections.Generic;using System.Linq;using System.Net;using System.Net.Sockets;using System.Security.Cryptography;using System.Text;using System.Text.RegularExpressions;using System.Threading;using System.Threading.Tasks;namespace ConsoleApp1{ public class Program { public static string strDanmuUrl = \"danmu.douyutv.com\"; public static int intPort = 8602; public static int intRoomID = 105025; public DateTime dtStart = DateTime.Now.ToLocalTime(); static Socket newClient = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); public static void Main(string[] args) { byte[] byteData = new byte[1024]; var strIpAddress = GetIPbyNameAsync(strDanmuUrl); var ie = new IPEndPoint(IPAddress.Parse(strIpAddress.Result), intPort); try { newClient.Connect(ie); } catch (SocketException e1) { Console.WriteLine(\"Can not connect to Internet, the Error is {0}.\", e1.ToString()); return; } string strMsg2Send = string.Format(\"type@=loginreq/username@={0}/password@={1}/roomid@={2}/\", \"visitor5585580\", \"1234567890123456\", intRoomID); //把字符串转变为byte array. byte[] byteSend = ProcessString(strMsg2Send); //把登录字符串(bytes)发送给服务器. newClient.Send(byteSend, byteSend.Length, 0); //从服务器接收到的bytes. byte[] byteRecvive = new byte[1024]; newClient.Receive(byteRecvive, byteRecvive.Length, 0); //将byte array转变成string. string strReceive = Encoding.UTF8.GetString(byteRecvive, 0, byteRecvive.Length); Console.OutputEncoding = Encoding.UTF8; Console.WriteLine(\"The message received from Douyu service is {0}\", strReceive); Console.WriteLine(); int intGid = GetGid(); string strSend2 = string.Format(\"type@=joingroup/rid@={0}/gid@={1}/\", intRoomID, intGid); byte[] byteSend2 = ProcessString(strSend2); newClient.Send(byteSend2, byteSend2.Length, 0); Thread keepLiveThread = new Thread(new ThreadStart(KeepLiveThread)); keepLiveThread.IsBackground = true; keepLiveThread.Start(); DateTime dtBegin = DateTime.Now.ToLocalTime(); while (true) { byte[] byteReceive2 = new byte[1024]; newClient.Receive(byteReceive2, byteReceive2.Length, 0); string strReceivce2 = Encoding.UTF8.GetString(byteReceive2, 12, byteReceive2.Length - 12); string strDanmu = ProcessAndShowDanmu(strReceivce2); LogAppend(strDanmu); } } private static void LogAppend(string strDanmu) { Console.OutputEncoding = System.Text.Encoding.UTF8; Console.WriteLine(\"\\n\"); Console.WriteLine(strDanmu); Console.WriteLine(\"\\n\"); } private static string ProcessAndShowDanmu(string strRecv) { if (strRecv.IndexOf(\"type@=\") == -1) { Console.WriteLine(strRecv); Console.WriteLine(\"无效信息\"); } else if (strRecv.IndexOf(\"type@=error\") &gt; 0) { Console.WriteLine(strRecv); Console.WriteLine(\"错误信息，可能认证失败\"); } else { strRecv = strRecv.Replace(\"@S\", \"/\").Replace(\"@A=\", \":\").Replace(\"@=\", \":\"); Console.WriteLine(strRecv); string msg_type_zh = \"\"; try { Match m = Regex.Match(strRecv, \"type:(.+?)\\\\/\"); if (m.Groups[1].Value == \"chatmessage\") { msg_type_zh = \"弹幕消息\"; Match m2 = Regex.Match(strRecv, \"\\\\/sender:(.+?)\\\\/\"); string sender_id = m2.Groups[1].Value; Match m3 = Regex.Match(strRecv, \"\\\\/snick:(.+?)\\\\/\"); string nickname = m3.Groups[1].Value; Match m4 = Regex.Match(strRecv, \"\\\\/content:(.+?)\\\\/\"); string content = m4.Groups[1].Value; Match m5 = Regex.Match(strRecv, \"\\\\/strength:(.+?)\\\\/\"); string strength = m5.Groups[1].Value; Match m6 = Regex.Match(strRecv, \"\\\\/level:(.+?)\\\\/\"); string level = m6.Groups[1].Value; DateTime dt = DateTime.Now; string datetime = dt.ToString(\"yyyy-MM-dd HH:mm:ss\"); String strContent = \"|\" + msg_type_zh + \"| \" + align_left_str(nickname, 20, ' ') + align_left_str(\"&lt;Lv:\" + level + \"&gt;\", 8, ' ') + align_left_str(\"(\" + sender_id + \")\", 13, ' ') + align_left_str(\"[\" + strength + \"]\", 10, ' ') + \"@ \" + datetime + \": \" + content + ' '; return strContent; } else if (m.Groups[1].Value == \"userenter\") { msg_type_zh = \"入房消息\"; Match m2 = Regex.Match(strRecv, \"\\\\/userinfo:id:(.+?)\\\\/\"); string user_id = m2.Groups[1].Value; Match m3 = Regex.Match(strRecv, \"\\\\/nick:(.+?)\\\\/\"); string nickname = m3.Groups[1].Value; Match m4 = Regex.Match(strRecv, \"\\\\/strength:(.+?)\\\\/\"); string strength = m4.Groups[1].Value; Match m5 = Regex.Match(strRecv, \"\\\\/level:(.+?)\\\\/\"); string level = m5.Groups[1].Value; DateTime dt = DateTime.Now; string datetime = dt.ToString(\"yyyy-MM-dd HH:mm:ss\"); String strContent = \"|\" + msg_type_zh + \"| \" + align_left_str(nickname, 20, ' ') + align_left_str(\"&lt;Lv:\" + level + \"&gt;\", 8, ' ') + align_left_str(\"(\" + user_id + \")\", 13, ' ') + align_left_str(\"[\" + strength + \"]\", 10, ' ') + \"@ \" + datetime; return strContent; } else if (m.Groups[1].Value == \"dgn\") { msg_type_zh = \"鱼丸赠送\"; Match m2 = Regex.Match(strRecv, \"\\\\/level:(\\\\d+?)\\\\/\"); string level = m2.Groups[1].Value; Match m3 = Regex.Match(strRecv, \"\\\\/sid:(.+?)\\\\/\"); string user_id = m3.Groups[1].Value; Match m4 = Regex.Match(strRecv, \"\\\\/src_ncnm:(.+?)\\\\/\"); string nickname = m4.Groups[1].Value; Match m5 = Regex.Match(strRecv, \"\\\\/hits:(.+?)\\\\/\"); string hits = m5.Groups[1].Value; DateTime dt = DateTime.Now; string datetime = dt.ToString(\"yyyy-MM-dd HH:mm:ss\"); String strContent = \"|\" + msg_type_zh + \"| \" + align_left_str(nickname, 20, ' ') + align_left_str(\"&lt;Lv:\" + level + \"&gt;\", 8, ' ') + align_left_str(\"(\" + user_id + \")\", 13, ' ') + align_left_str(\"[unknown]\", 10, ' ') + \"@ \" + datetime + \": \" + hits + \" hits \"; return strContent; } else { msg_type_zh = \"未知类型\"; String strContent = \"|\" + msg_type_zh + \"| \" + strRecv; return strContent; } } catch (Exception e) { Console.WriteLine(e.ToString()); } //finally //{ // Console.WriteLine(\"|该句异常| \" + strRecv); //} } return \"空\"; } private static string align_left_str(string raw_str, int max_length, char filled_chr) { int my_length = 0; foreach (char c in raw_str) { if (Convert.ToInt32(c) &gt; 127 || Convert.ToInt32(c) &lt; 0) { my_length++; } } if ((max_length - my_length) &gt; 0) { return raw_str + filled_chr * (max_length - my_length); } else { return raw_str; } } private static void KeepLiveThread() { while (true) { Thread.Sleep(40000); TimeSpan ts = DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, 0); //string strKeepAlive = string.Format(\"type@=mrkl/\"); string strKeepAlive = string.Format(\"type@=keeplive/tick@={0}/\", Convert.ToInt64(ts.TotalSeconds)); byte[] bytesSend = ProcessString(strKeepAlive); newClient.Send(bytesSend, bytesSend.Length, 0); } } private static int GetGid() { string ipadd2 = \"119.90.49.107\"; var port2 = 8034; var newclient2 = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); var ie2 = new IPEndPoint(IPAddress.Parse(ipadd2), port2); newclient2.Connect(ie2); string devid = System.Guid.NewGuid().ToString().Replace(\"-\", \"\").ToUpper(); string rt = (DateTimeHelperClass.CurrentUnixTimeMillis() / 1000).ToString(); string ver = \"20150526\"; string magic = \"7oE9nPEG9xXV69phU31FYCLUagKeYtsF\"; byte[] result = Encoding.UTF8.GetBytes(rt + magic + devid); //MD5 md5 = new MD5CryptoServiceProvider() string tmpoutput; using (var md5 = MD5.Create()) { var result2 = md5.ComputeHash(result); tmpoutput = BitConverter.ToString(result2).Replace(\"-\", \"\"); } string vk = tmpoutput; string strGetGid = string.Format(\"type@=loginreq/username@=/ct@=2/password@=/roomid@=\" + intRoomID + \"/devid@=\" + devid + \"/rt@=\" + rt + \"/vk@=\" + vk + \"/ver@=\" + ver + \"/\"); byte[] bytesSend = ProcessString(strGetGid); newclient2.Send(bytesSend, bytesSend.Length, 0); byte[] data = new byte[1024]; //下面这个地方有点tricky，从wireshark里发现的，第一条返回数据没啥用，第二条里面才有gid数据 var bytesRecv3 = newclient2.Receive(data, data.Length, 0); var bytesRecv3_2 = newclient2.Receive(data, data.Length, 0); string strRecv = Encoding.UTF8.GetString(data, 0, bytesRecv3_2); Console.WriteLine(\"接受到的数据\" + strRecv); int gid = getValueByName(strRecv); Console.WriteLine(\"从服务器({0})断开连接\", ipadd2); byte[] bytesSend2 = loginReq(\"\", \"\", \"510792\"); newclient2.Send(bytesSend2, bytesSend2.Length, 0); newclient2.Shutdown(SocketShutdown.Both); newclient2.Dispose(); return gid; } private static byte[] loginReq(string username, string password, string roomid) { string uuid = System.Guid.NewGuid().ToString().Replace(\"-\", \"\").ToUpper(); TimeSpan ts = DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, 0); long time = Convert.ToInt64(ts.TotalSeconds); string salt = \"7oE9nPEG9xXV69phU31FYCLUagKeYtsF\"; string vkTmp = string.Format(\"{0}{1}{2}\", time, salt, uuid); byte[] result = Encoding.UTF8.GetBytes(vkTmp); string tmpoutput; using (var md5 = MD5.Create()) { var result2 = md5.ComputeHash(result); tmpoutput = BitConverter.ToString(result2).Replace(\"-\", \"\"); } string vk = tmpoutput; string p = string.Format(\"type@=loginreq/username@={0}/password@={1}/roomid@={2}/ct@=2/devid@={3}/ver@={4}/rt@={5}/vk@={6}/\", username, password, roomid, uuid, 20150515, time, vk); byte[] bteAry0 = Encoding.UTF8.GetBytes(p); byte[] bteAry1 = Encoding.UTF8.GetBytes(\"dc000000 dc000000 b1020000 \"); byte[] buf = new byte[bteAry0.Length + bteAry1.Length]; bteAry0.CopyTo(buf, 0); bteAry1.CopyTo(buf, bteAry0.Length); //后面第二个参数，是里面已经存在的byte[]的长度 //buf.Put(0); return buf; } private static int getValueByName(string strRecv) { int gid = 0; if (strRecv.IndexOf(\"type@=\") == -1) { Console.WriteLine(strRecv); Console.WriteLine(\"无效信息\"); } else if (strRecv.IndexOf(\"type@=error\") &gt; 0) { Console.WriteLine(strRecv); Console.WriteLine(\"错误信息，可能认证失败\"); } else if (strRecv.IndexOf(\"type@=mrkl\") &gt; 0) { Console.WriteLine(strRecv); Console.WriteLine(\"服务器接收到了心跳数据\"); } else { strRecv = strRecv.Replace(\"@S\", \"/\").Replace(\"@A=\", \":\").Replace(\"@=\", \":\"); try { Match m2 = Regex.Match(strRecv, \"\\\\/gid:(.+?)\\\\/\"); gid = Convert.ToInt16(m2.Groups[1].Value.ToString()); Console.WriteLine(gid); } catch { } return gid; } return 0; } private static byte[] ProcessString(string strMsg2Send) { string msgToPro = new string(new char[1024]); msgToPro = strMsg2Send; int i = msgToPro.Length + 1 + 8; byte[] bytes1 = BitConverter.GetBytes(i); byte[] bs = Encoding.ASCII.GetBytes(msgToPro); byte[] bytes2 = new byte[] { 0xb1, 0x02, 0x00, 0x00 }; byte[] bytes3 = new byte[] { 0x00 }; byte[] resArr = new byte[bytes1.Length + bytes1.Length + bytes2.Length + bs.Length + bytes3.Length]; bytes1.CopyTo(resArr, 0); bytes1.CopyTo(resArr, bytes1.Length); bytes2.CopyTo(resArr, bytes1.Length + bytes1.Length); bs.CopyTo(resArr, bytes1.Length + bytes1.Length + bytes2.Length); bytes3.CopyTo(resArr, bytes1.Length + bytes1.Length + bytes2.Length + bs.Length); return resArr; } private static async Task&lt;string&gt; GetIPbyNameAsync(string s) { IPAddress[] host = await Dns.GetHostAddressesAsync(s); return await Task.FromResult(host[0].ToString()); } } internal static class DateTimeHelperClass { private static readonly System.DateTime Jan1st1970 = new System.DateTime(1970, 1, 1, 0, 0, 0, System.DateTimeKind.Utc); internal static long CurrentUnixTimeMillis() { return (long)(System.DateTime.UtcNow - Jan1st1970).TotalMilliseconds; } }} 没啥多说的，有空继续改进吧，最近在想怎么获取QQ群内的聊天，并且保存起来晚上有空看看大家聊了什么有营养的话题，当然了，感觉基本上都是老司机在扯淡，不过净化还是有的。 参考文章","link":"/2016/09/19/crawl_the_douyu_danmu_by_c_sharp_program/"},{"title":"mac上的ln命令","text":"文章更新 20170218-初次成文 为什么会有这篇文章最近发现对ln命令有一点困惑，所以赶紧总结一下。 先说主要的，ln干嘛的ln是linux系统中一个重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。 命令格式1ln [参数] [源文件或目录] [目标文件或目录] 命令功能Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种：硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。 软链接 软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式 软链接可以 跨文件系统 ，硬链接不可以 软链接可以对一个不存在的文件名进行链接 软链接可以对目录进行链接 硬链接 硬链接，以文件副本的形式存在。但不占用实际空间。 不允许给目录创建硬链接(root可以创建软链接？) 硬链接只有在同一个文件系统中才能创建 图例表明两者的区别 这里有两点要注意： ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化； ln的软链接只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接 ln 源文件 目标文件，没有参数-s，它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。 如果原始文件改名或者移动位置，则软链接失效，硬链接则继续发挥作用；如果源文件被删除，软连接无效，而硬链接继续发挥作用，这是因为硬链接是将源文件的副本手动写入了inode。 ln指令用在链接文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件或目录，且最后的目的地并非是一个已存在的目录，则会出现错误信息。 命令参数必要参数 -b 删除，覆盖以前建立的链接 -d 允许超级用户制作目录的硬链接 -f 强制执行 -i 交互模式，文件存在则提示用户是否覆盖 -n 把符号链接视为一般目录 -s 软链接(符号链接) -v 显示详细的处理过程 选择参数 -S “-S&lt;字尾备份字符串&gt;“ 或 “--suffix=&lt;字尾备份字符串&gt;“ -V “-V&lt;备份方式&gt;“或”--version-control=&lt;备份方式&gt;“ --help 显示帮助信息 --version 显示版本信息 使用实例实例0：整体说明先建立两个文件 12$ touch blah1 $ touch blah2 分别给两个文件输入一些数据： 12$ echo \"Cat\" &gt; blah1$ echo \"Dog\" &gt; blah2 可以预见： 123$cat blah1; cat blah2CatDog 然后我们分别为两个文件建立 硬链接 和 软链接： 12$ ln blah1 blah1-hard$ ln -s blah2 blah2-soft 看看分别发生了什么： 1$ ls -l 显示结果 1234blah1blah1-hardblah2blah2-soft -&gt; blah2 改变blash1文件的名字，并不会影响链接的结果： 123$ mv blah1 blah1-new$ cat blah1-hardCat blah1-hard文件指向了inode，因此文件内容并不会发生改变。然后我们在看看如果把blah2改名为blah2-new，会发生什么 12345$ mv blah2 blah2-new$ ls blah2-softblah2-soft$ cat blah2-soft cat: blah2-soft: No such file or directory 因为软链接指向的是文件名，即便只改变文件名，而不是内容，blah2-soft也无法显示内容。 相似的，即便blah1文件被删掉，blah1-hard依然会保有blah1的内容。 但是如果blah2文件被删除了，blah2-soft则指向(软链接)到了一个并不存在的文件上。 实例1：给文件创建软链接命令： 1ln -s log2013.log link2013 输出： 123456[root@localhost test]# ll-rw-r--r-- 1 root bin 61 11-13 06:03 log2013.log[root@localhost test]# ln -s log2013.log link2013[root@localhost test]# lllrwxrwxrwx 1 root root 11 12-07 16:01 link2013 -&gt; log2013.log-rw-r--r-- 1 root bin 61 11-13 06:03 log2013.log 说明：为log2013.log文件创建软链接link2013，如果log2013.log丢失，link2013将失效 实例2：给文件创建硬链接命令： 1ln log2013.log ln2013 输出： 12345678[root@localhost test]# lllrwxrwxrwx 1 root root 11 12-07 16:01 link2013 -&gt; log2013.log-rw-r--r-- 1 root bin 61 11-13 06:03 log2013.log[root@localhost test]# ln log2013.log ln2013[root@localhost test]# lllrwxrwxrwx 1 root root 11 12-07 16:01 link2013 -&gt; log2013.log-rw-r--r-- 2 root bin 61 11-13 06:03 ln2013-rw-r--r-- 2 root bin 61 11-13 06:03 log2013.log 说明：为log2013.log创建硬链接ln2013，log2013.log与ln2013的各项属性相同 实例3：接上面两实例，链接完毕后，删除和重建链接原文件命令： 输出： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647[root@localhost test]# lllrwxrwxrwx 1 root root 11 12-07 16:01 link2013 -&gt; log2013.log-rw-r--r-- 2 root bin 61 11-13 06:03 ln2013-rw-r--r-- 2 root bin 61 11-13 06:03 log2013.log[root@localhost test]# rm -rf log2013.log [root@localhost test]# lllrwxrwxrwx 1 root root 11 12-07 16:01 link2013 -&gt; log2013.log-rw-r--r-- 1 root bin 61 11-13 06:03 ln2013[root@localhost test]# touch log2013.log[root@localhost test]# lllrwxrwxrwx 1 root root 11 12-07 16:01 link2013 -&gt; log2013.log-rw-r--r-- 1 root bin 61 11-13 06:03 ln2013---xrw-r-- 1 root bin 302108 11-13 06:03 log2012.log-rw-r--r-- 1 root root 0 12-07 16:19 log2013.log[root@localhost test]# vi log2013.log 2013-012013-022013-032013-042013-052013-062013-072013-082013-092013-102013-112013-12[root@localhost test]# lllrwxrwxrwx 1 root root 11 12-07 16:01 link2013 -&gt; log2013.log-rw-r--r-- 1 root bin 61 11-13 06:03 ln2013-rw-r--r-- 1 root root 96 12-07 16:21 log2013.log[root@localhost test]# cat link2013 2013-012013-022013-032013-042013-052013-062013-072013-082013-092013-102013-112013-12[root@localhost test]# cat ln2013 hostnamebaidu=baidu.comhostnamesina=sina.comhostnames=true 说明： 源文件被删除后，并没有影响硬链接文件；软链接文件在centos系统下不断的闪烁，提示源文件已经不存在 重建源文件后，软链接不在闪烁提示，说明已经链接成功，找到了链接文件系统；重建后，硬链接文件并没有受到源文件影响，硬链接文件的内容还是保留了删除前源文件的内容，说明硬链接已经失效 实例4：将文件链接为另一个目录中的相同名字命令： 1ln log2013.log test3 输出： 1234567891011121314151617181920212223242526[root@localhost test]# ln log2013.log test3[root@localhost test]# lllrwxrwxrwx 1 root root 11 12-07 16:01 link2013 -&gt; log2013.log-rw-r--r-- 1 root bin 61 11-13 06:03 ln2013-rw-r--r-- 2 root root 96 12-07 16:21 log2013.log[root@localhost test]# cd test3[root@localhost test3]# ll-rw-r--r-- 2 root root 96 12-07 16:21 log2013.log[root@localhost test3]# vi log2013.log 2013-012013-022013-032013-042013-052013-062013-072013-082013-092013-10[root@localhost test3]# ll-rw-r--r-- 2 root root 80 12-07 16:36 log2013.log[root@localhost test3]# cd ..[root@localhost test]# lllrwxrwxrwx 1 root root 11 12-07 16:01 link2013 -&gt; log2013.log-rw-r--r-- 1 root bin 61 11-13 06:03 ln2013-rw-r--r-- 2 root root 80 12-07 16:36 log2013.log[root@localhost test]# 说明：在test3目录中创建了log2013.log的硬链接，修改test3目录中的log2013.log文件，同时也会同步到源文件 实例5：给目录创建软链接命令： 1ln -sv /opt/soft/test/test3 /opt/soft/test/test5 输出： 123456789101112131415161718192021222324252627282930[root@localhost test]# lldrwxr-xr-x 2 root root 4096 12-07 16:36 test3drwxr-xr-x 2 root root 4096 12-07 16:57 test5[root@localhost test]# cd test5[root@localhost test5]# lllrwxrwxrwx 1 root root 5 12-07 16:57 test3 -&gt; test3[root@localhost test5]# cd test3-bash: cd: test3: 符号连接的层数过多[root@localhost test5]# [root@localhost test5]# [root@localhost test5]# lllrwxrwxrwx 1 root root 5 12-07 16:57 test3 -&gt; test3[root@localhost test5]# rm -rf test3[root@localhost test5]# ll[root@localhost test5]# ln -sv /opt/soft/test/test3 /opt/soft/test/test5创建指向“/opt/soft/test/test3”的符号链接“/opt/soft/test/test5/test3”[root@localhost test5]# lllrwxrwxrwx 1 root root 20 12-07 16:59 test3 -&gt; /opt/soft/test/test3[root@localhost test5]# [root@localhost test5]# cd test3[root@localhost test3]# ll总计 4-rw-r--r-- 2 root root 80 12-07 16:36 log2013.log[root@localhost test3]# touch log2014.log[root@localhost test3]# ll总计 4-rw-r--r-- 2 root root 80 12-07 16:36 log2013.log-rw-r--r-- 1 root root 0 12-07 17:05 log2014.log[root@localhost test3]# cd ..[root@localhost test5]# cd .. 说明： 目录只能创建软链接 目录创建链接必须用绝对路径，相对路径创建会不成功，会提示：符号连接的层数过多 这样的错误 在链接目标目录中修改文件都会在源文件目录中同步变化 参考文章 每天一个linux命令（35）：ln 命令 What is the difference between a hard link and a symbolic link?","link":"/2017/02/18/symlink_on_mac_os/"},{"title":"hexo建站完整步骤","text":"文章更新 20161021-初次成文 20170804-文章终结 为什么会有这篇文章在另外一篇帖子里，内容和这个基本重复了，传送门请戳这里。突然发现，自己竟然没有一个比较完整的步骤，那么就大概写一遍吧。 环境安装需要预先好Git和Node.JS Windows 环境下，安装 git for windows和 node.js MAC OS环境下，安装Homebrew，并使用brew命令安装Node.js和NPM，方法参考这里 全局安装hexo的命令航工具hexo-cli 1npm install -g hexo-cli #全局安装，其实这个npm的-g和-save参数我还是不是很明白，解释可以看下文。 目前我个人对-g和--save的理解还比较粗浅，比如对Hexo-cli这种包，应该使用-g让npm将hexo安装到全局，以便你可以在任何目录下都使用hexo init来初始化一个hexo的项目，而对于--save则是将让npm将这个包安装到当前项目下，以便当期项目可以使用这个包，比如hexo-deployer-git这样的包就需要使用--save参数。 初始化项目这里使用blog作为项目名 1hexo init blog 如果已经在blog目录下面了，直接使用’hexo init’命令即可。 运行hexo12cd bloghexo server 查看 http://localhost:4000/ 可以浏览到hexo初始化的默认体博客 Coding.net上创建项目在Coding.net上创建两个项目，一个私有的项目用来存放Hexo的源文件(markdown格式)，另外一个公开项目，用来存放展示的html文件。 需要注意的是，用来公开展示的项目名称需要和你的账户名一致。 将本地的hexo代码上传到Coding.net首先使用git remote -v查看目前的远程仓库推送和拉取方式 如果返回值为空，说明你的.git/config文件缺少 [remote &quot;origin&quot;] 内容，需要使用下列的命令进行添加 12git config branch.master.remote origingit config branch.master.merge refs/heads/master 这样就有了内容，如果你发现git remote -v返回的是https方式，那么需要修改为git方式 从https修改为git方式 1git remote set-url origin git@git.coding.net:tinyvane/hexo.git 这样再次运行git pull/push就不会再要你输入密码了。 也可以通过下面的命令，从git方式修改为https方式 1git remote set-url origin https://git.coding.net/tinyvane/hexo.git Pages服务有个特点, 如果项目名和用户名一样. 就可以使用 username.coding.me 访问发布的网站, 否则则是 username.coding.me/projectname 开启Pages服务进入项目页面的Pages服务那一栏，立即开启. 默认使用了coding-pages的branch 绑定ssh证书首先要在本地生成ssh证书，ssh-keygen -t rsa -C &quot;you@youremail.com&quot;，把证书的公钥(~/.ssh/id_rsa.pub)的内容拷贝到coding个人账户下的SSH公钥里面 配置hexo的deploy方式在hexo目录（本文是blog）下面找到_config.yml，在文件末尾加上deploy到coding的配置 1234deploy: type: git repo: coding: git@git.coding.net:username/projectname.git,coding-pages 注意coding.net的配置是 coding:{项目git地址},{branch} 生成静态文件1hexo g 由于coding.net的Pages服务是默认执行jekyll项目, 静态项目需要一个.nojekyll文件标识. 所以第一次执行, 需要在生成的public文件夹中加入一个 .nojekyll 空白文件 部署命令1hexo d 就可以发布成功了 访问hexo默认访问地址是username.coding.me或者username.coding.me/projectname 后面每次更新博客的时候, 就只需要重复上面的命令hexo g &amp;&amp; hexo d就可以立刻发布 查看实例 http://www.wuliaole.com 参考文章 http://www.jianshu.com/p/f104e6b7c0c5","link":"/2016/10/21/use_hexo_to_create_a_blog/"},{"title":"LaunchAgents与LaunchDaemon","text":"文章更新 20170218-初次成文 为什么会有这篇文章在MAC OSX上使用Homebrew安装过程中，多次涉及到launchctl的使用，每个服务存放的位置不同，有的放在了Library/LaunchDaemon下，有的放在了Library/LaunchAgents下，所以有点困惑，就想着把区别弄明白。所以做了一些研究。 什么是 launchd ?Mac OS X 从 10.4 开始，採用 launchd 来管理整个系统的服务和进程。传统的 UNIX 系统会使用 /etc/rc.* 或其他的机制来管理开机时要启动的启动服务，而从Mac OS X 10.4开始使用 launchd 来管理，它的启动服务，分别叫做 Launch Daemon 和 Launch Agents。而视为服务程序，一般应该是后台进程，一般不提供GUI，也不应该跳到控制台的前台来(当然有些例外)。 launchd 管理的后台进程主要有四种，分别是： Launch Daemon: 在开机时载入 (load) 。 Launch Agent: 在使用者登入时载入。 XPC Service: 好像是 10.7 才有的，我还没灌 10.7 ，先跳过。 Login Items: 在 User 登入时执行。有两种方法可以用程式新增项目到 Login Item： Shared File List：会出现在 Account 偏好设定的 Login Item 清单。 Service Management Framework：这个就不会出现在 Login Item 清单。 （以下把重点放在 Launch Daemon / Agent 。至于 XPC 和 Login Item 就留待其他比较在行的大大来解释。） Launch Daemon &amp; Launch AgentLaunch Daemon 和 Launch Agent 是同一种东西在不同范围下的异名。Launch Daemon 是系统级别的服务 ，称为 daemon，Launch Agent 是用户级别的服务，称为 Agent，前者在开机时会载入（load），后者在使用者登入时（才）会载入。 如果你打开活动监视器，并在显示选项中，切换到所有进程，分层显示 ，你会发现有个 kernel_task 会在最上层，下层紧跟着 launchd ，它下面有很多子进程的拥有者都是 root 。很多时候，还会有一个相同级别的 launchd ，启动用户正是你自己，它底下的子进程的用户也几乎都是你自己。前者所包含的这些子进程，由 root 执行的称为 Launch Daemons ，后者由使用者(你)执行的称为 Launch Agents 。 两个 launchd 分别由各自的 plist文件(就是在 LaunchDaemon 或 LaunchAgents 目录中看到的 *.plist 文件)所管理，plist文件是 XML 格式。 launchd 服务进程的生命周期由 launchd 所管理的服务（Launch Daemon 、 Launch Agent）是要先由 launchd 载入（load）以后才会执行（run），但载入之后并不一定马上执行。在苹果的官方文件说明了 OSX内核 载入完成后会发生的事，用来说明 Launch Daemons 、Launch Agents 及其各自子进程的的生命週期。 开机时，会先载入 OS Kernel ，载入完成后就执行 launchd ，用来载入系统级别的子进程（daemons）。这个系统级别的 launchd 在开机时会做这些事： 载入 (load) 存放在这些目录下的 plist ： /System/Library/LaunchDaemons /Library/LaunchDaemons 注册那些 plist 文件内设定的 sockets (port) 和 file descriptors 执行 (run) KeepAlive = true 的 daemons ，当然 RunAtLoad = true 的也会启动。 该运行的进程运行之后，就出现了登录窗口，提示使用者登入。有设定自动登入的话，就会跳过这项。 在使用者登入以后，会执行属于该使用者的 launchd ，负责处理 Launch Agent ，做的事跟上面载入 Launch Daemon 很像，差别在于它从以下的目录载入 plist： /System/Library/LaunchAgents /Library/LaunchAgents ~/Library/LaunchAgents 由使用者执行的任何程式也都是 launchd 来执行的，所以 launchd 也是该使用者的所有子进程的母进程。 在使用者登出、关机或重新开机时，会触发终止事件，用来接受使用者的登出、关机、重新开机等指令的进程是 loginwindow 。它会先向使用者确认，一但确认，就会对每个由该使用者的 launchd 所启动的 processes 送出 终止信号，如果是 Cocoa 则送出 Cocoa API 的 event，其他的就送出 SIGTERM 要他们自我了断，45 秒之后，除了 Cocoa 的应用程式可以丢出某个 error 来取消这整个 termination process，其他还没结束的都会被 kill 掉。 这就是为什麽 loginwindow 这个 process 会一直存在，它要负责把该使用者执行起来的 processes 统统清掉。而 per-user services 都关掉以后，就回到 loginwindow ，或是执行关机、重新开机的流程，后两者就是照着差不多的流程去关掉所有 system-wide services 。 参考文章 Mac OS X 的 Launch Daemon / Agent","link":"/2017/02/19/launchagents_and_launchdaemon_on_mac_osx/"},{"title":"白话GIT","text":"文章更新 20170308-初次成文 20170406-大更新，完成了“白话GIT”的初稿 为什么会有这篇文章很多时候，git是一个让人又爱又恨的东西，初期接触觉得很酷很方便，但是要系统的学习起来，很难，命令很多，想系统的靠一篇文章来学透git的想法，对我这种智商为负的人来说是不可能，只好在使用的过程中逐渐掌握。所以，如果你凑巧看到了这篇文章，觉得git很难学，那么你可以稍微安慰一下，因为还有我为你垫底。 另外一个原因呢，就是发现网上很多的教程文章，都是总结性质的，而不是”白话”性质的，所以就自己白话一篇。 关于git的那些糊涂账最新的想法是，网上的系统的GIT教程，都弄得非常的高深莫测，在自己接触GIT的一年左右的时间内，尤其是最近这一个月，发现StackOverFlow和GIT的官方算得上的解释概念非常清晰的地方了，遇到问题GOOGLE一下，会讲解得很清楚，而其他的地方，经常是长篇大论，从头讲到尾，弄得很多时候无从下手。 由于一直看不下去系统介绍GIT的教程，都是用到什么学什么，所以还是很一些概念无法有彻底的明白。比如一些很常见的名词，什么是orgin, master, branch, repo？ 简单的说，origin是远程库的默认名字，这个名字一般用的时候最好修改成更有意义的名字，比如github, gitcafe等，master并不是库名字，而是主要的意思，比如，master branch，表示主要分支。 而local和master则分别表示本地和远程，比如常见的是local master branch，表示的意思是本地主分支。 当使用git init folder的时候，GIT会创建了一个GIT管理的目录(如果你已经在目录内了，命令变为git init)，这个目录就是GIT的仓库，也被称做版本库，这个目录(仓库、版本库)内部主要包括暂存区和master分支，是不是感觉一句话就让你乱了？别着急，下面更乱。 先说说git clone先说说，GIT一般是你本地的一个库，或者说是一个目录，一个仓库，那么如果你不是一开始就本地建立，肯定要先从远程的网站复制一个目录到你的本地来，对其进行更改、上传、更行等等操作。那么命令就比较简单了，一句话 1git clone git@github.com:username/他的项目名字.git 你的本地目录名字 上面命令组合中，第一个命令就是我们要学习的GIT，第一个参数clone，就是复制、克隆的意思，第二个参数是远程仓库名字，第三个参数是你想把远程的仓库复制到本地的名字，你可以重新命令一个新的目录名，比如下面这句 1git clone https://github.com/tinyvane/bug.n.git mybugn 上面就是把博主的一个公开项目复制到你的本地，本地目录是mybugn(本文下文都会用这个目录名字) 然后你进入到这个目录后，如果你的shell装了必要的插件，目录名字会变成 那么现在你本地已经有了mybugn这个目录，这个目录下面比较重要的文件，一是.git目录，这个目录下面保存着关于这个git项目的配置信息，.gitignore文件，用来记录不需要GIT管理的文件名，.gitmodules记录着关于子项目的信息。 好了，下面，来说说基本的和常用的git命令，我觉得如果由浅入深的话，很多时候根本分不清，不如按照场景分类，比如上传代码时候的命令，合并代码时候的命令，冲突的时候，等等。 推送命令执行过git clone后，项目已经从远程到了本地，那么本地修改了代码之后，如何让他们从本地到远程呢?很简单 123git add . #添加本地所有文件到GIT管理下git commit -m 'update' #提交，update是关于这次提交的说明git push origin master #推送内容 是不是觉得没什么难的？但是这里面涉及origin和master这两个东西，是什么呢？ 如果你的项目不大，origin就是GIT给远程仓库默认起得名字，而master是主要分支的意思，当执行git push origin master的时候，GIT会把当前分支下（git checkout了的分支）的所有提交全部推送到远程仓库下（这里是origin）下的master分支下。 GIT的初始配置在推送之前，你需要指定一些东西哦，还要让GIT知道你是谁。 12git config --global user.name \"foolman at thinkpad\"git config --global user.email foolman@gmail.com 如果用了 --global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 --global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。 要检查已有的配置信息，可以使用 git config --list 命令： 还有一些其他的东西可以指定，比如GIT使用哪个文本编辑器、何种差异比较工具等等，具体可以看GIT官方说明1.5 起步 - 初次运行 Git 前的配置。 关于远程仓库首先说命令 git remote -v 查看对应的远程分支，如果结果为空，就说明你需要指定了。 git remote add [alias] [url] 将本地文件和云端仓库映射起来，这步很重要，这里[url]应该写类如https://git.coding.net/tinyvane/hexo.git这样的远程仓库地址 git remote rm [name] 删除远程仓库 git remote set-url --push[name][newUrl] 修改远程仓库 上面的的[alias]是别名的意思，具体是指你可以用一个短小精悍的名字，来替代那长长的https://github.com/tinyvane/tinyvane.git。 下面用实例来说说 1git remote add origin git@github.com:tinyvane/randomfiles.git 在这里，我们将远程分支git@github.com:tinyvane/randomfiles.git赋予了别名origin，英文的意思是初始的意思，或者是源的意思。这个origin可以随便修改的。 如果想删掉呢？ git remote rm origin 是不是很简单？但是当这样做了之后，就不能执行git push origin master命令，GIT会提示fatal: 没有配置推送目标，就是说GIT觉得远程没有对应的推送位置了，需要重新指定一次 12git remote add origin git@codingnet1:tinyvane/hexo.gitgit push --set-upstream origin master 这样，才又重新建立起本地master和远程master的对应关系 好了，这里介绍了一个远程默认分支的概念，其实这个就是github上和你本地分支对应的远程分支，如果说得再深入一些，是两个repository，repository是存储库的意思，一般简称为库或者repo。两个repo，一个是remote repo，在远程服务器上，另外一个是local repo，在自己本地电脑上。 所以，一个标准的GIT远程或者本地地址，包含3项信息，分别是server、repo和branch，用中文分别就是服务器、库和分支。 继续上栗子，比如https://git.coding.net/tinyvane/hexo.git 这句中git.coding.net是server,是服务器地址；tinyvane是repo，是库；hexo.git是branch，是分支。但是这里要说一下，这个hexo.git，并不是GIT所说的分支或者branch，这里面 如果按照本地和远程来区分，那么就变为6个概念 remote server、remote repo和remote branch，分别是远程服务器、远程仓库、远程分支。 local server、local repo和local brach，分别是本地服务器、本地仓库、本地分支。 当你使用git clone，从远程服务器上，这里以github为例，你就是克隆了远程服务器上的仓库里的一个分支，复制到本地，在git push之前，你所有的文件改动，都是在你本地服务器的local repo上进行的，你的改动(local repo)和远程仓库(remote repo)是独立的，就是说你无论怎么改动本地，在git push之前，都不会影响远程仓库的。 好了，继续说。 当你git clone之后，git会自动将你下载过的那个远程仓库，给一个别名(alias)，默认是origin。 下面要说的东西，开始有些不好理解了，请做好思想准备。 为远程仓库指定完别名之后，GIT会建立一个指向远程仓库（remote repo）的某个分支（就是branch的概念了）的指针。 继续用最开始的例子 https://github.com/tinyvane/hexo.git，这条信息中，除去github.com这个服务器名，接下来就是用仓库名/分支名的方式来表示的分支路径。 所以tinyvane/hexo.git，就是这样一条路径。 好了，懂了这个概念，就可以继续说默认分支的问题了，本地的分支，默认是origin，那么远程的分支呢？ 远程分支，首先是有一个master branch的概念，就是主线分支，这个分支中基本上都是发布的代码，其他分支呢？假如你新开了一个betadev分支，用来发布调试版本的代码，那么这个betadev分支，就是对这个master branch的修修补补，当修补成熟了，你可以将betadev分支的代码合并到master branch中去。 所以，远程的默认分支，就是master。 懂了这些，我们再回头看我们开始的时候使用的推送命令 1git push origin master git push命令的完整表示形式是 git push [remote-name] [branch-name] 注意，分支（上面语句中的[branch-name]）推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，就是从左到右的顺序，所以git push是&lt;本地分支&gt;:&lt;远程分支&gt;，而git pull是&lt;远程分支&gt;:&lt;本地分支&gt;。这是一个方向的问题，理解了就非常好记忆，拉取代码是从 远程 到 本地 拉回来，推送是从 本地 到 远程 推过去。这种:的写法，提前说一下，称为引用规格（refspec）。这个概念，先记着，不用想太多，继续往下看。 所以，git push origin master这条命令的完整的形式，应该是 git push origin refs/remotes/origin/master（本地的，带着remote字样）:refs/origin/master（远程的，不带remotes哦，这点刚开始容易混淆），并且里面都没有heads字样哦！ 这里说明一下，refs/heads/master 是你本地的的工作分支名称，而带有remotes字样的，比如refs/remotes/origin/master ，一般叫做“跟踪分支”，跟踪分支并不是真正的分支，而是指向远程仓库中上一次提交的那个分支。而“master”或者“origin”并不是固定的，比如origin，当你第一次git clone的时候，如果不指定别名，那么git就认为本地对应的远程仓库别名是Origin，而master也是一个默认的名称，表示主要分支的意思。 所以，现在我们可以总结一下，refs/remotes/origin/master和refs/heads/master基本是一样的，分别是远程分支在本地的追踪分支，以及本地的master分支，这两个分支具有对应的关系，而refs/heads/origin/master则是在远程仓库上的分支。 所以 1git push origin refs/heads/master:refs/heads/origin/master 和 1git push origin refs/remotes/origin/master:refs/heads/origin/master 效果相同，当然了，如果想省事，也可以直接简化成为 1git push origin 我们再来想想看，这个refs/heads/master:refs/heads/origin/master的写法，在哪里出现过呢？ 在本地的GIT仓库路径下执行命令 1cat .git/config 会看到类似这样的结果： 123456[remote \"origin\"] url = git@codingnet1:tinyvane/hexo.git fetch = +refs/heads/*:refs/remotes/origin/*[branch \"master\"] remote = origin merge = refs/heads/master 这个[remote]字段，就是表示远程仓库部分，下面的[branch]表示本地仓库部分。 从上面的结果中可以得知如下信息： 远程分支是refs/heads/*，远程分支对应的本地分支则是：refs/remotes/origin/*，这个地方的规则是:，分别表示源，和目标， 远程仓库的默认分支是origin，他的路径是git@codingnet1:tinyvane/hexo.git，那么+refs/heads/*:refs/remotes/origin/*，这句话中的加号啊，星号啊又是什么鬼？？ 这里附上GIT官方说明，中文版 先说这句话怎么来的吧，在最开始说git clone的时候，提到了这样一条语句 1git remote add origin git@github.com:tinyvane/randomfiles.git 这条命令，会在.git目录下的config文件中添加一个小节 123[remote \"origin\"] url = git@github.com:tinyvane/randomfiles.git fetch = +refs/heads/*:refs/remotes/origin/* 并在其中指定远程版本库的名称（origin）、URL 和一个用于获取操作（fetch）的引用规格（refspec） 引用规格的格式由一个可选的 + 号和紧随其后的 : 组成，其中 是一个模式（pattern），代表远程版本库中的引用； 是那些远程引用在本地所对应的位置。 + 号告诉 Git 即使在不能快进的情况下也要（强制）更新引用。 默认情况下，引用规格由 git remote add 命令自动生成， Git 获取服务器中 refs/heads/ 下面的所有引用，并将它写入到本地的 refs/remotes/origin/ 中。 所以，如果服务器上有一个 master 分支，我们可以在本地通过下面这种方式来访问该分支上的提交记录： 123git log origin/mastergit log remotes/origin/mastergit log refs/remotes/origin/master 这三条命令的作用相同， 因为 Git 会把它们都扩展成 refs/remotes/origin/master 如果想让 Git 每次只拉取远程的 master 分支，而不是所有分支，可以把（引用规格的）获取那一行修改为： fetch = +refs/heads/master:refs/remotes/origin/master 这仅是针对该远程版本库的 git fetch 操作的默认引用规格。 如果有某些只希望被执行一次的操作，我们也可以在命令行指定引用规格。 若要将远程的 master 分支拉到本地的 origin/mymaster 分支，可以运行： 1git fetch origin master:refs/remotes/origin/mymaster 注意2，如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。 比如git push origin :master，这样一句话，master前面的冒号之前，并没有通常所说的&lt;本地分支&gt;的名字，那么git就会认为你要推送一个空的本地分支到远程覆盖掉远程master分支，相当于新建了远程的master分支内容。 那么如果想把git push origin master拓展一下，应该是什么样的呢？ 那就是 1git push origin refs/remotes/origin/master:refs/origin/master 是不是看着有点蛋疼？但是却对这些格式比较清晰了呢？ 那么git push origin master就是表示，将本地仓库的分支内容，推送到远程服务器的origin仓库的master分支，这样说，是不是理解了呢？如果没有理解，请评论，我将继续改进，将这个白话git教程做到更好。 好了，光说远程的事情，回头看看本地。 git clone之后，git为远程的仓库也好，分支也好，做了这么多工作之后，git对本地下载过来的那些东西做了什么呢？ git会为本地repo（仓库），同样命名为origin，本地的那个branch，同样命名为master branch，也就是，本地也是master branch（主分支），为什么？因为本地和远程是对应的。 git同样也为这个本地的master branch建立了一个指针，随着你不断进行改动文件、git add、git commit等操作，这个指向master branch的指针也会不断移动。不懂？没关系，我刚开始的时候也不懂，请继续看就好了。 在你的git仓库，使用命令，查看所有远程跟踪及本地分支branch情况123 1`git branch -a` #（或--all） 会显示 123* master remotes/origin/HEAD -&gt; origin/master remotes/origin/master 上图 如果你的bash环境下开了颜色，可以看到红色的结果是远程分支，绿色的是当前工作的分支，白色的是本地分支。远程有两个分支，绿色哪一行，星号*表示当前分支所在的位置，箭头表示追踪。请注意，HEAD并不是一个分支，所以这里remotes/origin/HEAD并不是说这里有一个叫HEAD的分支，而是一个指针，它指向你最近工作过的分支上。 可以使用 git reset HEAD^ 命令来让指针的位置往前挪一个提交，也可以使用git show HEAD或者git show origin/HEAD来查看本地或者远程的指针位置。 或者使用 git remote set-head origin -a 进行设置，使用参数-d删除 那么，这里显示结果第一行中的 * master，就表示当前你工作在master分支上，remotes/origin/HEAD表示本地的HEAD(也就是指针）正在追踪远程的origin/master分支，第三行，远程的另外一个分支是remotes/origin/master，这是一个tracking branch，直译为追踪分支。关于追踪分支的概念先不多说，请大家慢慢了解，这是另外一种分支类型。 使用下面的命令，查看所有远程分支 1`git branch -r` #(或--remotes） 结果会显示 12origin/HEAD -&gt; origin/masterorigin/master 上图更生动一些，如下图 可以看到，远程有一个分支origin/master，master就是local branch，origin/master是remote branch（master is a branch in the local repository. remotes/origin/master is a branch named master on the remote named origin） 在我个实际个人使用中，发现远程分支无意中多了一个remotes/origin/origin/master的远程分支，如何删掉呢？如果按照上面说的，使用语句git 用下面一个图来表示一下： 在这个图中，我们共有C1 C2 C3 C4 C5 5次提交， git push origin master 在简单的条件下，我们就是远程一个分支origin，本地一个分支 git remove add 下载代码1git clone https://github.com/tinyvane/tinyvane.git localpath 这是克隆操作，也是下载的一种，可以使用https或者ssh方式，如果是ssh，上述命令中的后半段，可以修改为 git@github.com:tinyvane/tinyvane.git localpath。当然了，github.com还可以使用别名（这个别名和git别名不是一个概念，但是思路一样），那就涉及修改.ssh目录下的config文件了。下文继续说，或者可以看我的其他文章。 git pullgit fetchgit merge参考文章 What’s the meaning of ‘origin’ in ‘git push origin master’ Is “refs/heads/master” same as “refs/remotes/origin/master” in Git? Git 的origin和master分析 10.5 Git 内部原理 - 引用规格 Git branch named origin/HEAD -&gt; origin/master git 常用命令(含删除文件) Git查看、删除、重命名远程分支和tag","link":"/2017/03/08/learn_git/"},{"title":"关于macOS的目录和软件安装","text":"文章更新 20170312-初次成文 为什么会有这篇文章最近运行brew updagre，发现一些软件有了冲突，记得上次更新还是在几个月之前，发现有一些软件也觉得过期想要卸载了，装了homebrew，所以可以使用brew uninstall方便的卸载掉他们，但是无意中发现其实Homebrew装软件的原则是不破坏原来的系统自带软件或者稳定性，所以将所有装的软件全部放到了/usr/local/Cellar目录下，这还好说，但是有的软件，总会在系统中同时存在几个版本，比如在升级wget这个工具的时候，系统自带的在/usr/bin目录下，Homebrew装的在/usr/local/Cellar/wget目录下，一个1.18，一个1.19，但是/usr/local/opt目录下的wget又是个什么鬼？好了，下文慢慢扯。 macOS系统的目录结构因为 Mac 属于一种类 Unix 系统，因此 Mac OS X 目录 = Unix 系统通用目录 + 独有目录，Mac OS X已经是被认证的Unix系统，所以其目录结构基本符合Unix系统目录结构。但是有很多目录在Finder中并看不到，这是因为这些目录的被设置了隐藏属性，我们可以在终端窗口中利用unix命令查看。 Unix 通用目录 /bin 传统unix命令的存放目录，如ls，rm，mv等。 /sbin 传统unix管理类命令存放目录，如fdisk，ifconfig等等。 /usr 第三方程序安装目录。 /dev 设备文件存放目录，如何代表硬盘的/dev/disk0。 /usr/bin, /usr/sbin, /usr/lib，其中/usr/lib目录中存放了共享库（动态链接库）. /etc 标准unix系统配置文件存放目录，如用户密码文件/etc/passwd。此目录实际为指向/private/etc的链接。 /tmp 临时文件存放目录，其权限为所有人任意读写。此目录实际为指向/private/tmp的链接。 /var 存放经常变化的文件，如日志文件。此目录实际为指向/private/var的链接。 macOS独有目录 /Applications 应用程序目录，默认所有的GUI应用程序都安装在这里 /Library 系统的数据文件、帮助文件、文档等等 /Network 网络节点存放目录 /System 只包含一个名为Library的目录，这个子目录中存放了系统的绝大部分组件，如各种framework，以及内核模块，字体文件等等。 /Users 存放用户的个人资料和配置。每个用户有自己的单独目录。 /Volumes 文件系统挂载点存放目录。 /cores 内核转储文件存放目录。当一个进程崩溃时，如果系统允许则会产生转储文件。 /private 里面的子目录存放了/tmp, /var, /etc等链接目录的目标目录。 用户资料存放位置对于普通OS X用户来说，对系统目录树结构的理解与否并不影响正常使用系统，以至于OS X把很多目录都故意隐藏，让普通用户通过Finder不能看到。用户真正关心的是把自己的资料存放到哪里更加方便和安全。 Windows用户通常会把个人资料存放在非系统盘的其它分区中，因为Windows系统一旦死掉，C盘的内容很可能就找不回来了。Mac OS X的用户则不用担心这个问题，OS X发生崩溃和不能启动的概率实在是太低了，就算是系统出现问题，由于用户目录和系统目录是彼此独立的，所以也容易找回。所以通常情况下，用户直接把资料存放在自己的用户目录中，OS X也建议用户这么做，并且已经为用户准备好了常用的子目录。 应用程序、文档、下载、音乐、电影、图片、公共，对于普通用户来说这些子目录也就够用了，当然如果你觉得不够，可以自己随便添加。 从Windows过来的用户，如果还想保持原来的习惯，把用户文件和系统文件存放在不同的分区中，那么就需要利用“磁盘工具”重新分区，把系统分区调整小一些，留出空间建立一个新的HFS+分区，使用的时候把这个分区挂载到系统目录树上。 关于/usr/local和opt目录其实在unix系统下，这两个目录的区别还是有一些的 /usr/local下一般是你安装软件的目录，这个目录就相当于在windows下的programefiles这个目录 /opt这个目录是一些大型软件的安装目录，或者是一些服务程序的安装目录 但是在安装了Homebrew的macOS系统上，区别嘛，直接看图吧。 看到了么？所有的文件，都指向了Cellar目录下的程序，也就是说这个目录目前放的，主要是用来兼容程序使用的目的。 使用Homebrew管理macOS的软件Homebrew的介绍我统一搬家到这个帖子，请使劲戳。 参考文章 linux下面/usr/local和opt目录有何区别 Mac OS X 的系统目录结构 有趣的 Homebrew 命名邏輯 使用homebrew提升使用Mac的幸福感 Homebrew refusing to link OpenSSL","link":"/2017/03/12/learn_about_macOS_directory_structure_and_formula_installation/"},{"title":"在OSX上安装BOWER","text":"文章更新 20170221-初次成文 为什么会有这篇文章最近接触了下Bootstrap，安装的时候可以选择bower管理器，所以就总结了一下。 准备工作想在OSX系统上顺利安装bower，首先要确保你的系统安装了Node.js和NPM，具体步骤可以参看另外一个帖子。 开始安装bower输入命令 1sudo npm install -g bower 结果如下，会带着bower的版本号，并且告知bower安装的具体位置。 123/usr/local/bin/bower -&gt; /usr/local/lib/node_modules/bower/bin/bower/usr/local/lib└── bower@1.8.0 在你要建立一个新的bower项目的目录下之下，可以执行bower init命令用来初始化项目。 这会开始进行bower项目的初始化设置，所有答案可以一路回车，最后会生成一个bower.json文件，保存当前项目路径下。 安装bower的包命令是 1bower install packagename --save-dev 其他更多的bower包，可以去这里。 还可以通过上述命令安装github上的库，比如通过 用户名/repo名 的形式，或者其他合法的url地址。 使用–save-dev参数，将会在bower的bower.json配置文件中，将安装的包的信息填写到devDependencies一栏中。 bower组件 你所安装的所有bower组件，将会自动下载到你当前的工作目录下，一个称作bower_components的子目录下，并且所有组件的依赖包也将自动下载到这些目录之中。 如果希望这些下载包的CSS和JS可以自动加入到你的项目之中，可以使用wiredep这个工具。反过来，如果是希望删除这些组件包，可以使用 grunt-bower-concat这个工具。 参考文章 Installing Bower On OSX 10.11 El Capitan","link":"/2017/02/20/install_bower_on_osx/"},{"title":"wireshark抓包结果分析","text":"文章更新 20170218-初次成文 为什么会有这篇文章最近在学习斗鱼如何登陆发弹幕，所以借助wireshark这款工具，可以轻松的获得本机和斗鱼之间的送举报，但是wireshark掌握起来确实不容易，所以先在这里记录一下。 wireshark的过滤指令 ip.src == 13.13.13.13 筛选本地ip地址为13.13.13.13的数据包 ip.dst == 12.12.12.12 筛选远程ip地址为13.13.13.13的数据包 tcp / http / ssl 筛选不同类型的数据包 允许使用 || &amp;&amp; != 等不同的符号来连接条件 参考文章","link":"/2017/03/09/learn_how_to_use_wireshark/"},{"title":"如何不用鼠标使用WINDOWS 10","text":"文章更新 20170315-初次成文 20170330-补充了几个不常用的快捷键 为什么会有这篇文章其实一直就应该写这个帖子了，但是估计也是因为懒，所以一直久拖不决。 基本的理念经过很长时间的考虑，还是希望能写一下这个题目，其实我想我这里无法达到100%不用鼠标，毕竟还有LOL要玩，曾经有几天为了不用鼠标，全部依靠键盘快捷键，还吧鼠标直接拔掉来用电脑。当然那对我来说是自虐，过去的事情，现在想想也不觉得傻，而是一种经历吧。 其实之前在网上寻找不用鼠标的方法的时候，看到了其实不少人和我有同样的想法。比如在知乎的帖子《怎么样才能只用键盘不用鼠标，包括任何指针触控设备，并优雅地使用电脑？》上，就有不少答案。我并觉得不用鼠标有多么的优雅，只是因为自己也有一台MBP，在那台本本上的触摸板绝对是一种享受，而在PC台式机上面，就需要鼠标键盘两个一起用，右手一会用鼠标，一会又要回到键盘上来敲字，觉得折腾不说，手也觉得更累。 所以，其实一切是为了效率，如果你觉得这是为了装逼，我也不想说啥，每个人都有自己的生活方式，只要不打扰到别人，我也觉得没啥可评价的。 效率，一切为了效率就像在上一小节中说到的，手在MBP电脑上，基本不需要移动，因为打字和滑动鼠标基本可以在很短的距离内，甚至手腕都不需要移动，那么如何在PC上也达到类似的效果呢？ 显而易见，那么就要尽量少的使用鼠标，而尽量依靠快捷键来使用电脑。那么来说说自己的硬件设施。 一台雷柏V500的87键位键盘，没有小数字键。 2台DELL 2312显示器，一台先锋42寸等离子电视，拼出来的3联屏。 一只服役超过6年的罗技MX518鼠标。 好了，有了这些，还需要软件上也同样有合适的搭配。 Windows 10操作系统。我用了Windows账户登录，在单位和家里的电脑保持了同样的设置。我是有多喜欢云啊-_-!!! 其他可选软件包括bug.n, dvvid, display fusion, ultramon，lanchy等等，但是经过一段时间的磨合，最终都被我抛弃了。转移专注于Windows自身的快捷键。 其他还有一点想说的，越小众的软件，除非是你自己开发的，否则尽量不要取刻意记他们的快捷键，因为这种快捷键记得越多，反而给自己添了更多的烦恼。 我同时使用的其他几个软件，主要包括： QQ 这个不用说了吧，工作号，大号，淘宝店主号，技术号之类的，不记快捷键，回消息还要去点一下头像，略显蛋疼。之前有一阵子在单位的低配电脑上，因为总需要截图，但是觉得开QQ资源占用有点多，就用了一个《QQ截图的提取版》，就是100多KB的一个软件，加一个快捷方式，和QQ截图用了一样的快捷键，但是开QQ之后，反而会提示快捷键冲突，后来发现印象笔记中也自带全局截图，也就慢慢不用QQ截图的提取版本了。对了，搜狗输入法也自带截图软件，和QQ截图一样好用。 印象笔记，虽然很多网友觉得印象笔记越来越臃肿，渐渐沦为的草稿收藏工具，但是我还在用，哈，bite me 搜狗输入法，为什么这也算是软件之一呢？因为他自带的截图和输入法，是每天离不开的，对我而言。 Chrome+插件，这里必备的插件是Vimium，一个让你用键盘就能操作的网页的插件。对了，顾名思义，Vimium的键盘规矩和VIM相同。 最重要的快捷键先从重要的快捷键开始，什么Alt+F4关闭窗口之类的留到后面吧。 Ctrl+Win+右箭头，切换到2号桌面。 Ctrl+Win+左箭头，切换到上一个桌面。 上面两个是我觉得Windows 10超赞的一个改进，效率超高。 Win+D， 显示桌面，如果你需要回到桌面下打开个文件夹什么的，用这个没错，再次按一下这个快捷键组合，则会重新回到之前的状态，非常方便。顺便这里说一下Win+m，顾名思义，这个M是minimize all的意思，因为有一些APP不支持最小化，这个时候就需要用Win+d了。另外一个重要区别是，Win+d两次可以切换回之前的状态，但是Win+M多按也没用，慎用。 Win+Shift+左右箭头，这个对于多个显示器来说，用户太大了，可以把当前窗口在左右窗口中随便移动。 Win+上下左右箭头，这个用法比较灵活，而且也需要练习一段时间，但是用熟了，就可以实现类似Awesome的效果，比如下面这样。 左右分类大家肯定很熟悉了，用Win+左右，把窗口放到你想放的一侧，然后另外一侧Windows会让你从已打开的窗口中选择。 但是Win+上下，其实用法非常灵活，比如，当前窗口，按一下Win+上箭头，窗口会吸附到屏幕上侧边缘，再按一下Win+上，会变成最大化。如果是一个窗口，按一下Win+下箭头，会最小化。注意了，如果先按Win+左右，吸附到左侧或者右侧，再上Win+上的话，窗口会变成一半，吸附到上侧，然后Windows会让你选择一个窗口，沾满下半侧的空间，是不是很赞？这样Win+4个方向键的灵活掌握，你可以实现4个窗口均分窗口，符合emcas的穷尽桌面每一个像素，却不互相打扰的原则。 好了，说完了这个几个技巧，就轮到切换窗口了，如果你只有一个显示器，Alt+Tab和Win+Tab的效果区别不大（后者炫酷一些），但是如果你有多个显示器，或者想利用Windows 10的多个虚拟说面，区别就比较大了。 这里的情况，主要针对多个屏幕的用户，在多屏条件下，Alt+Tab，会列出所有显示器上的所有窗口，而Win+Tab则会分别在每个显示器上，把窗口分别列出来，这个时候，使用Tab键，可以依次在 当前桌面窗口、添加虚拟桌面、下一个显示的桌面窗口、下个窗口的添加虚拟桌面等几个选项之间轮换，注意，Alt+Tab、Win+Tab和Tab这几个快捷键，都可以配合Shift组合使用，实现倒序选择了。 Win+123 从上面的图片中可以看到，如果是经常使用的应用程序可以将它固定到任务栏，然后通过快捷键，win + 1、win + 2、win + 3等来进行快捷访问。 其他快捷键 Win+Alt+D 显示日期时间，这个有啥用？谁有用谁记吧。 Win+E，打开我的电脑，用来打开文件夹很有用。 Win+L，锁定电脑，我自己用电脑，基本不关机，也没用。 Win+x，相当于Start开始按钮的右键，里面有一些常用的设置。 Win+R，这个不用多说了吧，运行，常用。 Win+A，打开Windows 10桌面右侧的通知中心，相当于MBP上的两个手指右侧划入。 Win，这个。。。不多说了吧。 Ctrl+s，保存，最常用的，基本上都不算快捷键了。因为写论文总要保存保存。。。。再保存。 其他 ALT+空格+X 最大化窗口 ALT+空格+R 还原窗口原始大小 ALT+空格+N 最小化窗口 由此可见，ALT+X是打开左上角的图标的右键，比如可以ALT+空格+C是关闭 CTRL+W 关闭窗口，比如QQ中的关闭某个联系人，浏览器中关闭某个TAB WIN+E 打开我的电脑，也可以用来打开个文件浏览器用 CTRL+O 打开，什么都能打开 CTRL+N 新的程序，新的进程 CTRL+T 新的浏览器标签（tab） CTRL+Z 恢复上一步操作 CTRL+SHIFT+ESC 打开任务管理器，这个用得很多因为有的程序打开了，就无法关闭了 好了，Game over，have fun. 参考文章 怎样不用鼠标，完全只靠键盘操作电脑？","link":"/2017/03/15/how_to_use_windows_without_mouse/"},{"title":"将较低版本的git升级到新版","text":"文章更新 20170330-初次成文 为什么会有这篇文章将低版本git升级到较高版本 使用编译方式升级移除低版本git1yum remove git* 下载新版git源代码Go编译过程中要求高版本的git，而yum源里面默认只有1.7.1版本。 123456789#原版kernel.org国内访问过慢，替换为中科大源wget http://mirrors.ustc.edu.cn/kernel.org/software/scm/git/git-2.9.3.tar.gz#wget https://coding.net/u/sfantree/p/self_use_OSS/git/raw/master/ngrok/git-2.6.0.tar.gz#wget https://coding.net/u/sfantree/p/self_use_OSS/git/raw/master/ngrok/git-2.9.3.tar.gztar zxvf git-2.9.3.tar.gzcd git-2.9.3./configure --prefix=/usr/local/git-2.9.3makemake install 编译错误如果在编译过程中遇到错误： 123456789LINK git-credential-storelibgit.a(utf8.o): In function `reencode_string_iconv’:/opt/git-master/utf8.c:530: undefined reference to `libiconv’libgit.a(utf8.o): In function `reencode_string_len’:/opt/git-master/utf8.c:569: undefined reference to `libiconv_open’/opt/git-master/utf8.c:588: undefined reference to `libiconv_close’/opt/git-master/utf8.c:582: undefined reference to `libiconv_open’collect2: ld 返回 1make: *** [git-credential-store] 错误 1 如果没遇到，请直接跳过这一章节。 解决办法： 12345cd /usr/local/src/wget http://ftp.gnu.org/pub/gnu/libiconv/libiconv-1.14.tar.gztar -zxvf libiconv-1.14.tar.gzcd libiconv-1.14./configure -prefix=/usr/local/libiconv &amp;&amp; make &amp;&amp; sudo make install 然后回到git继续编译： 1234make configure./configure --prefix=/usr/local -with-iconv=/usr/local/libiconvmakemake install 取代yum安装的低版本git1ln -s /usr/local/git-2.9.3/bin/* /usr/bin/ 检查git版本1git --version 参考文章 编译升级Git版本 centos6.5安装git 2.X版本","link":"/2017/03/30/upgrade-lower-version-git-to-newest/"},{"title":"关于VSCODE遇到的ENOENT-no-such-file-or-directory-lstat-c-ygdrive错误","text":"文章更新 20170312-初次成文 为什么会有这篇文章这是我从git for windows全面转向使用cygwin之后遇到的一个错误，有几天了，一直没有仔细检查错误的原因。今天终于抽空解决了一下。 错误描述当你安装了cygwin，并且没有独立安装git for windows的时，而是使用了cygwin下的git插件，使用VSCODE打开一个git管理的项目，就会遇到一个错误ENOENT: no such file or directory, lstat 'C:\\cygdrive'。 解决办法 安装git for windows 关于VSCODE中的git集成工程 使用软连接让vscode正确找到cygwin下的git插件（本文方法） 建立软连接其实很简单，Windows下按WIN键，输入cmd，然后鼠标右键，选择以管理员身份打开 然后如果看到打开的命令行窗口左上角显示管理员即可 然后输入 1mklink /j \"C:\\cygdrive\" C:\\cygwin64\\home\\tinyv 然后重启vscode，点击左侧的git图标，如果发现还出现错误，并且错误是ENOENT: no such file or directory, lstat 'D:\\cygdrive\\c' 则还需要下一步 进入你刚刚建立的c:/cygdrive，命令 1cd c:/cygdrive 然后输入命令 1mklink /j \"C:\\cygdrive\\d\" D:\\ 重启vscode，错误应该就好了。 几个说明第一步中的tinyv，是你在c:/cygwin64/home目录下的用户名，这个要改成你自己的具体名字。 第二步中的D:\\，是你用VSCode打开的项目所在的盘符，我的项目在d盘下，所以这里的错误提示是/cygdrive/d，这个也要修改成具体的盘符，而不能生搬硬套我的写法。 参考文章 Keep getting error ENOENT: no such file or directory, lstat ‘w:\\cygdrive’ Visual Studio Code cannot detect cygwin git.exe path","link":"/2017/03/23/how_to_deal_with_vscode_and_git_from_cygwin/"},{"title":"如何安装和使用screen","text":"文章更新 20170330-初次成文 为什么会有这篇文章在linux服务器上运行长时占用的任务，当网络连接断开的时候，任务也就断了，screen可以让连接保持，即使你的xshell连接断开，也不影响screen中运行的任务。 screen命令是什么？Screen是一个可以在多个进程之间多路复用一个物理终端的全屏窗口管理器。Screen中有会话的概念，用户可以在一个screen会话中创建多个screen窗口，在每一个screen窗口中就像操作一个真实的telnet/SSH连接窗口那样。 如何安装screen除部分精简的系统或者定制的系统大部分都安装了screen命令，如果没有安装，CentOS系统可以执行 1yum install screen Debian/Ubuntu系统执行：apt-get install screen screen使用方法screen用来解决那些需要长时间安装的程序，比如lnmp时，或者执行某个长时的后台应用，比如提供ngrok服务。 创建screen会话可以先执行：screen -S ngrok ，screen就会创建一个名字为ngrok的会话。 暂时离开，保留screen会话中的任务或程序当需要临时离开时（会话中的程序不会关闭，仍在运行）可以用快捷键Ctrl+a d(即按住Ctrl，依次再按a,d) 恢复screen会话当回来时可以再执行执行：screen -r ngrok 即可恢复到离开前创建的ngrok会话的工作界面。如果忘记了，或者当时没有指定会话名，可以执行：screen -ls screen会列出当前存在的会话列表。 111791.ngrok [Detached] 11791.ngrok即为刚才的screen创建的ngrok会话，目前已经暂时退出了ngrok会话，所以状态为Detached 当使用screen -r 11791.ngrok后状态就会变为Attached，11791是这个screen的会话的进程ID，恢复会话时也可以使用：screen -r 11791 关闭screen的会话执行：exit 会提示：[screen is terminating]，表示已经成功退出screen会话。 使用screen来进行远程演示这是screen的一个非常有趣的用法，首先演示者先在服务器上执行 screen -S test 创建一个screen会话，观众可以链接到远程服务器上执行screen -x test 观众屏幕上就会出现和演示者同步。 常用快捷键 Ctrl+a c ：在当前screen会话中创建窗口 Ctrl+a w ：窗口列表 Ctrl+a n ：下一个窗口 Ctrl+a p ：上一个窗口 Ctrl+a 0-9 ：在第0个窗口和第9个窗口之间切换 screen里面如何用鼠标滚轮来卷动窗口内容在screen里面，因为每个窗口的历史内容已经被screen接管了，所以使用鼠标滚轮，无法往上下方向滚动，二是会在命令行出现之前的历史命令。 解决办法，就是在~/.screenrc里面添加（没有的话，vim或者touch创建一个） 1termcapinfo xterm* ti@:te@ 重开一个screen即可。 参考文章 CentOS下安装screen SSH远程会话管理工具 - screen使用教程 使用 Screen 创建并管理多个 shell tmux/screen里面如何用鼠标滚轮来卷动窗口内容","link":"/2017/03/30/how_to_install_and_use_screen_on_linux/"},{"title":"利用ngrok完成内网穿透","text":"文章更新 20170330-初次成文 为什么会有这篇文章我所在的公司，使用的网络是由北京联通提供的，100多台电脑共用一个公网出口IP。为了使用Resilio Sync同步我公司和家里的电脑数据，本想和网管商量下，能否给我的内网IP开设端口转发功能，无奈询问之后，网管竟然不清楚服务器和路由器的位置。这种内网环境，即便通过Shadwosocks，也经常发生内网和外部电脑(我家里的电脑，和其他两台NAS)之间无法有效保持24x7的连接。花生棒是一个可选方案，但其一个月只提供2GB的流量，感觉略坑。经过一番网络搜索，发现可以借助ngrok来实现内网与外网的联通。 什么是ngrok?ngrok是一个ddns服务，为内网机器绑定一个公网域名之后，可以将内网机器的端口暴露在公网上，方便内网程序的调试和开发。比如，在内网机器上，想开HTTP服务的80端口，那么就可以使用ngrok，而不需要借助路由器的端口转发和端口映射功能。当然这样做的前提是，你需要一台可以从内网访问到的公网服务器，比如阿里云的云主机，或者便宜的搬瓦工VPS（一年20美金即可）。 ngrok的使用条件 域名 (很多域名如.top，.online域名首年都是0.88美金，具体访问namecheap.com或者namesilo.com) 拥有独立IP的VPS或云主机(阿里云或者搬瓦工) ngrok服务器端编译我使用的阿里云服务器，装的CentOS 6.5 64位系统。 安装go的编译环境环境安装 1yum -y install zlib-devel openssl-devel perl hg cpio expat-devel gettext-devel curl curl-devel perl-ExtUtils-MakeMaker hg wget gcc gcc-c++ build-essential mercurial 安装go 1234wget http://www.golangtc.com/static/go/1.7rc6/go1.7rc6.linux-386.tar.gztar -zxvf go1.7.6.linux-386.tar.gzmv go /usr/local/ln -s /usr/local/go/bin/* /usr/bin/ 检查是否安装成功，命令 go env 如果看到下面的信息 123456789101112131415➜ ~ go envGOARCH=\"amd64\"GOBIN=\"\"GOEXE=\"\"GOHOSTARCH=\"amd64\"GOHOSTOS=\"linux\"GOOS=\"linux\"GOPATH=\"\"GORACE=\"\"GOROOT=\"/usr/lib/golang\"GOTOOLDIR=\"/usr/lib/golang/pkg/tool/linux_amd64\"CC=\"gcc\"GOGCCFLAGS=\"-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build672964581=/tmp/go-build\"CXX=\"g++\"CGO_ENABLED=\"1\" 说明go环境安装成功 下面开始进行go的编译，在参考其他帖子的过程中，推荐go的编译需要git版本&gt;=1.9，而我阿里云上的git是1.7.1因此需要升级git，我没有将步骤写在这里，因为觉得和主题不是很相关，如果你的git版本较低，可以参考这个帖子将较低版本的git升级到新版。 开始编译服务器端声明编译的路径和必要的域名(域名改成你自己的) 1234567#这是原版代码，编译过程会从github下载依赖包，国内网络坏境可能会有问题，下面使用的是阿里云的OSS提供的地址#git clone https://github.com/inconshreveable/ngrok.git ~/ngrok#推荐直接下载完整包，一次性编译无需下载wget http://tinyoss.oss-cn-qingdao.aliyuncs.com/ngrok.zipunzip ngrok.zipexport GOPATH=~/ngrok/ #指定GO语言所在位置export NGROK_DOMAIN=\"ngrok.wuliaole.com\" #这个需要改成你的域名 生成证书123456cd ~/ngrokopenssl genrsa -out base.key 2048openssl req -new -x509 -nodes -key base.key -days 10000 -subj \"/CN=$NGROK_DOMAIN\" -out rootCA.pemopenssl genrsa -out server.key 2048openssl req -new -key server.key -subj \"/CN=$NGROK_DOMAIN\" -out server.csropenssl x509 -req -in server.csr -CA rootCA.pem -CAkey base.key -CAcreateserial -days 10000 -out server.crt 生成的3个文件，分别是rootCA.pem、server.csr和server.crt，各有用处。 下面将这3个文件复制到指定位置 123cp rootCA.pem assets/client/tls/ngrokroot.crt -icp server.crt assets/server/tls/snakeoil.crt -icp server.key assets/server/tls/snakeoil.key -i 不同的编译类型如果要为不同的服务端编译，需要根据系统类型，更改go env中的变量。主要是GOOS和GOARCH这两项。 为linux-x86-64系统编译比如我的阿里云主机，系统是CentOS 6.5 64位，就属于这种类型，分别指定变量并且执行服务器端编译： 123export GOOS=linux export GOARCH=amd64 #如果是64位系统，则修改为386make release-server #如果是客户端，这里是make release-client 编译完成后，在路径~/ngrok/bin/linux_amd64下，会看到一个名为ngrokd的文件，这个即为服务端运行文件。 为树莓派系统编译123export GOOS=linux export GOARCH=armmake release-server #如果是客户端，这里是make release-client 编译完成后，在路径~/ngrok/bin/linux_arm下，会看到一个名为ngrokd的文件，这个即为服务端运行文件。 为windows系统编译服务端文件123export GOOS=windows export GOARCH=386 #如果是64位windows，这里修改为amd64make release-server #如果是客户端，这里是make release-client 编译完成后，在路径~/ngrok/bin/windows_386下，会看到一个名为ngrok.exe的文件，这个即为服务端运行文件。 为Mac OS编译服务端文件123export GOOS=darwinexport GOARCH=amd64 #如果是64位windows，这里修改为amd64make release-server 编译完成后，在路径~/ngrok/bin/darwin_amd64下，会看到一个名为ngrokd的文件，这个即为服务端运行文件。 *. GOOS参数可以指定为windows、linux、freebsd、darwin (Mac OS X 10.5 or 10.6) 和nacl(Chrome 的Native Client 接口)*. GOARCH可以指定为amd64 (64-bit x86)、386 (32-bit x86)、和arm (32-bit ARM)。 绑定域名将编译配置时的域名ngrok.wuliaole.com，解析到服务器IP 我是DNSPOD，为wuliaole.com添加一条值为*.ngrok的A记录即可。 服务器端部署将编译好的可执行文件移至/usr/bin/下 1cp ~/ngrok/bin/ngrokd /usr/bin/ 为ngrokd的运行单独开一个screen 如果你发现screen执行失败，说明你没有装，CentOS可以通过yum install -y screen来安装screen服务，具体可以参见我的另外一个帖子《screen的安装和使用》，讲述了强大的screen的安装和使用。 1screen -S ngrokd 运行ngrokd 1234#http./bin/linux_amd64/ngrokd -domain=\"$NGROK_DOMAIN\" -httpAddr=\":6060\" -httpsAddr=\":6061\" -tunnelAddr=\":6062\" #https设置了tls#./bin/linux_amd64/ngrokd -domain=\"$NGROK_DOMAIN\" -httpAddr=\":6060\" -httpsAddr=\":6061\" -tunnelAddr=\":6062\" -tlsKey=./device.key -tlsCrt=./device.crt 这里详细解释一下上面这句话中参数的含义 httpAddr 是访问普通的http使用的端口号，用后面用 `ngrok.wuliaole.com:6060 来访问服务 httpsAddr 是访问的https使用的端口号，同上，只不过是需要https的服务访问才用这个端口 tunnelAddr 是通道的端口号，这个端口是Ngrok用来通信的，所以这个端口在服务器上和客户端上设置必须要对应才可以正常的链接，默认不填写好像是4433。 防火墙呢 ngrok客户端编译Windows客户端好了，你现在服务器上，已经有一个ngrokd服务在运行了，那么客户端与服务器端如何连接呢？ 也没啥难的，就是继续修改go环境的编译参数，继续编译客户端就好了 123GOOS=windowsGOARCH=amd64 make release-client 我是在64位的windows 10环境下连接服务器，其他参数，大家可以参考服务端程序的参数，自行进行相应的修改。 编译完成后，在路径~/ngrok/bin/windows_amd64下，会看到一个名为ngrok.exe的文件，这个即为服务端运行文件。使用scp命令或通过ftp，将其下载到你的本地电脑上即可。 然后，创建一个ngrok.cfg文件来保存配置，内容很简单 12server_addr: \"ngrok.wuliaole.com:6062\"trust_host_root_certs: false 然后，记得要采用cmd命令的方式来运行客户端程序，一句话 1./ngrok -subdomain resiliosync -proto=http -config=ngrok.cfg 8000 上面的8000是你想暴露的http服务端口号。如果还想暴露更多诸如ssh或者其他更多服务的端口，自行添加即可。 树莓派或者linux客户端在ngrokd文件的同一级目录下，vim或者touch创建ngrok.cfg文件（yml语言格式） 这里假设你想用ssh端口管理树莓派或者你的linux服务器，ssh的默认端口是22，但是你想让这台树莓派将外网的10086端口转发到内网的22，那么设置如下： 1234567891011server_addr: ngrok.wuliaole.com:6062trust_host_root_certs: falsetunnels: http: proto: http: 80 #这里是你想暴露的http服务端口号 subdomain: pi #这里给你想暴露的http服务起个名字 ssh: remote_port: 10086 proto: tcp: 22 这里我把需要转发的http和ssh都写入配置文件，其他tcp服务语法格式和ssh相似，remote_port为远程端口，等下外网连接的时候用的就是这个remote_port的端口号。tcp:22为需要转发的本地端口。 在树莓派上运行 1./ngrok-for-arm -config=ngrok.cfg start http ssh 这时候，处于内网的树莓派就可以通过连接你的服务器（运行ngrokd的外网服务器）来提供80、22、10086等端口的服务了。 比如，你的外网机器，就可以使用ssh来连接和管理处于内网环境的树莓派了。 1ssh -p 10086 pi@ngrok.wuliaole.com 结语ngrok确实是非常强大，没啥想说的了。 参考文章 自搭Ngrok实现树莓派内网穿透 关于 ngrok 使用上的注意事项 编译ngrok的Windows、Mac的客户端 内网穿透 ngrok 服务器和客户端配置","link":"/2017/03/30/make_use_of_ngrok_to_penetrate_intranet/"},{"title":"Hexo大小写引起的404问题","text":"文章更新 20170330-初次成文 为什么会有这篇文章之前用hexo发布的文章，到了github或者coding.net网站上之后，总会有2个路径无法打开，后来仔细想了想，才发现是大小写的问题。怎么办？当然了清空了文件，重新发一次了呗。 解决办法首先修改Hexo根路径下的.git目录下的config文件，将其中的ignorecase的属性，由true修改为false。 然后，删除博客项目中 .deploy_git 文件夹下的所有文件，并 push 到 Github 上, 这一步是清空你的 github.io 项目中所有文件。 具体如何做呢？这个其实费了点时间。 想想其实就知道，hexo d所做的，就是将.deploy目录下的文件，推送到你的github的那个和你github用户名同名的项目库中，那么我们要做的，就是手动先清空那个远程repo中的文件，然后再上传过一次！ 说起来简单，那么如何清空远程repo上的文件呢？最简单的办法，就是将本地对应的项目库中的文件全部删掉，然后再git push回去，就可以了，如何做呢？ 这里以github为例，假设你的github用户名是patrick，那么你的hexo项目，路径就应该是https://github.com/patrick/patrick.github.io.git。 我们先在你的hexo目录下，建立一个名为.deploy的目录 1git clone https://github.com/patrick/patrick.github.io.git yourHexoPath/.deploy/patrick.github.io 然后，进去这个目录，删掉所有文件，记得要保留.git目录，在执行推送 123git add .git commit -m 'delete all hexo generated files'git push origin master 这样，你github下的repo内容就空了。 下一步，本地hexo生成文件，再复制到上面的目录中去，再手动push一次即可。 123456hexo generatecp -R public/* .deploy/patrick.github.iocd .deploy/patrick.github.iogit add .git commit -m \"update\"git push origin master 看看，你的网站是不是和hexo d -g发布的效果一样呢？ 参考文章 Hexo 部署到 Github Pages 文件夹大小写问题 手把手教你使用Hexo + Github Pages搭建个人独立博客","link":"/2017/03/31/correct_hexo_404_by_ignorecase/"},{"title":"北京联通烽火HG260GU更换华为8240光猫","text":"文章更新 20170330-初次成文 为什么会有这篇文章装的北京联通200M宽带，修改了HG260G-U的配置，桥接了，但是到了路由器之后，每个单个设备的下载速度只有50M左右，说明这个烽火的路由器性能不咋地。直接淘宝了搞了个二手的华为8240，4口全是千兆口，入门级强悍！ 更换光猫之前的准备工作先来说说自己的光猫，我的光猫是烽火HG260G-U，采用的是GPON格式。 如果进入联通光猫的192.168.1.1可以看到一些参数，这些参数是需要“手抄”填写到华为8240里面的，这里先记录一下。 为了信息安全，敏感信息全部用xxx或者进行了马赛克处理。 记录一下： 标题 内容 运营商: 北京联通 设备型号: HG260G-U 设备标识号: XXXXXX-XXXXXXXXXXXXXXXXXXXXXXX MAC/SN: FHTT17BF964A 硬件版本: V2.0 软件版本: G00L2.02 CPU使用情况: 14% 内存使用情况: 53% ![HG260GU的默认配置2](Image [1].png) 数据太多，整理一下，方便大家查看。 60:B6:17:xx:xx:xx 这是烽火猫背面的mac地址。 所以，从上面可以知道，设备的SN，就是FHHT+mac地址后面8位，设备的SN，就是设备的mac地址去掉冒号。 换上华为8240光猫把原来烽火后面的光纤插头，小心的插在华为的后面，开机，进入新买的8240了。 需要注意的是，华为的默认管理地址是192.168.100.1，所以，设置电脑为192.168.100.2，子网掩码 255.255.255.0。 8240启动后，可以通过命令ping 192.168.100.1，显示有回复，但是网页端无法登录，无奈只好长按reset持续10秒钟以上，但是发现从网页端依然进入不了192.168.100.1的管理页面。 峰回路转无意中发现可以进入telnet模式 打开cmd，输入命令 1telnet 192.168.100.1 账号root，密码root。 ![华为8240的shell模式](Image [3].png) 进入后，发现这是一个迷你型的busybox linux系统，命令行模式和linux非常接近。 发现网上给的sudo su命令无法启用，然后无意中发现输入?，可以显示全部命令。 ![华为8240的shell模式3](Image [4].png) 刷入原来烽火光猫的信息将60:B6:17:xx:xx:xx和去掉冒号的mac地址，输入如下面命令中。 1234set sn snid 60B617xxxxxxset productmac MAC 60:B6:17:xx:xx:xxset wanmac 60:B6:17:xx:xx:xxset wanmac MAC 60:B6:17:xx:xx:xx ![华为8240的shell模式](Image [5].png) ![华为8240的shell模式](Image [6].png) 顺便说一下，华为8240的cpu是ar8316。 管理端如何进入？我后来还是通过Google，找到了老周的一个帖子，他用了一些cmd脚本，来加速键盘输入，因为其实每次重启光猫后，是有几秒时间可以进入web的，就需要脚本配合，快速替换掉光猫内的设置信息，打开光猫的管理界面才可以。 老周帖子地址。 进入192.168.100.1后，账号是telecomadmin，密码admintelecome ![华为8240的登录界面](Image [8].png) 在系统工具中，可以看到SN已经设置成老光猫的信息，密码不要动。 ![华为8240的管理界面](Image [9].png) ![华为8240的管理界面2](Image [10].png) 老周”使能”脚本到底是什么？主要归结起来，就是下面这三句话 123set aclservicesrule HTTPLanEnable 1set aclservicesrule TELNETLanEnable 1save data 第一条命令，就是打开HTTP端访问，第二条是打开telnet访问，至于我的为什么可以直接telnet，我也不知道为什么。 升级8240的固件其实这步可做可不做，主要是当时我刚写入老光猫的信息后，无法从联通局端获取到争取的ip信息，所以以为是固件版本的问题，但是其实是我的一个笔误，把SN写错了一个字母，蛋疼的错误。 升级固件之前，先把目前的固件信息备份一下 ![华为8240的固件信息](Image [11].png) 好了，准备使用的是HG8240V100R006C01SPC122_china_full_all.bin这个固件， 选择bin文件之后，点update firmware的时候，会问你是否离开该页，记得要点离开，然后可以从浏览器的左下角看到上传的进度。 ![升级华为8240的固件进度条](Image [12].png) 等1分钟吧，就成功了。 ![固件刷新成功的华为8240](Image [13].png) 然后再次进入192.168.100.1 界面换了，果然漂亮了一些 ![升级后的华为8240](Image [14].png) ![升级后的华为8240](Image [15].png) 拨号651错误这个也是我当时犯错之后，看不到windows 10拨号错误具体是什么，还需要从windows的错误日志中找到具体的错误编号。 ![Windows 10中寻找错误信息](Image [16].png) 参考文章 老周光改日记","link":"/2017/03/31/change_hg260gu_to_huawei_8240_for_beijing_unicom/"},{"title":"DotNet Core在MAC OS上的安装","text":"文章更新 20170413-初次成文 20170728-内容更新 为什么会有这篇文章最早开始接触是在MBP上装了.NetCore 1.0.0，后来升级到了1.0.1，然后感觉过了小一年，想把DotNetCore升级一下，然后想先1.0.0和1.0.1先卸载掉，因为我发现在目录下这些目录全部存在，这估计是由于MAC系统的一个习惯，为了避免错误，新装的软件多是直接在PATH中指定路径，而系统自带的软件，则尽量不会去执行移除操作。 基础问题关于SDK和RUNTIME这俩东西，概念倒不麻烦，SDK是Software Development Kit，软件开发包，Runtime是运行时，是程序运行的基础。以.Net Core为例，从最早的1.0.0, 1.0.1, 1.1.1，到现在的2.0.0 preview 2，都是Runtime在不断的升级，SDK可以选择同步升级或者不升级，因为SDK一般是为了辅助开发的程序员可以使用当前Runtime的最新功能。 查看SDK和Runtime的版本好了，具体到.Net Core的SDK和Runtime，如何查看你的系统上装了哪个版本呢？ 首先是在MAC上 123which dotnet #查看dotnetcore的runtime路径dotnet #第一行出现的数字就是你安装过的最新版的Runtime版本号。dotnet --version ##第一行的数字是安装的SDK版本号。 从上面的图中可以看出来DotNetCore的runtime的安装路径，并且发现了没？ 我的系统上当前的runtime是1.1.0，很新，但是SDK却只有1.0.1呢？ 所以，要升级或者重装一下。 安装检查Homebrew环境见我的另外一个帖子，关于Homebrew的使用全部集中在那个帖子了。 安装OpenSSL和其他官方说明见这里。 12345brew updatebrew install opensslmkdir -p /usr/local/libln -s /usr/local/opt/openssl/lib/libcrypto.1.0.0.dylib /usr/local/lib/ln -s /usr/local/opt/openssl/lib/libssl.1.0.0.dylib /usr/local/lib/ 过程就不说了，没什么太多的问题，值得记录的，主要是安装OpenSSL之后的结果。见下 12345678910111213141516171819202122232425==&gt; Downloading https://homebrew.bintray.com/bottles/openssl-1.0.2l.el_capitan.bottle.tar.gz######################################################################## 100.0%==&gt; Pouring openssl-1.0.2l.el_capitan.bottle.tar.gz==&gt; Using the sandbox==&gt; CaveatsA CA file has been bootstrapped using certificates from the SystemRootskeychain. To add additional certificates (e.g. the certificates added inthe System keychain), place .pem files in /usr/local/etc/openssl/certsand run /usr/local/opt/openssl/bin/c_rehashThis formula is keg-only, which means it was not symlinked into /usr/local,because Apple has deprecated use of OpenSSL in favor of its own TLS and crypto libraries.If you need to have this software first in your PATH run: echo 'export PATH=\"/usr/local/opt/openssl/bin:$PATH\"' &gt;&gt; ~/.zshrcFor compilers to find this software you may need to set: LDFLAGS: -L/usr/local/opt/openssl/lib CPPFLAGS: -I/usr/local/opt/openssl/include==&gt; Summary🍺 /usr/local/Cellar/openssl/1.0.2l: 1,709 files, 12.1MB 主要难点是后半段的解释，OpenSSL是一个keg-only的formula，并且由于苹果为了推广使用的TLS算法和加密库，而放弃了OpenSSL。 关于key-only和Homebrew的问题，请移步这个帖子 因此，如果强行link，会引起系统的问题。因此建议用户使用命令 1echo 'export PATH=\"/usr/local/opt/openssl/bin:$PATH\"' &gt;&gt; ~/.zshrc 将这次安装的OpenSSL路径写入系统变量，对于像.Net Core这样的编译器来说，需要单独设置。 安装.Net Core的SDK下面安装SDK或者单独安装Runtime，安装SDK内含Runtime，反过来则不是。我这里下载的SDK内含.Net Core 1.0和1.1。 安装成功后后，有一个提示 这里有一段话注意事项： 1In order to be able to use .NET Core on OS X, you need to install OpenSSL version 1.0.1/1.0.2. There are many ways to install/update your libssl. Using Homebrew is the easiest. You can view the instructions here or if you're updating, on this page. 上文提到的两个链接地址，一个新装OpenSSL步骤，地址见这里，另外一个升级的步骤，地址见这里。 我个人对强行link formula的方式并不是很支持，还是喜欢单独为需要的编译器做单独设置。这个后文再说，目前先不设置。 创建第一个控制台程序装好了.Net Core CLI，就可以在terminal下试试运行程序了。 12dotnet new console -o hwappcd hwapp 运行后，.Net Core会自动下载相应的文件，建立起一个应用台程序 123456789101112131415161718Welcome to .NET Core!---------------------Learn more about .NET Core @ https://aka.ms/dotnet-docs. Use dotnet --help to see available commands or go to https://aka.ms/dotnet-cli-docs.Telemetry--------------The .NET Core tools collect usage data in order to improve your experience. The data is anonymous and does not include command-line arguments. The data is collected by Microsoft and shared with the community.You can opt out of telemetry by setting a DOTNET_CLI_TELEMETRY_OPTOUT environment variable to 1 using your favorite shell.You can read more about .NET Core tools telemetry @ https://aka.ms/dotnet-cli-telemetry.Configuring...-------------------A command is running to initially populate your local package cache, to improve restore speed and enable offline access. This command will take up to a minute to complete and will only happen once.Decompressing 100% 5738 msExpanding 100% 12314 msGetting ready...Content generation time: 246.0067 msThe template \"Console Application\" created successfully. 时间用了20秒不到，还可以。 恢复依赖和运行程序12dotnet restoredotnet run dotnet restore命令为项目准备了必要的文件 1234567891011Restoring packages for /Users/wangyi/Desktop/hwapp/hwapp.csproj... Generating MSBuild file /Users/wangyi/Desktop/hwapp/obj/hwapp.csproj.nuget.g.props. Generating MSBuild file /Users/wangyi/Desktop/hwapp/obj/hwapp.csproj.nuget.g.targets. Writing lock file to disk. Path: /Users/wangyi/Desktop/hwapp/obj/project.assets.json Restore completed in 1 sec for /Users/wangyi/Desktop/hwapp/hwapp.csproj. NuGet Config files used: /Users/wangyi/.nuget/NuGet/NuGet.Config Feeds used: https://api.nuget.org/v3/index.json dotnet run则是运行该程序。 升级OpenSSL遇到的问题这里的办法并不十分妥当，我已经不再推荐，但是作为参考还是很好的。 最近要把.NetCore的Runtime从1.0升级到1.1，发现EI CAPITAN上自带的OpenSSL版本是0.98，但是.Net Core对版本的最低需求是1.0.1，所以以为直接升级就可以了 1brew install openssl 结果显示 123Updating Homebrew...Warning: openssl is a keg-only and another version is linked to opt.Use `brew install --force` if you want to install this version 但是遇到了keg-only的提示，然后硬上弓，输入命令brew install --force openssl 结果提示 1Warning: openssl-1.0.2k already installed, it's just not linked. 输入命令 1brew link openssl 提示 12345Warning: Refusing to link: opensslLinking keg-only openssl means you may end up linking against the insecure,deprecated system OpenSSL while using the headers from Homebrew's openssl.Instead, pass the full include/library paths to your compiler e.g.: -I/usr/local/opt/openssl/include -L/usr/local/opt/openssl/lib 意思就是说如果你想把keg-only类型的套件symlink的话，不是不可以，但是像openssl这么重要的基础套件，Homebrew建议你不要这么做，而是直接把这个套件的完整路径，直接告诉你所需要的软件，在这里就是需要让.Net Core 1.1知道我们装好的1.0.1k版本的opessl的具体路径，让前者需要的时候去这个特定的路径寻找，而不要使用系统默认的openssl，这样一方面满足了.Net Core的使用条件，另一方面，系统安全性也得到了保证。 如何做呢？ 如果/usr/local/bin/openssl存在，则先删除 1rm /usr/local/bin/openssl 将以前通过homebrew下载的新版本的openssl链接到/usr/local/bin/openssl 1ln -s /usr/local/Cellar/openssl/1.0.2k/bin/openssl /usr/local/bin/openssl 关闭terminal重新打开，再次查看openssl版本 1openssl version 多说几句，在查看openssl版本号的时候，我依然显示的0.9.8，没有显示为最新的1.0.2k。怎么回事呢？ 问题解决了，原来是没有关闭shell，关闭了，重开，再输入openssl version，就显示为 1OpenSSL 1.0.2k 26 Jan 2017 下面的东西，应该不用看了。 先看看默认的openssl来自哪里 1which openssl 发现结果来自/usr/bin/openssl，奇怪的是当我查看PATH路径变量的时候，显示的命名是/usr/local/bin排在/usr/bin之前呢？这是为啥呢？没有为啥，因为没有重启terminal。 12345678910111213/usr/local/opt/php56/bin: /usr/local/bin: /usr/local/sbin: /usr/bin: /bin: /usr/sbin: /sbin: /usr/local/bin: /usr/bin: /bin: /usr/sbin: /sbin: /usr/local/share/dotnet 题外话，这里PATH里面很多重复的，真是头疼。 参考文章 How to determine if .netcore is installed","link":"/2017/04/13/dotnetcore_on_mac_os/"},{"title":"Visual Studio for Mac 安装过程","text":"文章更新 20170414-初次成文 20170425-最终也是没有弄好，暂时放弃 20170728-正式版出了，折腾了一下午装好了 为什么会有这篇文章正式版出了，想起来之前折腾许久也没有装好，决定再尝试安装一下，结果虽然依然不太顺利，但是总算装好了。 下载与安装VS for Mac 软件下载地址 下载后，运行 这次的界面和预览版有所改变，第一次安装，全都选中。 失败了几次，都卡在了Android SDK上，无意中某次重装，发现安装器还发现了.Net Core，后来再安装就没有了，这正式版也是不太靠谱。 如果安装失败了，点击退出，安装器会提示保存进度，这个功能说好也不好，说好是因为下次重装不用下载2G多内容了，不好的呢？如果你决定放弃安装，占了N多硬盘，你还不知道该怎么清理。 通过控制台查看具体失败信息发现最后卡在了Android上面，可以通过cmd+o打开控制台，查看失败的原因 123456789101112131415161718192021222324[2017-07-29 03:39:30.329] [Debug] Starting installation task.[2017-07-29 03:39:30.330] [Info] Background installation worker called.[2017-07-29 03:39:30.330] [Info] Processing software items[2017-07-29 03:39:30.330] [Info] Skipping installation of software item 'Mono Framework'[2017-07-29 03:39:30.330] [Info] Skipping installation of software item 'Java SDK'[2017-07-29 03:39:30.330] [Info] Installing software item 'Android SDK'[2017-07-29 03:39:30.330] [Debug] Android SDK component 'http://dl-ssl.google.com/android/repository/tools_r25.2.5-macosx.zip' download URL: http://dl-ssl.google.com/android/repository/tools_r25.2.5-macosx.zip[2017-07-29 03:39:30.330] [Debug] Android SDK component 'http://dl-ssl.google.com/android/repository/build-tools_r25.0.3-macosx.zip' download URL: http://dl-ssl.google.com/android/repository/build-tools_r25.0.3-macosx.zip[2017-07-29 03:39:30.330] [Debug] Android SDK component 'http://dl-ssl.google.com/android/repository/platform-tools_r25.0.5-darwin.zip' download URL: http://dl-ssl.google.com/android/repository/platform-tools_r25.0.5-darwin.zip[2017-07-29 03:39:30.330] [Debug] Android SDK component 'http://dl-ssl.google.com/android/repository/platform-23_r03.zip' download URL: http://dl-ssl.google.com/android/repository/platform-23_r03.zip[2017-07-29 03:39:30.330] [Debug] Android SDK component 'http://dl-ssl.google.com/android/repository/sys-img/google_apis/x86-23_r20.zip' download URL: http://dl-ssl.google.com/android/repository/sys-img/google_apis/x86-23_r20.zip[2017-07-29 03:39:30.331] [Debug] Android SDK component 'http://dl-ssl.google.com/android/repository/sys-img/google_apis/armeabi-v7a-23_r20.zip' download URL: http://dl-ssl.google.com/android/repository/sys-img/google_apis/armeabi-v7a-23_r20.zip[2017-07-29 03:39:30.331] [Debug] Android SDK component 'http://dl-ssl.google.com/android/repository/tools_r25.2.5-macosx.zip' download URL: http://dl-ssl.google.com/android/repository/tools_r25.2.5-macosx.zip[2017-07-29 03:39:30.331] [Debug] Android SDK component 'http://dl-ssl.google.com/android/repository/emulator-darwin-3833124.zip' download URL: http://dl-ssl.google.com/android/repository/emulator-darwin-3833124.zip[2017-07-29 03:39:30.331] [Debug] Android SDK component 'http://dl-ssl.google.com/android/repository/google_apis-23_r01.zip' download URL: http://dl-ssl.google.com/android/repository/google_apis-23_r01.zip[2017-07-29 03:39:30.331] [Debug] Android NDK download URL: http://dl-ssl.google.com/android/repository/android-ndk-r14b-darwin-x86_64.zip[2017-07-29 03:39:30.331] [Info] Android SDK is waiting for download to finish.[2017-07-29 03:39:30.643] [Debug] Download size for 'http://dl.google.com/android/android-sdk_r24.4.1-macosx.zip': 102781947[2017-07-29 03:41:11.681] [Exception] Failed to get content size at 'http://dl-ssl.google.com/android/repository/tools_r25.2.5-macosx.zip'[2017-07-29 03:41:11.681] [Exception] System.Net.WebException: The request timed out[2017-07-29 03:41:11.681] [Exception] at System.Net.HttpWebRequest.EndGetResponse (System.IAsyncResult asyncResult) [0x00065] in /Library/Frameworks/Xamarin.Mac.framework/Versions/2.10.0.113/src/mono/mcs/class/System/System.Net/HttpWebRequest.cs:1025[2017-07-29 03:41:11.681] [Exception] at System.Net.HttpWebRequest.GetResponse () [0x0000e] in /Library/Frameworks/Xamarin.Mac.framework/Versions/2.10.0.113/src/mono/mcs/class/System/System.Net/HttpWebRequest.cs:1037[2017-07-29 03:41:11.681] [Exception] at Xamarin.Components.Ide.Web.RequestHelper.GetResponse (System.Func`1[TResult] createRequest, System.Action`1[T] prepareRequest) [0x0023e] in /Users/builder/data/lanes/5133/752d68f3/source/installer/Xamarin.Web.Installer/MonoDevelop.Core.Web/RequestHelper.cs:83[2017-07-29 03:41:11.682] [Info] Please file a bug: https://go.microsoft.com/fwlink?linkid=852416 最终确定了几个无法下载的软件，可以手动下载，也可以在失败界面，查看失败安装说明，会有详细的安装提示，我就是通过这个提示安装成功的。见图如下。 说一点题外话，某次安装过程，提示VS for MAC要求将XCODE升级到8.3版本之上。我其实也想升级，无奈8.3的XCODE要求MAC OS对低10.12(sierra)，而我是EI CAPITAN（10.11），如果升级到10.12之后，KARABINER就无法使用了，日本键盘序列的我伤不起啊。 只能期待KARABINER早日支持10.12吧。 不过我决定死马当活马医，装完再说。 失败组件的安装通过手动安装说明，我下载这6个文件。 其中2个分别是Android SDK和NDK，3个是Xamarin的分别为开发MAC、Android和IOS而必备的组件，还有一个就是Visual Studio for MAC本尊 -_-… Android SDK和NDK手动安装这个是最麻烦的，其他的几个都含直接安装搞定，略去不说了。 解压缩android-sdk_r24.4.1-macosx.zip，得到一个android-sdk-macoxs目录，把这个目录移动到/Users/你的用户名/Library/Developer/Xamarin目录下，android-ndk-r14b-darwin-x86_64.zip也同样解压缩，得到一个android-ndk目录，放到同样位置。如下面这样。 然后到android-sdk-macosx-tools目录下，运行android程序 会打开android sdk manager，程序会自动从GOOGLD读取最新的组件列表。 勾选VS FOR MAC要求的3个组件，安装系统缺少的SDK组件。 确定后，MANAGER会再次确认，要求用户接受每一个软件的安装协议。点击INSTALL按钮。 好了，ANDROID SDK搞定了。 其他组件的安装VS for MAC，XAMARIN的3个组件都没遇到啥问题，双击直接搞定了。 没出问题的组件的安装下面的内容在这次正式版的安装过程中没出啥问题，但是留个备份供大家参考。 手动安装Mono Framework首先是Mono Framework 4.8.0.459，大概346M，下载地址见这里，pkg的安装包，下了5-6分钟吧，直接双击安装。 安装过程，相比.NetCore，那是相当顺利啊。 如何手动安装Java SDK打开iterm，输入javac -version 提示 1No Java runtime present, requesting install. 点弹出窗口上的更多信息，然后直接跳转到了SUN的官网下载页面 未来指引很多的实例，慢慢学起来。 参考文章 Visual Studio 2017 for Mac","link":"/2017/04/14/newbee_to_visual_studio_for_mac/"},{"title":"C# Winform窗体半透明","text":"文章更新 20170511-初次成文 为什么会有这篇文章bla bla bla 参考文章 每天一个linux命令（35）：ln 命令","link":"/2017/05/11/how_to_set_half_opacity_winform_windows/"},{"title":"c#如何判断键盘某个键的双击","text":"文章更新 20170511-初次成文 为什么会有这篇文章最近需要判断键盘的双击，网上的找到的都是判断鼠标双击的，所以自己研究了下，分享出来。 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051using System;using System.Windows.Forms;namespace _20170510_doubleclickmonitor{ public partial class Form1 : Form { public Form1() { InitializeComponent(); var k_hook = new KeyboardHook(); k_hook.KeyDownEvent += new KeyEventHandler(hook_KeyDown);//钩住键按下 k_hook.Start();//安装键盘钩子 } bool keyBpressed = false; DateTime firstPressTime; private void hook_KeyDown(object sender, KeyEventArgs e) { if (e.KeyValue == (int)Keys.B) { //判断是第一次按下还是第二次，根据keyBpressed这个布尔值来判断 if (!keyBpressed) { //如果是第一次按下B，不干什么，只记录时间 firstPressTime = DateTime.Now; //更改keyBpressed的状态 keyBpressed = true; } else { //如果是第二次按下B DateTime secondPressTime = DateTime.Now; var ms = secondPressTime.Subtract(firstPressTime).TotalMilliseconds; if (ms &lt;= 1000) { MessageBox.Show(\"b pressed twice!first time:\"+ firstPressTime + \" ;second time:\"+ secondPressTime + \" span: \"+ ms); keyBpressed = false; } else { MessageBox.Show(\"is not fast enough!\"); keyBpressed = false; } } } } }} 上面代码的实现，需要键盘监听类KeyboardHook，具体见C#全局键盘监听（Hook）的使用。 参考文章 Detect If Certain Key Was Pressed Twice Rapidly","link":"/2017/05/11/how_to_detect_key_pressed_twice_event_by_csharp/"},{"title":"winform程序启动后缩小至任务栏","text":"文章更新 20170511-初次成文 为什么会有这篇文章目前在做一个的小APP，需要运行开始就缩小到任务栏。 实现主要功能 程序启动自动隐藏到任务栏右侧通知栏显示。（与系统托盘同义） 双击系统托盘图标显示、隐藏窗口； 右击系统托盘图标提供三个菜单选项，“退出”、“隐藏”、“显示”； 需要的控件 建一个WinForm程序—IconForm，将Form属性ShowInTaskbar改为false，这样程序将不会在任务栏中显示。 将Form属性WindowState选择为 Minimized，以便起来自动最小化隐藏 在工具栏中的“公共控件”里，拖入NotifyIcon控件—notifyIcon1，这个是程序运行任务栏右侧通知区域图标显示控件，为控件notifyIcon的属性Icon添加一个icon图标，或从代码中加入。 在工具栏中的“菜单和工具栏”里，拖入ContextMenuStrip—contextMenuStrip1，这个控件是右击时关联菜单。 右键notifyIcon1选择属性，将其属性ContextMenuStrip改加为contextMenuStrip1，这个时候notifyIcon1和contextMenuStrip1两个控件就关联了。 右键contextMenuStrip1，选择属性，进入Items，然后点击“添加”，这里添加三个菜单选项：exitMenuItem、hideMenuItem、showMenuItem，同时分别将其Text属性改为：退出、隐藏和显示。 添加代码双击IconForm，即添加Load事件然后，右击窗体，选择属性，转到事件页面，双击 Load 事件，给窗体添加代码 1234567891011private void Form1_Load(object sender, EventArgs e){ //1.将Form属性ShowInTaskbar改为false，这样程序将不会在任务栏中显示。 //2.将Form属性WindowState选择为 Minimized，以便起来自动最小化隐藏。 string startup = Application.ExecutablePath; //取得程序路径 int pp = startup.LastIndexOf(\"\\\\\"); startup = startup.Substring(0, pp); string icon = startup + \"\\\\flower.ico\"; //3.一定为notifyIcon1其设置图标，否则无法显示在通知栏。或者在其属性中设置 notifyIcon1.Icon = new System.Drawing.Icon(icon);} 这里需要一个ICO图标，我的放在这里了，图片请放在启动路径下 双击SizeChanged事件，添加代码12345678private void Form1_SizeChanged(object sender, EventArgs e){ if (this.WindowState == FormWindowState.Minimized) { this.Hide(); //或者是this.Visible = false; this.notifyIcon1.Visible = true; }} 双击窗体上的菜单项，添加相关代码12345678910111213141516171819202122private void toolStripMenuItem1_Click(object sender, EventArgs e){ if (MessageBox.Show(\"你确定要退出程序吗？\", \"确认\", MessageBoxButtons.OKCancel, MessageBoxIcon.Question, MessageBoxDefaultButton.Button2) == DialogResult.OK) { notifyIcon1.Visible = false; this.Close(); this.Dispose(); Application.Exit(); }}private void toolStripMenuItem2_Click(object sender, EventArgs e){ this.Hide();}private void toolStripMenuItem3_Click(object sender, EventArgs e){ this.Show(); this.WindowState = FormWindowState.Normal; this.Activate();} 转到窗体设计模式，右击notifyIcon1 ，选择属性，双击其中DoubleClick，添加相关代码1234567891011121314private void notifyIcon1_DoubleClick(object sender, EventArgs e){ if (this.WindowState == FormWindowState.Normal) { this.WindowState = FormWindowState.Minimized; this.Hide(); } else if (this.WindowState == FormWindowState.Minimized) { this.Show(); this.WindowState = FormWindowState.Normal; this.Activate(); }} 完整的代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Text;using System.Windows.Forms;namespace IconForm{ public partial class Form1 : Form { public Form1() { InitializeComponent(); }//说明，程序运行后自动隐藏到任务栏右侧的通知栏里， //1 右击选择退出，隐藏，显示//2 双击可以隐藏和显示切换 //一 右击窗体，选择属性，转到事件页面，双击 Load，SizeChanged事件，给窗体添加代码 private void Form1_Load(object sender, EventArgs e) { //1.将Form属性ShowInTaskbar改为false，这样程序将不会在任务栏中显示。 //2.将Form属性WindowState选择为 Minimized，以便起来自动最小化隐藏。 string startup = Application.ExecutablePath; //取得程序路径 int pp = startup.LastIndexOf(\"\\\\\"); startup = startup.Substring(0, pp); string icon = startup + \"\\\\testIcon.ico\"; //3.一定为notifyIcon1其设置图标，否则无法显示在通知栏。或者在其属性中设置 notifyIcon1.Icon = new Icon(icon); } private void Form1_SizeChanged(object sender, EventArgs e) { if (this.WindowState == FormWindowState.Minimized) { this.Hide(); //或者是this.Visible = false; this.notifyIcon1.Visible = true; } }//二 双击窗体上的菜单项，添加相关代码 private void exitMenuItem_Click(object sender, EventArgs e) { if (MessageBox.Show(\"你确定要退出程序吗？\", \"确认\", MessageBoxButtons.OKCancel, MessageBoxIcon.Question, MessageBoxDefaultButton.Button2) == DialogResult.OK) { notifyIcon1.Visible = false; this.Close(); this.Dispose(); Application.Exit(); } } private void hideMenuItem_Click(object sender, EventArgs e) { this.Hide(); } private void showMenuItem_Click(object sender, EventArgs e) { this.Show(); this.WindowState = FormWindowState.Normal; this.Activate(); }//三 转到窗体设计模式，右击notifyIcon1 ，选择属性，双击其中DoubleClick，添加相关代码 private void notifyIcon1_DoubleClick(object sender, EventArgs e) { if (this.WindowState == FormWindowState.Normal) { this.WindowState = FormWindowState.Minimized; this.Hide(); } else if (this.WindowState == FormWindowState.Minimized) { this.Show(); this.WindowState = FormWindowState.Normal; this.Activate(); } } }} 程序效果 参考文章 C# winForm启动最小化到任务栏右侧通知栏并交互操作","link":"/2017/05/11/how_winform_app_startup_then_minimize_to_taskbar/"},{"title":"如何降级Resilio Sync","text":"文章更新 20170519-初次成文 20170727-更新文章初衷 为什么会有这篇文章Resilio Sync曾经确实是个非常好用分享工具，无奈这种p2p的方式并不能得到有限监管，所以他的tracker server某个时间节点之后，被盯上了，具体是谁不方便表达，大家自己脑补吧。后来从2.5.4开始，就频繁出来国内多个节点无法互相看到的问题，当时以为降级可以解决问题，后来才觉得还是太天真了。 如何降级Resilio Sync在Resilio Sync的官方网站找到最新版本发行的说明。 https://forum.resilio.com/topic/43414-latest-desktop-build-252/ DOWNGRADEResilio Sync will make a backup copy of all your settings prior migration into “sync-v2.3.7-1471003319.backup”-like folder (version and timestamp may vary). If you decide to return to 2.3.*, you’ll need to manually copy the content to your storage folder, remove Resilio Sync and be aware of next downgrade drawbacks: You’ll downgrade to “Free” version and you’ll have to re-apply license manually. File association with license files .btskey is broken so you’ll need to apply license in BTSync UILinking new devices to downgraded Sync is not possible. You’ll need to recreate identity if you want to link some new device.Downgrade is not supported for Selective Sync folders (as all placeholder files are renamed to *.rsl). If you downgrade and your Sync has Selective Sync folders, your files are going to be deleted on all peers. 好了，我翻译一下 1，去Resilio Sync的安装目录下 找到sync-v2.3.7-xxxxx.backup这样一个目录，我的见下图 看看这个目录下面都有什么东西呢？ 你需要手动把这个目录下的这些文件，保存到你的“storage folder”，存储文件夹，这个目录在哪里呢？其实就是在Sync UI里面设置里，有一个设置，见下图 上面这个界面有点奇怪，因为它是新版Sync的，2.5.2，是我想卸载掉的版本。 但是当我去这个位置下的时候，完全没有所谓的settings.dat这些文件呢。只好求助于Windows的搜索功能了， 好了，找到了,见下图 看来，其实所谓的存储目录，就是 Users 目录下的用户名目录下的 AppData\\Roaming\\Resilio Sync 目录？ 从下面来个对比 嗯，看来没错了，左侧是目前在用的目录，右侧是backup文件下的文件。 好了，现在我就开始卸载新版的Sync软件，然后再安装老版本软件，然后再覆盖就应该OK了。 停止Sync这个我就不说了，直接右键退出Sync就可以了。 卸载 我没有勾选 Remove settings 的选项，这个设置是Sync方便你下次还想装的话，就直接用了目录下的配置文件的目的。 安装老版本卸载后，发现其实那个Resilio Sync目录下并没有少多少东西，甚至Sync的主应用程序都在。不管了，继续装。 覆盖配置文件神奇的事情发生了，我甚至都没有覆盖配置文件，老版本的Sync就自动运行起来了，而且也连上了新版Sync的peer，让我惊喜。 虽然这样也算是安装好了，但是还是不放心，所以还是推出了老版本的Sync，把backup的文件重新覆盖了。 然后，又可以连接上家里电脑的peer了，感觉还是比较满意，正好截个图，留下个配置的说明。 成功算是小成功咯。 参考资料 Latest Desktop Build 2.5.2","link":"/2017/05/19/how_to_downgrade_resilio_sync/"},{"title":"GPT和MBR的区别","text":"文章更新 20170810-初次成文 为什么会有这篇文章最近单位发了一块西部数据的4T硬盘，在PC上格式化的时候，让我选择GPT和MBR，犹豫了一下，特地来研究一下。 前言当在WINDOWS 8.X或者WINDOWS 10系统上安装一块新的硬盘的时候，系统必然会要求你对这个新硬盘进行分区，而且有两种不同的分区结构，MBR和GTP，这俩是什么意思？又有什么区别呢？ MBR所谓的“分区结构”，是指在硬盘分区上的信息组织形式，比如一个分区的开始和技术位置，以及这个分区是否为可启动的标志位信息等。如果你曾经有在一台MAC电脑上安装双系统（MAC OS和WINDOWS）的经历，那么你应该遇到过两种分区形式：MBR和GPT，前者是Master Boot Record的缩写，中文翻译是“主分区记录”，后者是GUID Parition Table的缩写，中文翻译是”GUID分区表”。后者（GPT）这种分区形式出现时间较短，出现的目的是为了取代MBR。GPT分区格式自带很多天生的优势，然而MBR在现在看到，依然具有对传统设备的最大兼容性，并且在一些特殊情况下，存在非MBR不可的情况。然而，准确的来说，GPT分区格式并不是WINDOWS系统所独有的一种格式，在MAC OS系统、LINUX以及其他一些操作系统下，也会使用GPT分区格式。 MBR分区格式的限制MBR分区分时最早出现在1983年，随同IBM推出的PC DOS 2.0版本一同出现。之所以MBR被称作 主分区记录， 是因为MBR分区格式的信息，储存于一块硬盘的数据记录开始的一块特殊区域。该区域包含一个启动引导器（BOOT LOADER)，这个区域用于引导操作系统，并且包含该硬盘的逻辑数据信息。储存在该区域的BOOT LOADER代码通常很短，其作用是“载入”其他分区上的“较大”的“启动引导器”。举例来说，如果在电脑上安装有WINDOWS系统，那么WINDOWS系统的BOOT LOADER代码则会有一小部分存在MBR分区内部，这就是为了什么如果你硬盘上的MBR分区被破坏了，那么你的WINDOWS系统则无法启动，必须手动修复MBR分区才可以让电脑正常恢复工作了。再举LINUX系统为例，LINUX系统的GRUB引导器，也会将部分代码写入MBR内。 MBR分区也有自身的限制，比如，MBR分区对单个分区的支持，不能超过2TB的大小，并且，也支持最多4个基础分区（PRIMARY PARTITIONS)，如果你需要更多的分区，那么你必须将基本分区划分为“扩展分区”(extended partiton)，以便在扩展分区内，建立更多的逻辑分区。这在很多人看来是一个非常傻缺的设定。 GPT分区的优势 GTP分区格式则较为新颖，也是为了逐渐取代MBR而生。谈到GTP分区，就不得不说到UEFI(是什么的缩写？)，UEFI也是为了取代历史悠久的BIOS而出现的。GUID分区表格式，之所以被称作UEFI，是因为该分区格式为硬盘上的每一个分区都分配了“唯一”的数据标识符，或者称作”GUID”，意为一个随机长度的字符串，这样的随机性和长度组合，基本可以保障世界上每一个GPT的分区都不会相同。 GPT分区没有MBR分区的限制，比如GPT的分区可以超越2TB的容量限制，并且分区的个数没有数量上限。而此时唯一的限制，就是操作系统对GPT分区的限制，比如，在WINDOWS系统条件下，GPT划分最多的分区数量为128，但是相应的，GPT分区也不再需要像MBR分区那样，为了多个分区而必须建立扩展分区。 在MBR分区的硬盘上，分区表数据和启动数据保存在同一个区域。如果这个区域的数据被破坏或者覆盖，那么就会有很大的麻烦。而GPT分区则相反，GPT分区将这些数据在整个硬盘范围内保存多份，所以相对来说，GPT分区的数据安全相比MBR要强大很多，并且当分区表和启动数据被破坏的情况下，还可以得到恢复。 GPT分区同样会对硬盘上的数据进行CRC奇偶校验，以确保硬盘数据保存的完整性。如果数据被破坏，GPT的奇偶校验机制，会有机会使用被破坏数据的备份来重新校准覆盖，保证数据的存储安全。而MBR分区，则根本不存在这样的机制，如果MBR的分区启动表被破坏，那么通常意味着你只能发现你的电脑无法正常启动，然后硬盘数据全部消失掉了。 兼容性GPT分区通常为了保持对MBR分区的兼容性，从而包含一份所谓的”保护性MBR分区表“，这意味着如果你使用老版本的磁盘工具读取GPT分区，那么工具通常会将GPT分区视为一整块都是扩展分区的MBR硬盘。这一兼容机制是为了保证老版本的磁盘工具不会将GPT分区视为未分区磁盘，从而错误的为GPT重新进行MBR分区操作，而破坏原有数据。 如果希望WINDOWS操作系统从GPT分区启动系统，则必须要求电脑系统配备UEFI的BIOS系统，并且是由64位的Windows 7，8，10，Vista或者是服务器版本。如果电脑不具备UEFI的BIOS，则上述Windows系统，可以将GPT分区作为数据存储分区，而不能作为启动分区。 其他现代如LINUX或者CENTOS等这些现代操作系统，则基本内置了对GPT分区的支持。比如苹果的MAC OS系统，则不再使用苹果的APT(Apple Partition Table)分区格式，转而使用GPT分区格式。 GPT分区相比MBR来说更为先进，也是潮流所向，然而如果你依然对传统WINDOWS有需求，比如电脑系统并不匹配UEFI的BIOS，那么目前你依然需要MBR分区格式。 参考文章 What’s the Difference Between GPT and MBR When Partitioning a Drive?","link":"/2017/08/10/difference_between_GPT_and_MBR/"},{"title":"Netgear WNDR3800CH 安装明月OPENWRT","text":"文章更新 20170808-初次成文 为什么会有这篇文章最近的Shadowsocks不稳定了，而且闹得网络也不稳定了，路由器是NETGEAR的WNDR3800CH型号，之前本来买的时候就是带的明月永在的OPENWRT固件，但是后来为了稳定，就刷回了WNDR的原厂固件，现在又想刷回明月固件，破费了一番周折。 安装前的准备工作首先需要明确一点的就是，如果WNDR3800的原厂固件，版本高于1.0.0.16，就必须刷回这个版本的。以我为例，当初升到了最新的固件1.0.0.48，直接上传明月的openwrt-15.05.1-ar71xx-generic-wndr3800ch-squashfs-factory.img不成功，去OPENWRT的官方论坛上，破费了一点时间，才发现了这个问题。 原厂固件降级这个没啥好说的，找到1.0.0.16的固件文件，然后进入到路由器界面（默认地址是192.168.0.1），依次进入 ADVANCED-Administration-Firmware Update，上传你的文件，会弹出一个提示，告诉你上传的固件版本要低于当前的版本，不要理解，直接确定即可，等10分钟左右，就可以了。 需要注意的是，固件刷完之后，路由的原来配置不变，账号密码依然是之前的。 上传明月OPENWRT固件上传我上面提到的那个明月编译的固件，这个时候如果还提示上传失败（Upload fail），则需要擦除路由器的全部设置，使其恢复出厂设置，要做到这个可以有两种方法，一种是暴力点的，找个大头针去戳路由器背后的RESET按钮，超过30秒。第二种温柔一些，继续在路由器界面里，找到ADMINISTRATION BACKUP SETTING里面，最后一下，RESTORE FACTORY SETTING，等上1分钟即可。 差点忘记了，恢复出厂设置后，路由器的IP地址，变为了192.168.1.1（我之前设置成了192.168.0.1） 然后，继续上传明月固件。 如果刷明月失败，可以考虑LEDELEDE是一个在OPENWRT基础上开发出来的全新固件，其实和OPENWRT对应的观察不多，也有类似的文件，所以我直接从LEDE的网站下载了，地址。 参考文章 每天一个linux命令（35）：ln 命令","link":"/2017/08/09/install_mingyue_openwrt_fireware_on_netgear_wndr3800ch/"},{"title":"使用移动硬盘在PC和MAC之间同步数据","text":"文章更新 20170810-初次成文 20180225-添加了Dropbox的内容 为什么会有这篇文章最近单位发了一块西部数据的4T硬盘，发现自带的软件很好用，解决了困扰我很久的数据同步且需要加密的问题。 场景描述 我家中拥有一台Windows 10的PC作为固定用机器，配置较好，硬盘和内存都很宽裕；整理出重要数据为700G左右； 家中同时配备了一台DS216+II的群晖NAS作为数据备份和共享的中介，硬盘为2块4T硬盘； 通常在上班时间，或者移动办公，使用一台MAC BOOK PRO作为日常OFFICE和简单的笔记汇总工作；硬盘只有128G的SSD； 需求描述 MBP硬盘很小，通常硬盘只能作为临时数据存储之用，如果要长期保存，捉襟见肘。因此，如何获取到家中PC上的1T常用数据，就是一个非常麻烦的问题。 下班后，MBP里的数据，需要第一时间能够同步到家中的PC电脑上去，如果还使用移动硬盘来进行数据传输，就会显得很笨拙。需要一个省时且实时性高的软件来完成数据的同步。 不同数据同步方案描述我一直在寻找免费的数据同步方案，没想到最终的结果，依然是商业方案。然而那是后话，先来描述一下，我使用过的同步数据方案。 Resilio Sync我使用过很多软件，比如RESILIO SYNC，原名BT SYNC，但是这个软件我使用了将近2年，实在对他的文件同步和删除机制搞不明白，比如，首先它会把删掉或者改动的文件，在同步目录的.sync目录下的Archive目录下保存一份备份，或者在文件名后面加上1或者2这样的后缀，以表示文件改动。但是，我个人对文件的修改有比较好的命名习惯，所以不是很依赖这种机制，另外一个让我最不能忍的问题就是，经常一些正常的文件，也会莫名其妙的被移动到Archive目录下，以至于我非常想编写个工具监控Archive目录下的改动，因为被不明原因移动到Archive目录下的文件，默认经过30天就会被永久删掉了，所以，我很担心一些文件万一没有注意到移动了位置，并且超过了30天，就会真心欲哭无泪了。 Syncthing还有一款软件叫Syncthing，和Resilio Sync相比，前者是开源的，后者是闭源软件，但是界面却相对简陋，并且必须通过命令行在后台启动，然后在浏览器里打开一个本地地址来管理同步功能。我试用的感觉就是，不同电脑之间的发现机制依然不够稳定，并且也存在同步过程中忽然丢失彼此连接的问题。所以这个方案，我用了几天之后也放弃了。 CloudStation Drive由于家中使用了群晖的NAS，CLOUD STATION就成了不得不接触的一个软件。这是目前我数据同步的辅助手段，因为有的时候，我会在家里，在PC和MAC两台电脑之间切换使用，所以目前使用这款软件作为即时同步的一个辅助手段。 云盘我试用了DropBox，OneDrive和Google Drive，这三款软件，从速度上来说，在有翻墙工具加持的条件下，Dropbox是最好的，可以用满上传速度，OneDrive最差，Google Drive有点无语，因为它的安装程序默认是一个离线的简单安装包，还需要在开始正式安装的过程中下载完整资料，然而GOOGLE目前被墙的基本无法顺利下载。我是折腾了一下，通过COW+ShadowSocks全局翻墙才顺利安装，但是却无法使用它的File Steam功能，这个类似Dropbox的Smart Sync和OneDrive的File on-demand功能。这三个功能都是我非常中意的功能，但是，都是企业用户优先（甚至是独享）的功能。 这个功能是干什么的呢？简单来说，就是可以在本地看到全部的云盘文件结构和名称，但是占用字节全部为零，只有在你真正需要这个文件的时候，双击该文件图标，则云盘软件自动感知，帮助你将文件从云端下载到本地。这个功能，对于像MAC这种硬盘不大的系统来说，非常实用。目前最新的消息是，Windows Insider用户，可以免费体验OneDrive的File on-demand功能，但是目前MAC上的OneDrive并没有这个功能，所以呢？对于像我这种需要在MAC和PC之间同步数据的用户来说，然并卵！ FreeFileSync这个才是我目前大容量的同步的终极手段，并且配合它的另外一个兄弟软件，叫Real-time Sync，可以实现插入U盘或者移动硬盘的时候，就自动开启同步动作。所以很方便，主要是使用它的几种不同的同步方式，分别是 更新、镜像和双向，可以适用于不同的需求。 另外，一个非常好用的功能，是同步时候的文件过滤功能，比如很多时候，在MAC电脑上，经常会出现一些DS_Store这样的特定文件，所以这些文件并没有必要同步到移动硬盘或者PC上。 一些好用的过滤设置： . `.*.~.*.\\RECYCLER`. \\RECYCLED\\*. `\\desktop.ini*.\\System Volume Information`. \\$Recycle.Bin\\*. `\\thumbs.db` 尤其重要的是第一个，可以把所有MAC和LINUX上的点号开头的文件和文件夹全部过滤掉，因为这些文件，对PC来说并不是重要。还可以使用*\\~*这样的规则，则可以忽略调漂浮号开头的文件，那些文件通常是PC这边软件的临时文件。 西部数据4T硬盘该方案使用了West Digital（西部数据）的My passport这款移动硬盘，4T容量，之所以这个方案会很方便，主要得益于WD的软件，如WD SECURITY，这是一个专门可以给WD硬盘加密的软件，并且支持PC和MAC双平台。 软件安装之后，还可以设置当移动硬盘接上后，自动解密，而不用繁琐的多次输入密码，甚为贴心。 如何选择分区格式WD移动硬盘还有一款配套软件，叫WD DISCOVER，这个软件类似APP STORE，里面有一些WD硬盘的配套软件可以安装。比如，WD SECURITY就是在这个地方可以直接下载，而省去了从WD网站上下载的步骤。 好用的配套软件 WD DISCOVER，这款软件类似APP STORE，里面包含着很多和西数移动硬盘配套的软件，有免费的也有收费的。 WD UTILITY，这款软件可以直接对西数移动硬盘进行擦除（格式化）操作，同时可以选择格式，如ExFAT, MAC OS HFS+以及NTFS，挺有意思的是，这个软件在PC上运行的时候，只提示EXFAT和NTFS，而在MAC上运行的时候，会提示EXFAT和MAC OS HFS+, 所以可以看出来，EXFAT是两个不同平台数据同步的必选格式。同时，UTILITY还可以检查西数移动硬盘的数据安全、设置硬盘自动休眠的时间（从10分钟到90分钟），甚至直接关闭硬盘休眠。另外一个挺有意思的功能，就是在WD UTILITY里面，还可以控制移动硬盘指示灯，不过我有点不理解谁会需要这个功能？如果关了指示灯，鬼知道硬盘到底有没有接上电脑呢？当然了，盘符自动出来也可以判断，我就是吐槽一下而已。 之前曾经考虑过单独使用NTFS或者MAC OS HFS+, 然后配合PARAGON的NTFS FOR MAC或者PARAGON HFS FOR WINDOWS。但是这个软件有个弊端，不能解锁BITLOCKER，或者不能解锁MAC VAULT，所以加密是个缺陷。说到了PARAGON，就不得不说M3 NTFS FOR MAC，这款软件和PARAGON的功能差不多，但是这家软件公司的另外一款软件叫M3 BITLOCKER LOADER，可以在MAC平台上解锁PC系统上的BITLOCKER加密分区。但是软件价格比较高，需要40美金左右，价格不菲。 Dropbox不得不说，Dropbox的免费方案，只有5G的容量，确实不够用，我选用了一年99刀的Professional方案，1T空间，配合SS，完美的同步速度，而且没有CloudStation Drive动不动的小问题（比如文件占用问题，比如文件角标无缘无故不显示的问题），价格虽然较高，但是非常完美的解决了问题。 最终的方案花钱的Dropbox，免费的话，可以参考上面的的各种方案。 参考文章 每天一个linux命令（35）：ln 命令","link":"/2017/08/11/use_WD_my_passport_to_sync_data_between_pc_and_mac/"},{"title":"饥荒，亦游戏亦心态","text":"文章更新 20170818-初次成文 为什么会有这篇文章最近出差，无论在高铁上，还是中午休息的时候，总会打开电脑，玩上几盘饥荒游戏的离线版，一个人跑地图，一个人努力在游戏的世界活下去。同事说这个游戏听我形容就很无聊，看着我往就更无聊，但是我却觉得这个游戏，并不是游戏那么简单，而是一种努力活下去的心态。 这张图，非常好的形容了我在游戏中的感觉。 攻略是干嘛用的经常熬到7-8天人就挂了，要么是手里草不够制造火把，被黑暗吞噬挂了；要么就是没有吃的，饿死了，还有一次是冬天来了（好不容易玩到20天左右，直接找不到任何吃的）直接被冻死了。凡此种种，不知道持续了多少次，但是我依然喜欢这个游戏。最近开始努力的攀爬科技树，希望能熬出来农场、冰箱和大锅，但是发现，这个游戏需要的，是你对看到的每样东西的敏感性，比如，看到燧石，就知道这个东西是用来做锤子、斧子的，看到草和树枝，就知道是用来做火把的，看到树干，就是用来做火堆、做木条的，所以，我决定先把所有东西的用途写下来。 初期攻略这里的初期，是指前20天，冬天来临之前的这段时间，也是我目前的状态，还没熬过去呢。 先来说说3个状态，HP值（血量）、饥饿度（饱食度）、精神值，这三个东西如何补充。 血液HP值 可以通过制作药膏来回复，需要蜘蛛卵、草的灰烬还有一个东西。但是初期，尽量不要受损，否则不好补回来。 饥饿度（饱食度） 吃东西填饱，比如梅子、胡萝卜、种子，能吃啥就吃啥，能烤熟了吃更好。并且，多多利用生物互相仇视的相性来快速获取食物资源，例如蜘蛛对猪人、牦牛对猎犬、高鸟等等，可以让你获得很多你一个人搞不定的肉类或者物品。 精神，摘花，做花圈戴在头上，或者睡一觉都可以回复，对了，制造新物品，也可以提升精神力。 每一种东西的作用初级物品： 树枝 和草搭配做火把，初期身上要放一组。 草 和树枝一起搭配用来做火把，用火烧了草可以变成灰烬，做治疗药膏要用到。初期身上要放一组。 燧石 做工具初期必备。 上面这三样东西，初期见到就采集，每种凑上1组吧，然后制作任何东西后，都是留下至少每种4个，至少为2个火把做准备，有时候一个火把是抗不过一整个夜晚的，然后你就挂了。 其他物品： 胡萝卜，可以直接吃，可以烤着吃，当然建议后一种，营养价值更加丰富。还可以用来吸引兔子？另外如果把胡萝卜给二师兄，他会拉屎？这个目前我还没尝试过。 浆果，可以自己吃。 燧石，是初期有限的资源，伐木采矿的工具都需要燧石。 木头，初期身上要搞一组。 怪物肉，不要自己吃，烤熟了也不要吃，因为会减血。留着，用来吸引二师兄。让他们去跟着你战斗，虽然我还不知道怎么吸引二师兄。 枫树，用来砍得得到木头和PINE CONE？用来干嘛的？ 松树，得到松果有啥用？可以得到木头。 矿产，这个有几种不同的 带条纹的，这种是可以开采出来金子，很有用。做科学机器必备。 白色的，得到的白色矿物，可以用3个一组做成白色整齐的石块，做科学机器后面的炼金机器需要。 冰，这个算不上矿产，太热了，可以吃冰，或者用冰来灭火；另外，做冰箱也需要15个冰块。 其他的还没摸清楚具体的作用。 蜂巢，会掉蜂蜜和另外一个东西，蜂蜜可以吃。 花朵，采集花朵可以提升精神力，12个花朵可以做成一个花环放在头上。 虫洞，这个好玩，之前还不敢跳进去，后来发现这个是传送利器。 动物 蝴蝶，这个就不说啥了。 蜜蜂，可以杀掉得到蜂蜜。击杀只要走位，一次定点两下，很简单搞定4-5只蜜蜂。 蜘蛛，可以杀掉得到蜘蛛卵或者蜘蛛网。蜘蛛网是做捕兽夹的必备，蜘蛛卵是做治疗药膏的必备。只要没有跳跳蛛，2-3-4只都可以通过走位搞定。 二师兄，就是猪，分正常的猪以及绿色的疯猪。可以杀掉得到猪肉，但是我基本上都不敢自己动手，都是依靠吸引二师兄去蜘蛛巢那边，让蜘蛛代为干掉二师兄，因为经常一下子出来5-6只蜘蛛，还有厉害的跳跳蛛，它们杀掉二师兄之后，也会直接吃掉猪肉，我的天，无奈。对了，给二师兄吃肉，会让二师兄跟着你1-2天，但是我目前还不知道哪种肉有效，给了LEAFY MEAT，还有MONSTER MEAT，二师兄吃完了白吃，压根不鸟我的召唤。 牦牛，会拉便便，做农场的必备物品；还有就会据说可以在夜晚用剃须刀给他们刮胡子？然后做出皮帽子？这个我还没成功。另外，耗牛们生气的时候，会攻击你，但是我目前还不知道为啥牦牛会生气。对了，牦牛还会攻击从墓地挖出来的鬼魂，我还没试过，因为还不知道如何挖坟地。 青蛙，杀掉可以得到青蛙腿，目前不知道有啥具体作用。不能用初期的斧头或者锄头和它们原地对砍，攻击力和速度都很高。 游戏攻略1、在哪里设置基地呢？ 可以寻找猪王聚落或牦牛草原，这两处都是设立营地的好地方，猪王聚落可以提供二师兄跟班。 2、急需制作出来的装备 猪皮头盔（或者叫猪皮帽、足球帽、棒球帽都可以，翻译比较乱），科学机器农场 需要粪便， 动物 蜘蛛 可以提供蜘蛛网、怪物肉还有蜘蛛内胆？可以干狗、干二师兄。初期，落单的蜘蛛可以用斧头干它们。 猪（二师兄） 可以提供猪肉，可以干蜘蛛，或者被蜘蛛干。初期不要去主动攻击他们，神走位，搞不定。 进入游戏后，第一件事是搜集附近的浆果、萝卜和燧石，这三项在道具栏最少要保持３个的数量，浆果萝卜可以吸引兔子或自己食用，燧石则是初期有限的资源，伐木采矿的工具都需要先做出来，再来将树枝、草、木材之类的工具营火必须道具收集满一组，就可以准备大范围探索了。刚开始的夜晚都很短，木头营火勉强可以烧整晚，记住要等完全入夜之后再生火，以免浪费资源。火炬也是入夜探索的利器，持着火炬绕着地图边缘走，听到蜘蛛或其他生物叫声不用停下，持续逃跑，蜘蛛最远追到天亮也会停下，到时候又是一只就地睡着代宰的蜘蛛等着你。打到的怪物肉都留着，招募二师兄可以用，不要自己烤来吃，会减血的。初期目标可以设定在寻找猪王聚落或牦牛草原，这两处都是设立营地的好地方，猪王聚落可以提供二师兄跟班，尤其是猪皮足球帽必须抢先制作出来，抵销攻击的效果比木甲还高，而牦牛草原可以帮你分散猎犬注意力。如果身上资源有限，撑不到你找到好地点，也可以考虑地图上的道路交叉点、虫洞入口附近等等，一来方便逃跑，二来也方便你随时舍掉营地出发寻找资源。 当营地初步设立好了，就必须确保食物的供应，游戏大约第２０天就会进入冬天，所以钓竿、蜂巢在冬天都是没作用的，食物的供应建议可以带二师兄去袭击落单的牦牛，最理想的状况是找到高脚鸟窝，既能偷蛋备用高脚鸟也会掉落肉块。其次是准备农田的设立，制作农田需要大量的木炭和粪便，种菜的种子也需要特别搜集，对此不用花太多时间，路过捡捡就好，我们的第二目标是争取在冬天来临前，将肉食的储备提升到一到两组，这样你冬天才有时间去伐木、采矿、还有寻找大象。尤其是冬象象鼻非常重要，冬天的气候效果是会时间性减血，制作出冬象背心能够延缓这段间歇时间，往往在打怪过程中致命一击就是这个减血效果了。等到你能够存活过冬天，基本上在游戏里保命不成问题了，接下来的目标可以放在完善你的武器装备、制作出高营养的料理和补血道具，准备前往冒险模式破主线。个人推荐，前往冒险模式之前必备的两样装备，冬象背心和冰法杖。冰法杖虽然有耐久度，但是危急之际用来冻住敌人拉长距离非常好用，况且结冻的时间长，只要不去主动攻击，冰法杖几乎是无敌的。其他两项可携空格则可根据冒险模式不同关卡的特性来考虑，关卡特性在相关攻略已经有说明。 首先说饥荒死亡五大因素，分别依次是，1黑暗，2被攻击，3饥饿，4精神低下，5冻死。 在大家刚进入地图的时候，首先一件事就是寻找燧石，有了燧石才能造斧子，有了斧子才能砍，树不然在第一个夜晚，会因为没有树木和，草不能构建营火而早早夭折，攒够3个燧石就能，造完斧子造锄头，开垦岩石这样就保证，斧子，锄头原材料不中断，另外不要小看遍地都是的草，有时候割几个懒得割了，殊不知等到了黑夜有时候就差1个草生不成营火被黑暗吞噬！还有就是从一开始就要收集种子和松果，这为以后建立基地的树木和农作物打下坚实基础，最基本生存保证了接下来，才是食物，浆果，萝卜，不要贪心采太多，它们有保质期的，没等你吃完就烂了，，边吃边采才是正道！浆果和萝卜要放在火上烹调才更营养更管饱！ 小提示（不管到什么时候手里都要有木头和草） 基本的食物保证了，下面是，基地选址，，我通常都会把基地放在，草甸上，要选在靠近，毛牛、蜘蛛巢穴、蜜蜂的附近、这样可以方便取牛粪、蜂蜜和蛛网。当然前提是，地图尽量的趟开，知道各个生物和自然特产在什么地方，接下来就是建立基地，，首先先将科学机器建立起来，之后是宝箱再往后是逮兔子的陷阱，放置陷阱的时候一定要找两个洞口紧密挨在一起的，这样用六个陷阱，笼罩两个洞口，可以密集的逮兔子，保障食物的固定来源！下一步就是收集牛粪建立五个或者更多的初级农场，把你收集的种子一个农场种植一个，让她慢慢生长，你就可以干别的去了，下面就是烹煮锅，烹煮锅需要石砖块、木炭、树枝。木炭怎样获得呢？这就需要在营火那一栏第三个选项造一个火把，用火把点燃树木，树木烧焦后砍伐得到木炭，这里要注意，烧完树木后产生的灰烬不要丢了那可是做止血的原料收集好了！ 小提示（精神力低下产生幻觉可以用稻草卷睡一觉补充） 做好以后烹煮锅使用方法是放四个食物按一下下面的按钮开始蒸煮，不管是新鲜的不新鲜的一股脑塞进去出来都是新鲜的肉丸，非常解饿2个就撑住了，解决了吃饭的大问题，接下来就是大量砍伐树木和岩石了，用木板墙或者石头墙把基地围起来，要注意的是饥荒游戏没有设计门这个因素，所以造墙的时候记得要留空，盖好了城墙造一把铲子把周围的树杈全部铲起来，集中放在一起，这样好采集，至于浆果丛和草铲了以后需要牛粪灌溉才能长出来很麻烦，不建议收集，记得吧你收集的松果选一个地方集体载重下去，这以后就成了你的树场了，做完这些事就是要收集蜘蛛网了，蜘蛛网可以做捕虫网等一系列关键装备，用捕虫网去抓蜜蜂饲养这样冬天你就可以不用为食物发愁，像熊二一样做梦都吃着蜂蜜！！ 小提示（墓地挖墓碑出来的幽灵可以引到牛群，牛群会主动攻击幽灵！） 接下来就是冬天保暖的问题了，你可以造剃刀等晚上牛睡觉的时候把牛毛刮下来，寒冬帽构成野牛毛、蜘蛛网。还有就是，寒冬衣的构成海象鼻、野牛帽、蜘蛛网，所以说蜘蛛网非常重要！至于海象鼻那就要等到冬天猎杀海象获得了，海象牙也是基地必不可少的物资！因为我也玩的不是太好所以我吧很多攻击性动物屏蔽了，比如说狗，狗这个家伙我恨之入骨啊，但凡看到你穷追不舍，就算在省际通道上同样跟你跑的一样快！从不轻易放弃！能把人追吐血，最可怕的是当夜幕奖励他还在追你你没有时间点篝火你就等死吧！所以虽然他的牙很重要但是我还是把它放弃了最后祝大家活的长久。 参考文章 《饥荒》新手初期资源收集与食物获取攻略 饥荒新手前期该干什么 饥荒新手游戏玩家必看初期简易攻略心得分享","link":"/2017/08/18/dont_starve_together_is_not_only_a_game/"},{"title":"半途而废的hexo重新开始使用步骤全记录","text":"文章更新 20180225-初次成文 20190719-更新了一些步骤 为什么会有这篇文章自己的hexo记录中断了大半年时间，之前的习惯由于换了新的工作，很多都被颠覆了，现在需要重新在自己之前的基础上继续巩固，所以有了这些文字，并且发现自己博客上的记录，很多文章都在重复的讲一个事情，作为轻度强迫症的自己，实在是受不了这种杂乱，重开一个帖子，整理集合同样的问题，并且简单记录一下。 文章参考条件1、Windows10环境2、已经有了hexo的目录，但是无法运行hexo server等命令了3、如果是全新安装，请参考xxx4、已经安装了cygwin，安装步骤，请参考5、已经安装了node.js，安装步骤，请参考6、已经安装了git，我使用的了cygwin自带的git，安装步骤，请参考 步骤1进入hexo目录，因为hexo server命令跑不起来了，使用npm命令安装下hexo 1npm install -g hexo-cli 然后试试hexo server命令，如果发现无法启动，则请参考这个文件，排查问题。 这是另外一个文件，名字叫做 hexo 遇到的各种问题 如果遇到 ‘localhost:4000无法启动’的问题，最大的可能是’4000’端口被占用了，Windows下的foxit经常占用这个端口，解决的方法有两个，一个是关掉Foxit的选项，另外一个是，使用’hexo server -p 4001’这样的命令启动本地hexo服务器，在IE浏览器里面同样使用’localhost:4001’的方式来访问hexo的本地服务器。 步骤2更新下本地的文件，从远端github上拉取最新版文件。 更新HEXO本身和插件，npm update -g，一个命令搞定hexo-cli和其他插件； 更新HEXO的模板，进入theme/模板 文件夹，使用’git pull’更新模板； 更新markdown文件，使用’git pull’命令。 git pull的时候遇到了一个错误 123456正在获取 originssh: Could not resolve hostname codingnet1: Name or service not knownfatal: 无法读取远程仓库。请确认您有正确的访问权限并且仓库存在。error: 不能获取 origin 请参考这个文件，排查问题。 这是另外一个文件，名字叫做 hexo 遇到的各种问题 ‘hostname github_yourname’，这个名字需要在’.ssh/config’文件里得到解析 要么修改’_config.yml’要么修改’config’文件，我宁可修改’.ssh/config’文件 对了，这里要说一点题外话，之前也使用过一段时间CODING.NET的托管服务，但是发现，因为绑定了顶级域名后，使用coding.net首页会显示个腾讯云或者Coding.net的自家广告，恶心至极。这里暂时保存下’_config.yml’文件的一些配置： 1234567891011# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:- type: git repo: git@github1:tinyvane/tinyvane.github.io.git branch: master message: \"Github Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }}\"- type: git repo: git@codingnet1:tinyvane/tinyvane.git branch: master message: \"Coding.net Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }}\" 然后命令就简单了，拉取远程仓库内容 1git pull 添加文章，使用命令’hexo new filename.md’，添加到本地仓库中，写文章，然后使用下面的命令，将MD等文件保存到github的hexo分支中去。 123git add .git commit -m '123'git push 再使用命令 1hexo g &amp;&amp; hexo d 将渲染生成之后的HTML文件，推送到github的’master’分支中去（这是github pages服务默认的展现分支，这个分支里面一般是静态页面）。 GAME OVER. 参考文章 每天一个linux命令（35）：ln 命令 每天一个linux命令（35）：ln 命令 每天一个linux命令（35）：ln 命令 每天一个linux命令（35）：ln 命令 每天一个linux命令（35）：ln 命令 每天一个linux命令（35）：ln 命令","link":"/2018/02/25/hexo_restart/"},{"title":"在CentOS上安装shadowsocks","text":"文章更新 20170330-初次成文 20180929-更新 为什么会有这篇文章之前翻墙都用搬瓦工，后来用了其他的几个VPS，都没有像搬瓦工那么方便的全自动的配置，所以就只好手动搭梯子了。 在CENTOS6上安装shadowsocks安装pythong-pip1sudo yum install python-pip 结果会显示 12345678910Loaded plugins: fastestmirrorSetting up Install ProcessLoading mirror speeds from cached hostfile * base: mirrors.aliyuncs.com * epel: mirrors.aliyuncs.com * extras: mirrors.aliyuncs.com * remi-safe: ftp.riken.jp * updates: mirrors.aliyuncs.comPackage python-pip-7.1.0-1.el6.noarch already installed and latest versionNothing to do 上面是因为我已经安装过pip，所以显示nothing to do，如果首次安装， 结果会有所不同。 安装shadowsocks继续使用pip安装shadowsocks 1sudo pip install shadowsocks 结果显示如下 12345Collecting shadowsocks Downloading http://mirrors.aliyun.com/pypi/packages/02/1e/e3a5135255d06813aca6631da31768d44f63692480af3a1621818008eb4a/shadowsocks-2.8.2.tar.gzInstalling collected packages: shadowsocks Running setup.py install for shadowsocksSuccessfully installed shadowsocks-2.8.2 建立配置文件建立配置文件 vim /etc/shadowsocks/config.json 123456789{ \"server\":\"xxx.xxx.xxx.xx\", #可以使用的ss服务器IP \"server_port\":1080, #ss服务器端口 \"local_address\": \"127.0.0.1\", \"local_port\":1080, #本地端口 \"password\":\"password\", #连接ss服务器密码 \"timeout\":600, #等待超时 \"method\":\"aes-256-cfb\", #加密方式} 运行shadowsocks服务使用命令控制启动和关闭 12sslocal -c /etc/shadowsocks/config.json -d startsslocal -c /etc/shadowsocks/config.json -d stop 检查是否成功启动 1netstat -lnp|grep 1080 加入开机自启动 1echo \"nohup sslocal -c /etc/shadowsocks/config.json /dev/null 2&gt;&amp;1 &amp;\" /etc/rc.local","link":"/2018/02/25/use_shadowsocks_on_centos_as_ladder_to_cross_the_greatwall/"},{"title":"很沮丧很沮丧","text":"文章更新 20180522-初次成文 为什么会有这篇文章换了新的工作之后，发现真的是瞎忙了很多，而且需要学习的东西感觉太多太多，却发现自己把时间都浪费在了打游戏上面，发现应该睡觉的时候，却在熬夜，应该加油工作的时候，却因为打游戏太累了而告诉自己先睡一会，醒来发现手机上N多找自己的电话。 妈妈走了之后，我发现自己更加容易给自己贴上孩子的标签，谁又想到我已经是一个5岁孩子的爸爸了呢？ 不知道，不知道，我也不知道自己如何才能更加努力，所以才在凌晨4点的时候，来写下这些文字，真的非常非常的沮丧，我发现要做的事情，却浪费了太多的时间，给自己一堆不去努力的理由，到底我在期待什么呢？期待奇迹么？ 在这个世界上，没有奇迹。 好了，git add ., git commit -m ‘add some comments’, git push. Game should be over now.","link":"/2018/05/22/frastraed/"},{"title":"好久没有写东西了","text":"文章更新 20170330-初次成文 为什么会有这篇文章发现上次写东西，应该是自己十分低落的那些日子，只是没想到，后来发生了更让人心疼的事情。 某个早晨，对象给我电话，带着哭声，我害怕的还以为是爸爸出了什么事情，没想到是另外一个让人更加想不到的事情，表弟走了。 前几天才住进去的医院，本来说这个早晨就要出院了，没想到，竟然走了。 下午赶回了天津，去了舅舅家，一家人都在，几个姨妈，大姨时不时忍不住哭几声，最令人心醉的还是舅舅，一直不停的念叨着，9月4日，就死就死。。。傻儿子也不和我交流，只是明天告诉他们吃什么，亲戚给了钱就存到银行里。。。 我不知道怎么安慰，只能一根接一根的抽着烟，有再多的不甘，人也没了。 这不能不让我想起来，同样是一年前的大年初一的子夜，我如何看着几个护士不停轮流的给妈妈做着心脏复苏，如何看着某个拉着拉杆箱，给妈妈注射了药物之后，又转身走了，那时候她的高跟鞋十分的扎眼，只是她的工作，来了又走，没有什么情绪，没有什么心疼或者不甘。。。 回忆并没有减轻大家的伤痛，我只是人在那个地方，心里却一直告诉自己，越早的接受现实，越能够坚强的对待生活，对待家人。 夜里12点左右，三姨的孩子过来了，晚上和表妹没有深究的弟弟的支付宝，反而成了我们俩研究的重点，也是让很多事情浮出水面，但是更让人难受的一个导火索。 美脚，独孤，没有拉过女孩的手，多少的债务，欺骗，谎言，还是孤独。。。 我们每个人都要独自长大，或者被迫着长大，无论哪种方式，总有或多或少的有一些对孤独的想法，或无奈，或欣喜，但是我想，无论哪种方式，总要坦然的接受才好。 否则如何说服自己，不去改变，不去做另外一个自己呢？ 很多次在酒肉场合，和别人“探讨”自己的对错关，自己对淡定的想法，不能不承认，很多时候，遇到个想法独特的，我更多是表达完自己的想法后，更多顺从对方答应下去。 什么是对错？完全看自己的立场，那么自己的立场怎么会有对或者错呢？你的正确，就是你认为的正确，保护好家人，就是你的立场！ 从这个立场下，做的决定，带着别人的利害关系，都是所谓的collatoral damege，没有办法的事情，别人说，对别人的伤害你不难道或者不觉得罪恶么？那么你怎么回答，好吧，把这些伤害，带给你的亲人，你觉得可以接受么？ 不可以，那你就继续批评你的，我继续轻舞飞扬，管您屁事。 对也好，错也好，另外一个重要的因素，就是在你决定了自己的行为后，要坦然接受这样的决定，否则，这样的行为无法持续，也会变成所为的“墙头草”，今天觉得这样对，明天又犯嘀咕，我是不是错了？我是不是下次要多考虑下别人的想法？ 摆脱，大哥，世界上几十亿人了，真正关系和你关心的，也就是3-5个，如果你想胸怀天下，不如选择自刎，还能为别人节约点粮食。 所以，还是要学会面对孤独，但是这个学习的过程，还是希望能陪伴在他的身边，try my best，尽一份父亲和朋友的力量。 2019年9月24日，写于北京的高铁上。 GAME NEVER ENDS. 参考文章 每天一个linux命令（35）：ln 命令","link":"/2018/09/24/just_writing_down_some_stuffs/"},{"title":"穷的竟然负资产了","text":"文章更新 20180926-初次成文 20181005-补充 为什么会有这篇文章写完了，应该是昨天就完成这篇文字的，没想到竟然拖到了今天，不过庆幸的是，昨天晚点的时候，终于想到了一个自己可以做的seo的事情，可以说非常适合自己的性格，也符合搜索引擎的口味，只是需要一段时间的沉淀和积累，不过谈到积累，几年之前的to do list还没有完成的我，又怎么会不懂得事件的积累的难和易呢。 房子基本尘埃落定了本来定的下午一点在朝阳不动产交易中心去做税费缴纳和过户联办的，没想到12点半要出发的时候，领导临时安排了点任务，结果出发的时候，已经一点10分了，还好是一路导航＋电动车飞奔过去，1点35分到达。 都觉得北京房地产已经遇冷，但是感觉朝阳交易大厅依然人山人海，不过想想，哪个人的交易金额不是几百万，都是非常重要的决定。 一共310万，基本搞定了一套朝阳的小两居房子，虽然面积不大吧，但是看看租赁，一个月也是可以到5000甚至5500的，在交易大厅，甚至看到了app上同样户型开价到5700的，真是觉得现在房租越来越高了。看来能在北京打拼的，都不是一般人物，否则面对这样的租金，我感觉至少到手要15000，也就是三分之一左右，才能不那么肉疼。 自己现在住的房子，虽然只有一间，但是刚刚小区整体翻新，厕所，厨房都给全部重新贴了瓷砖，现在住的也算是干净舒适。而且房租虽然从一年前的2000涨到了2200，但是也还算可以接受，所以，知足常乐吧。 关于码字这个事情很久都没有更新博客了，说不上是因为懒惰，还是因为别的什么，现在争取每天可以更新一篇吧，当作日记也好。 后记其实发现仔细的整理了一下帐目，发现手头的钱还是正数的，因为忘记了之前替单位垫付的1w块钱，还有就是出差报销和各种结账也有1w多没有到手，所以，并不是负资产，可以暂时的喘歇一口气了。 不过回过头想想，真的应该好好的节衣缩食，开始存钱了，否则这两套房子和孩子的压力，真的不是一星半点的呢。 参考文章 每天一个linux命令（35）：ln 命令","link":"/2018/09/26/broken_up/"},{"title":"两天陪了三顿酒","text":"文章更新 20180926-初次成文 为什么会有这篇文章这两天陪着几波客户吃饭，甚至一个晚上要赶两个局，中国的酒文化虽然现在随着八项规定的严格实施已经收敛了不少，但是依然在饭桌上，还是能看到很久杯觥交错的场面，尤其是没有女孩子在场的时候，基本上很多时候酒是离不开的，怎么说呢，一句话简单概括一下，“不喝不热闹”，言简意赅，很多话都是借着几杯酒下肚，晕晕乎乎的就说出口。 最近依然在坚持每天下班后骑着电动车扫街，也发现了不少好玩的胡同儿，比如“雨儿胡同”、“帽儿胡同“之类的，而且发现了鼓楼前面那一片真的挺热闹的。 北京的胡同儿，曲径通幽，九曲十八弯，经常是转着转着就出不去了，进了死胡同…这里说的是真正的死胡同，发现这样的胡同儿，其实生活在其中，也并不如想象中那样方便，比如交通、通勤，我就某天见过一辆救护车从胡同儿里面开出来，如果真的是从外面此时再开进来一辆车，基本上就堵在那里了。 电视剧中的四合院，确实是前后几jin的院子（这里的jin字不知道咋写…）但是如果是守着老宅子，不变卖成现金，那么也就真的是穷的只剩下房子了吧。 参考文章 每天一个linux命令（35）：ln 命令","link":"/2018/09/27/three_alcoholic_meals_in_two_days/"},{"title":"远程调试PHP代码","text":"文章更新 20180927-初次成文 为什么会有这篇文章远程空间阿里云，不用也浪费了，就这点原因。 如何配置环境远程阿里云主机上安装xDebug扩展1、ssh到虚拟机，具体命令忽略。 2、在命令行中输入 php -m 可以查看 php 已加载的拓展，如果没有安装xDebug则准备安装， 3、了解自己环境的配置 查看服务器 php 版本，命令php -v php.ini 所在地址，命令 find / -name ‘php.ini’， 服务器系统位数 32位 还是 64位，命令 ‘file /bin/ls’或者’getconf LONG_BIT’ 如果对下载哪个版本的xDebug还是部清楚，那么直接访问xDebug的官方工具页面，地址https://xdebug.org/wizard.php，把php -i命令的结果贴进去，然后出来分析结果，对了，xDebug是不支持低于7.0版本的，至少我的结果是这样。 题外话，如何升级服务器上的PHP版本？地址http://www.wuliaole.com/post/upgrade_php_from_5.3_to_5.4_or_high_version_with_rpm_or_yum/ 4、 安装VS Code和PHP Debug插件1、为什么没有选择Sublime Text？因为写代码还是更习惯VSC。 2、在VSC的扩展里面搜索PHP DEBUG，目前版本1.2+ 3、在VSC的首选项中，配置PHP路径 VS Code 中安装xDebug拓展安装xDdebug拓展之前需要知道运行环境的 PHP 版本信息，以便下载正确的拓展。 首先，拓展分运行架构，x64 和 x86；其次 PHP 分版本，不同版本的拓展程序不同，以及 TS 和 NTS 版本。 通过右击计算机，属性中可以了解到环境的运行架构。 执行命令来获取 PHP 版本： 参考文章 每天一个linux命令（35）：ln 命令","link":"/2018/09/27/debug_php_code_remotely/"},{"title":"和儿子一起写作业","text":"文章更新 20181001-初次成文 为什么会有这篇文章国庆七天假，第一天上午的时间，主要是辅导儿子写作业，抄写、数字、拼音三门作业，其实儿子已经在幼儿园完成了一部分作业了，基本上用了1个小时左右，就把国庆节的作业都完成了。 后来第二天的时候，我偷偷问媳妇，作业是不是国庆节7天每天都有，被告知就之前的那么多，才放下心来，心里觉得作业还真是不多。后来过了几天，媳妇和别人说起来儿子的优点的时候，说他回家第一件事就是先把作业完成之后的时候，我还是优点开心的，虽然后面补了一句儿子觉得把作业完成之后就可以尽情的玩了。但是我依然很开心，因为他老爹是个十足的拖延症啊… 儿子上了学前班，或者叫做“幼小衔接”，已经有快2个月了，但是发现儿子身上依然有一些不大不小的问题，比如动不动就生气，会踢人、咬人等等，每次我都是一本正经的瞪着他，然后他就会无缘无故的和我玩命的闹起来，我只能安慰自己说，孩子还不懂太多的道理，不能一味的严厉，不过话说回来，我自己也拿捏不好这个管教的尺度啊。 参考文章 每天一个linux命令（35）：ln 命令","link":"/2018/10/01/do_homework_with_my_son/"},{"title":"儿子最近的脾气感觉越来越大呢","text":"文章更新 20181007-初次成文 为什么会有这篇文章国庆7天也没有带他去哪里玩玩，基本就是在市内的各个麦当劳转新玩具，儿子他妈一向奉行我平时陪伴少，周末她休息的原则，不过也说不上是好还是不好，不过今天儿子说中午我们俩人去宜家不带妈妈，这句话倒是让我有点担心起来。 媳妇容易着急，总问我为啥看到儿子天天生气着急就自己比他还着急，我说你把好脾气都给了朋友，给亲人就没有耐心了，话说这话说起来容易，做起来难呢。其实反省起来，我自己对她家里人的态度也是不冷不热，其实这并不是什么值得称道的好脾气，主要是因为自己给自己找了个‘好脾气’的借口罢了。 孩子慢慢长大，我不想留下遗憾。 是否能把自己称为一个好父亲，我觉得标准可能在孩子，但是，这和我一直认为的自己又有所不同，所以，也许，教育真的没有标准的答案。","link":"/2018/10/07/7_days_with_ningning/"},{"title":"阿里云centos7.4基础","text":"文章更新 20181010-初次成文 为什么会有这篇文章最近的阿里云活动还是非常给力的，1核cpu 1g内存 1mb带宽的阿里云微型主机，3年价格907元，真是一个给力的价格，虽然1m的带宽可能在下载的速度上差了一些，但是玩转个小应用，或者养活个博客还是绰绰有余的。 准备工作 阿里云使用的CentOS 7.4 64位 阿里云的1核1g1m带宽 IP地址120.27.50.234 开始安装登录阿里云服务器1ssh root@120.27.50.234 修改ssh登陆默认端口修改/etc/ssh/sshd_config1vim /etc/ssh/sshd_config 查找到 #Port 22字段，将其前面的注释去掉，然后在下面添加一行 Port 你希望是用的端口号，就像下面这样： 12Port 22Port 230 这样做的目的是为了保证你添加的端口无法连接的时候，还能使用默认的22端口来连接你的服务器。 修改firewall配置使用 firewall-cmd 命令来添加想要使用的ssh端口： 1firewall-cmd --zone=public --add-port=230/tcp --permanent #permanent是保存配置，不然下次重启以后这次修改无效) 加入防火墙没有启动，请先执行 1systemctl start firewalld 来启动防火墙，然后再次执行上面的 firewall-cmd 命令添加端口，随后重新加载防火墙的规则 1firewall-cmd --reload 查看添加端口是否成功，如果添加成功则会显示yes，否则no 1firewall-cmd --zone=public --query-port=230/tcp 下面的部分是对那些启动了SELinux的系统来说的，如果你的系统没有启动SELinux，下面这一小节可以忽略或者跳过。 修改SELinux相关设置使用以下命令查看当前SElinux 允许的SSH端口： 1semanage port -l | grep ssh 假如遇到错误 semanage command not found ,执行 1yum provides /usr/sbin/semanage 或者 1yum whatprovides /usr/sbin/semanage 上面两条语句二选一，然后 1yum -y install policycoreutils-python 再重新尝试运行 semanage命令。 如果SELinux未开启则先开启查看SELinux状态： 12/usr/sbin/sestatus -v #如果结果显示为enabled，说明selinux正发挥作用 如果显示 disable则需要修改/etc/selinux/config 文件，将selinux=disabled修改为selinux=enforcing或者 selinux=permissive 被动模式，关于这两种模式的区别，大家可以自行google 添加230端口到 SELinux 1semanage port -a -t ssh_port_t -p tcp 230 然后确认一下是否添加进去 1semanage port -l | grep ssh 如果成功会输出 1ssh_port_t tcp 230, 22 重启ssh1systemctl restart sshd.service 如果可以成功连接，则修改完毕，则可以将/etc/sshd/config中的 port 22 注释掉了，只保留230一个端口即可。 再次ssh连接的时候，就要多添加一个参数p，来指定ssh的连接端口。 1ssh -p 230 root@120.27.50.234 并且因为key改变了，还要到文件 ~/.ssh/known_hosts中，把之前记住的RSA key信息删掉 安装OH-MY-ZSH1yum install -y zsh curl git Then use the following script to install ‘OH-MY-ZSH’ terminal. 1sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" 替换yum源，安装各种repo库123456789mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup #Use aliyun's CentOS base repo to replace the CentOS' default repos.wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repoyum makecache #Make cache for yum to speed up the installation of yum's reposyum -y update #Update CentOS's packages to the newest versions.rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm# Install the fedora repo.rpm -Uvh http://rpms.famillecollet.com/enterprise/remi-release-7.rpm #Install Remi repo.install yum-utils #Install yum utilities. Specify the version of yum.yum -y install yum-utils #Install the yum utilities. 安装 PHP7.2、nginx、php-fpm 等等安装nginx1.12.21yum -y install nginx 安装完成后，启动nginx 1systemctl start nginx 让nginx随linux系统启动 1systemctl enable nginx install mysql 8.0The following steps are to install mysqlMySQL must be installed from the MySQL community repository, so following commanded are essential: 123wget https://dev.mysql.com/get/mysql80-community-release-el7-1.noarch.rpmrpm -ivh mysql80-community-release-el7-1.noarch.rpm #Tell yum where to looking for the mysql community ver 8.0, which should be only location in the Remi repos.yum install mysql-server ##on some websites, this is mysql-community-server, got no idea why... Then start the mysql with system start. 123systemctl start mysqldsystemctl enable mysqld systemctl status mysqld # check status of mysqld Enhancement the secure of MySQL First, need to find out what’s the temporary password of MySQL, which isgenerated by the installation program itself for the default installation. 1grep 'temporary password' /var/log/mysqld.log then run the command 1mysql_secure_installation Remember the temporary password above, which is needed for the installation progress of securing MySQL, then you could input the new password you want to set. Install php7.21yum install -y php72 check the php version 1php72 -i Create a symbolic link to /usr/bin/php, other way the default command for php is php72, which is not what you like. 1ln -s /usr/bin/php72 /usr/bin/php install php-fpm and other plugins.Use following comands to search the php related packages. 1yum list installed | grep php And output message should look like below: 12345php72.x86_64 1.0-1.el7.remi @remi-safephp72-php-cli.x86_64 7.2.10-1.el7.remi @remi-safephp72-php-common.x86_64 7.2.10-1.el7.remi @remi-safephp72-php-json.x86_64 7.2.10-1.el7.remi @remi-safephp72-runtime.x86_64 1.0-1.el7.remi @remi-safe So we’re sure that the system got no php-fpm package installed on the server. Run the follow commands to install the php-fpm, which is need to mentioned first: the version of php-fpm also need to be specified to be same like the php you installed already. so the command is alike below: 1yum -y install php72-php-fpm Then eveyting is set!!! Use the following commands to make sure the php-fpm is enabled and started with the system. Which you could be more sure when you double check the status of php-fpm with ‘systemctl status php72-fpm.service’. 123systemctl enable php72-php-fpm.servicesystemctl start php72-php-fpm.servicesystemctl status php72-php-fpm.service Customize the PHP 7.2Configure Nginx for using with PHP 7.2 Make sure latest version of Nginx server installed on CentOS 7 or RHEL 7. Find out nginx server user and group names using egrep command 1egrep '^(user|group)' /etc/nginx/nginx.conf Sample outputs: 1user nginx; Then you need to edit the configuration file on the path /etc/opt/remi/php72/php-fpm.d/, the file name is www.conf. 1vim /etc/opt/remi/php72/php-fpm.d/www.conf Set user and group to nginx, looking for the following specific paragraphs: 12user = nginxgroup = nginx Save and close the file. Restart php-fpm service: 1systemctl restart php72-php-fpm.service Update your nginx config 1vim /etc/nginx/nginx.conf Edit/add as follows in server section: 12345678## enable php support ## location ~ \\.php$ { root /usr/share/nginx/html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; } Save and close the file. Restart the nginx server: 1systemctl restart nginx Create a test script called foo.php at /usr/share/nginx/html/ 1vim /usr/share/nginx/html/foo.php Append the following code: 1234&lt;?php // test script for CentOS/RHEL 7+PHP 7.2+Nginx phpinfo();?&gt; Save and close the file. Fire a browser and type url: http://your-domain-name/foo.php If you see what you should see, then everything is set! Game over! 参考文章 1 2","link":"/2018/10/11/install_centos_74_php_72_and_mysql_80_on_aliyun/"},{"title":"20190719-shadowsocks支持windows邮件、OFFICE登陆翻墙","text":"为什么会有这篇文章即便使用了SSR开了GLOBAL模式，会发现自己的APP STORE和OFFICE 登陆等界面，还是无法打开页面。 前置条件windows10、ssr 正文使用admin模式打开powshell，一条命令搞定。 1foreach($f in Get-ChildItem $env:LOCALAPPDATA\\Packages) {CheckNetIsolation.exe LoopbackExempt -a \"-n=$($f.Name)\"} 或者使用下面的脚本 123456@echo OFFecho 清楚所有程序 &amp;&amp; CheckNetIsolation.exe LoopbackExempt -c 1&gt;nulcd %USERPROFILE%\\AppData\\Local\\Packagesecho 开始添加程序for /d %%i in (*) do echo 添加程序%%i &amp;&amp; CheckNetIsolation.exe LoopbackExempt -a -n = %%i 1&gt;nulpause 标题1标题2参考链接 参考链接 参考链接 参考链接","link":"/2019/07/19/let_windows_mail_office_login_using_shadowsocks/"},{"title":"201907199-常用GIT命令和使用场景","text":"为什么会有这篇文章 git命令太多，总结一下比较好 前置条件至少知道GIT是什么 Git常用操作命令收集git init 命令这个命令是将一个目录初始化为一个git仓库，注意这个命令不要乱用。 常用命令git status ## 查看本地git仓库，显示的信息包括现在在本地哪个分支上，当前分支和远程分支相比的进度，还有哪些文件的改动了等等。 git diff ## 查看当前分支下文件的文件和远程仓库？相比较的具体变化 git add . ## 将新的文件加入到git管理 git log (查看历史提交记录) 远程仓库相关命令检出仓库：$ git clone git://github.com/jquery/jquery.git查看远程仓库：$ git remote -v添加远程仓库：$ git remote add [name] [url] #将本地仓库和远程仓库映射起来，这步很重要，这里[url]应该写类如’https://git.coding.net/tinyvane/hexo.git' 这样的远程仓库地址，举个例子git remote add origin ssh://user@siteurl:port/home/git，这里的origin一般是习惯。删除远程仓库：$ git remote rm [name]修改远程仓库：$ git remote set-url –push[name][newUrl]推送远程仓库：$ git push [remoteName] [localBranchName] git pull 相关命令 拉取远程仓库：$ git pull [remoteName] [localBranchName] 拉取远程仓库并且指向本地指针 将git上所有文件拉取到本地：$ git fetch --all强制将本地内容指向刚刚同步git云端内容：$ git reset --hard origin/master上面这两句通常一起使用。 git push 相关命令说一个比较常见的git push -u的参数，很多时候弄不清楚到底是什么含义。贴一段官方界面 -u, –set-upstreamFor every branch that is up to date or successfully pushed, add upstream (tracking) reference, used by argument-less git-pull(1) and other commands. 分支(branch)操作相关命令查看本地分支：$ git branch查看远程分支：$ git branch -r创建本地分支：$ git branch [name] —-注意新分支创建后不会自动切换为当前分支切换分支：$ git checkout [name]创建新分支并立即切换到新分支：$ git checkout -b [name]删除分支：$ git branch -d [name] —- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项合并分支：$ git merge [name] —-将名称为[name]的分支与当前分支合并 创建远程分支(本地分支push到远程)：$ git push origin [name]删除远程分支：$ git push origin :heads/[name]我从master分支创建了一个issue5560分支，做了一些修改后，使用git push origin master提交，但是显示的结果却是’Everything up-to-date’，发生问题的原因是git push origin master 在没有track远程分支的本地分支中默认提交的master分支，因为master分支默认指向了origin master 分支，这里要使用git push origin issue5560：master 就可以把issue5560推送到远程的master分支了。 使用场景把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，那么可以这么做。 $ git push origin test:master // 提交本地test分支作为远程的master分支 //好像只写这一句，远程的github就会自动创建一个test分支$ git push origin test:test // 提交本地test分支作为远程的test分支 删除远程的分支如果想删除远程的分支呢？类似于上面，如果:左边的分支为空，那么将删除:右边的远程的分支。 $ git push origin :test // 刚提交到远程的test将被删除，但是本地还会保存的，不用担心 版本(tag)操作相关命令查看版本：git tag创建版本：git tag [name]删除版本：git tag -d [name]查看远程版本：git tag -r创建远程版本(本地版本push到远程)：git push origin [name]删除远程版本：git push origin :refs/tags/[name] 子模块(submodule)相关操作命令添加子模块：$ git submodule add [url] [path]如：$ git submodule add git://github.com/soberh/ui-libs.git src/main/webapp/ui-libs初始化子模块：$ git submodule init —-只在首次检出仓库时运行一次就行更新子模块：$ git submodule update —-每次更新或切换分支后都需要运行一下删除子模块：（分4步走哦）1)$ git rm –cached [path]2) 编辑“.gitmodules”文件，将子模块的相关配置节点删除掉3) 编辑“.git/config”文件，将子模块的相关配置节点删除掉4) 手动删除子模块残留的目录 忽略一些文件、文件夹不提交在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如 123targetbin*.db git操作-删除文件git删除文件 1234rm add2.txtgit rm add2.txtgit commit -m \"rm test\"git push web 服务器端 12cd /var/www/foo.gitsudo git update-server-info 检查删除效果 12rm foo3 -rfgit clone http://[某ip]/foo.git foo3 综合场景更新已经存在的local code123cd;cd foo2git remote add web [某user]@[某ip]:/var/www/foo.git/git pull web master github上的版本和本地版本冲突在github上创建项目，然后本地git init 然后没有git pull -f –all 然后git add . | git commit -am “init” 导致github上的版本里有readme文件和本地版本冲突，下面给出冲突原因： [master][~/Downloads/ios] git push -u origin master 强制覆盖已有的分支（可能会丢失改动），再点击上传，上传成功。 只有这句是核心，所以，本人就略微想了一下 [master][~/Downloads/ios] git push -u origin master -f git push的时候遇到’src refspec master does not match any’错误很多时候只是没有执行’commit’命令。 123mkdir repo &amp;&amp; cd repogit remote add origin /path/to/origin.gitgit add . OOOPPPSSS~忘记COMMIT了 12git push -u origin mastererror: src refspec master does not match any. 只需要做一个事情： 12git commit -m \"initial commit\"git push origin master git push 到远程分支在项目中git initgit add .git commit -m “ “ 连接远程主机git remote add [远程主机名] [url] 一种方式是： git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 另一种是：在本地新建分支并切换到该分支git checkout -b [本地分支名] 如果直接git push [本地分支名] 出现fatal: The current branch zheer has no upstream branch.To push the current branch and set the remote as upstream, use git push --set-upstream zheer zheer然后git push –set-upstream [远程主机名] [远程分支名] 强制推送本地master到远程mastergit push -f master master 一些常见错误的解决fatal: refusing to merge unrelated histories这个问题，还没有完全搞明白，看这里：https://stackoverflow.com/questions/37937984/git-refusing-to-merge-unrelated-histories-on-rebase 委婉待续 https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8#%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E5%88%A0%E9%99%A4%E5%92%8C%E9%87%8D%E5%91%BD%E5%90%8D https://blog.csdn.net/abo8888882006/article/details/12375091 https://yuanyuanshen.github.io/2016/10/25/github-%E4%B8%8A%E4%BC%A0error-src-refspec-master-does-not-match-any-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/ 参考链接 git 常用命令(含删除文件) git push 到远程分支","link":"/2019/07/19/common_used_git_commands/"},{"title":"WORD中的VBA操作","text":"为什么会有这篇文章最近用WORD比较多，发现VBA的用处真的是很方便，可以批量做很多手工很麻烦甚至是无法完成的功能。 系列文档 WORD好用的技巧 WORD中的VBA操作 前置条件WORD 常用的VBA记录一下至于怎么启用WORD中的宏操作，简单说一下，依次点击 文件 - 选项 - 信任中心 - 右侧信任中心设置 - 选择启用所有宏。然后在视图选项卡中，最右侧可以见到。 批量删除文档中没用的样式123456789101112131415Sub DeleteUnusedStyles() Dim oStyle As Style For Each oStyle In ActiveDocument.Styles 'Only check out non-built-in styles If oStyle.BuiltIn = False Then With ActiveDocument.Content.Find .ClearFormatting .Style = oStyle.NameLocal .Execute FindText:=\"\", Format:=True If .Found = False Then oStyle.Delete End With End If Next oStyleEnd Sub 批量删除空白表格123456Sub Removetables () Dim oTable As Table Each oTable In ActiveDocument.Tables oTable.Delete Next oTableEnd Sub 参考链接 How To Remove/Delete All Tables From A Document In Word Removing Unused Styles","link":"/2019/08/03/vba_scripts_in_word/"},{"title":"wordpress博客做好之后要做的事情","text":"安装注意调整xshell里的权限，比如www和ftp账号的 调整.htaccess文件默认centos下是没有这个文件的 安装theme我目前用的d8的，记得要保证theme本身不带什么插件，否则就和自己后来装的容易冲突了，同时换一下logo 安装插件删掉hello dolly，启动akimest，api填进去就ok了，安装了高级版本的TinyMCE编辑器，目前除了好用点，没发现其他用处。 不用多说或者畅言，评论在站里还是比较好，因为wordpress 4.3.1默认带了plupload，所以不需要安装之前的那个drag and drop插件了 插一句，关于自动更新的，我在另外一个帖子里写了解决办法，更新wordpress过程中遇到“无法创建目录”问题如何解决？ 总之就是chmod -777或者chmod -755，不多说了，会了就很方便。 水印问题我用的Easy Watermark 0.6.0，这里有一个帖子，介绍了不少水印的插件，但是吧。。。可能作者推荐的，我这里显示安装量和活跃度比较低，就用了一个2个月前更新且符合4.3.1的水印工具，大家自己选择吧，用着顺手就好。 给wordpress图片加水印的3款插件。我自己写了一个中文版的使用介绍。 防盗链备份恢复参考资料http://www.zhihu.com/question/22864602","link":"/2015/12/08/what_need_to_be_done_after_installation_of_wordpress/"},{"title":"微软即点即用和msi共存的安装方法","text":"为什么会有这篇文章这两天在荔枝软件店铺买了5人一辆车的office 365正版系统，发现下载过来是个安装包，安装出错，搜索了一下，原因是说office365只有所谓的“即点即用（Click-to-Run）”，和之前用setup.exe那种安装方式不能共存，想了1分钟我有啥office软件是msi安装包安装的，才想到了visio 2016，万般无奈，只好先卸载了office 2016，但是那是吃饭赚钱的家伙，又不能一直不安装，所以这里记录一下方法。 ODT全名是Office Deployment Tool for Click-to-Run，这是下载地址 软件下载后解压到任意位置，目录会默认带着一个setup.exe和三个xml文件，将其中一个复制了，修改下名字，比如变为’configuration-VISIO2016-x64.xml· 文件内容可以参考我的设置 12345678910111213141516&lt;Configuration&gt; &lt;Add OfficeClientEdition=\"64\" Channel=\"Monthly\"&gt; &lt;Product ID=\"VisioProXVolume\" PIDKEY=\"PD3PC-RHNGV-FXJ29-8JK7D-RJRJK\" /&gt; &lt;Language ID=\"zh-cn\" /&gt; &lt;/Product&gt; &lt;/Add&gt; &lt;!-- Enable all product updates. --&gt; &lt;Updates Enabled=\"TRUE\" Channel=\"Current\" /&gt; &lt;!-- Enable the installer UI to be displayed and automatically accept the EULAs. --&gt; &lt;Display Level=\"Full\" AcceptEULA=\"TRUE\" /&gt; &lt;!-- Automatically activate the installed products. --&gt; &lt;Property Name=\"AUTOACTIVATE\" Value=\"1\" /&gt; &lt;!-- Force any applications blocking the installation to close. --&gt; &lt;Property Name=\"FORCEAPPSHUTDOWN\" Value=\"TRUE\" /&gt;&lt;/Configuration&gt; 然后打开cmd或者powershell，记得要使用admin运行。 1./setup.exe /download .\\configuration-VISIO2016-x64.xml 如果是cmd则使用下面的命令 1setup.exe /download configuration-VISIO2016-x64.xml 然后继续执行安装命令 1setup.exe /configure configuration-VISIO2016-x64.xml 说点其他的我其实折腾了一番后发现，VISIO 2016其实有2个版本，确切的说是3个版本，一个是标准版，只是很少有人喜欢用罢了。另外两个分别是零售版和批量授权版。 对应上面配置文件中的关键字，分别是VisioProRetail和VisioProXVolume，这个地方其实影响挺大的，网上找到的VISIO 2016的序列号，要仔细辨别是零售版还是批量授权版本，否则找到的序列号根本无法激活你下载的VISIO 2016。具体我这里就不放序列号了，大家自己可以找找。或者可以购买正版。 下面是我下载的两种版本VISIO的具体目录，大家可以参考一下： 123 456 上图中，11901是批量授权版本，11727是零售版本。 参考链接 Use the Office Deployment Tool to install volume licensed versions of Project 2016 and Visio 2016 参考链接 参考链接","link":"/2019/07/19/how_does_office365_coexist_with_msi_visio_2016/"},{"title":"WORD中的技巧收集","text":"为什么会有这篇文章将平时收集的各种WORD技巧汇集到一起。 前置条件你有WORD就好。 技巧1-Word上下行不同字数等宽对齐不说话，先看图，什么叫做没有对比就没有伤害：我们自己制作的Word封面是这样的： 大神的Word封面是这样的： 看完这两张图，还需要过多的解释吗？为了达到下图这种效果，有的小伙伴会使用空格进行调整，但有时候即使使用空格，也无法很好的对齐。 那么如何快速实现从图一到图二的呢？分享一个完美的解决方法。 首先调出标尺工具：勾选【视图】选项卡中【显示】组中的【标尺】工具。 选中需要对齐的行，移动标尺两端的标尺点到所需要的位置。标尺在移动的过程中会有一条虚线，可以方便用户使用。 上述操作完成了对页面文字的居中和右边下划线的对齐，接下来我们需要将左边的文字以冒号为基准对齐。 选中左边的文字（注意只选择需要对齐的文字，不要选择一整行），点击【开始】选项卡中【段落】组中的【分散对齐】按钮（不能点击段落–缩进和间距–常规对齐方式中选择分散对齐），会弹出调整宽度对话框。 在弹出的【调整宽度】对话框中，根据实际需求设置【新文字宽度】，然后点击确定。 同理，设置下一行文字进行设置，就达到我们需要的效果了。 技巧2 查找与替换空行替换这里的空行指单独显示软回车或硬回车的行。如何替换？在“编辑”菜单中打开“查找和替换”对话框（或按ctrl+H），在“查找内容”中输入^p^p（ ^p指段落标记）替换位置中输入^p，然后点击全部替换。 手动换行符(Shift+回车)替换^p^p替换成^p并不能替换因手动换行符形成的空行。如果文件中用的是手动换行符，那么就要用^l^l替换成^p。 ***注意，这里用的不是1，而是L字母的小写，也可以直接用替换对话框里的特殊字符，里面有手动换行符)，空行才能去除。 注意空格的存在。如果每个空行的换行符前还有一个空格。空格成了“罪魁祸首”！再用“^l ^l”(注意两个换行之间有一个空格)，替换成“^l”。单击几次全部替换，再更改了几次“查找内容”，比如把“^p ^l”替换成“^l”。页面中再也没有空行了。 查找替换：（根据回车形式不同而不同） 1、查找输入^l,替换成^p （手动回车） 2、查找^p^w^p,替换成^p （两空行之间有空格内容） 3、查找^p^p,替换成^p （如果一次没有清理干净，多查找替换几遍） 软回车替换成硬回车1.在“查找替换”中用“^l ”替换成“^p”，这里用的不是1，而是L字母的小写，也可以直接用替换对话框里的“特殊字符”，里面有“手动换行符”。 2.网上复制的内容先粘贴到“记事本”中，再复制粘贴到WORDK中，就“OK”了！ 一个奇怪的方框 这个方块，是一个全角空格。前面那个原点，是一个“不间断空格”，这些在特殊符号里，都可以找到。很多时候，WORD这些奇奇怪怪的符号会让你很抓狂。 参考链接 技巧1原文参考链接 参考链接 参考链接","link":"/2020/02/24/Useful_tips_in_Microsoft_Word/"},{"title":"WORD中有用的技巧","text":"为什么会有这篇文章前置条件正文标题1标题2参考链接 参考链接 参考链接 参考链接","link":"/2020/02/24/Useful_tips_in_word/"},{"title":"HEXO插入图片的BT脑回路","text":"为什么会有这篇文章hexo的插入图片的方式，主要有两种，一种是使用![]()，一种是。 如果有人和我一样，按照下面几种方式来使用hexo，会觉得上面这两种方式，很难说哪里方式更加反人类。不问为什么，只说怎么干，就是耍流氓。我的前提条件： 使用资源文件，asset_folder: true 在front-matter区域，使用了urlname变量，作为生成html后的网址来存放真实文章的index.html和所有相关图片。 真正markdown文章保存在日期时间-中文件名.md这样的文件中，并且配套生成日期时间-中文件名的文件夹中。 我使用typora所见即所得的编辑器来写东西。typora支持拖放文件直接可视化。 这样，写文章的时候，就会很纠结，我个人是肯定受不了的不符合MARKDOWN语法或者风格插入方式的，并且这种方式，在typora里面也看不到实际的图片。 所以，就只剩下了如何修改![]()这种方式了。 然后，发现了hexo-asset-image这个插件，好用的很。 不过大家注意，如果直接使用npm install hexo-asset-image --save这样安装的话，好像版本不是最新的，所以我去了作者的github上看了，果然有人在讨论这个问题，所以采用了原始保守的方式安装。 1npm install https://github.com/xcodebuild/hexo-asset-image --save 虽然可能网络不是很好的话，从github时间会花的长一些，但是从这里安装的，能保证是最新的版本（我当时默认方式安装的是0.0.4版本，从github安装的是0.0.5版本）。 这样安装好之后，其实还是能发现有一些小问题的，就是关于如果在_config.yml文件中没有使用超过 年/月/日 在你的title前面的话，就会有这种问题出现，我截图一下。 我是不想和这个问题过多纠缠了，我把我的permilink从以前的#permalink: post/:urlname/，改成了permalink: :year/:month/:day/:urlname/。一切完美。 这样，在typora里，我新加入的图片也可以启动显示，以前老的文章里，生成的html的一切正常，只是需要在typora里面，增加一个前置路径，这样在typora里面才能实时看到图片，总之，是比较完美的解决方案了。 参考链接 hexo-asset-image的GITHUB Hexo 的 markdown-it 渲染引擎和其相关插件 在 hexo 中无痛使用本地图片 Front-matter Hexo - Layout 从零开始制作 Hexo 主题 hexo中完美插入本地图片 [hexo图片快捷插入(https://blog.csdn.net/Jesounao/article/details/79205774)","link":"/2019/08/04/the_human_way_of_inserting_pics_in_hexo/"},{"title":"Visual Studio 2015 的日常","text":"文章更新1.20160909-初次成文 为什么会有这篇文章没有为什么 一些常用设置如何修改项目初始创建的位置“工具”-“选项”，从“项目和解决方案”文件夹中选择“常规”。在“Visual Studio 项目位置”文本框中输入文件和项目的位置。 快捷键添加类 SHIFT+ALT+C 一些记录的东西如何添加RESX资源文件参见这里添加和编辑资源 /(Visual C#/) 对于resx文件，我们可以在vs2015的IDE中在 解决方案资源管理器 中点右键-&gt;添加新项目中-&gt;控件资源档来添加。 参考文章 无聊小博","link":"/2016/09/09/the_life_with_visual_studio_2015/"},{"title":"C#全局键盘监听（Hook）的使用","text":"文章更新 20151210-初次成文 20170518-更新内容 为什么需要全局键盘监听？在某些情况下应用程序需要实现快捷键执行特定功能，例如大家熟知的QQ截图功能Ctrl+Alt+A快捷键，只要QQ程序在运行（无论是拥有焦点还是处于后台运行状态），都可以按下快捷键使用此功能… 这个时候在程序中添加键盘监听肯定不能满足需求了，当用户焦点不在App上时（如最小化，或者用户在处理其它事物等等）键盘监听就失效了 怎样才能实现全局键盘监听？这里需要用到Windows API，源码如下：（可以作为一个工具类[KeyboardHook.cs]收藏起来） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164using System;using System.Collections.Generic;using System.Text;using System.Runtime.InteropServices;using System.Windows.Forms;using System.Reflection;namespace clickmonitor{ /// &lt;summary&gt; /// 键盘钩子 /// [以下代码来自某网友，并非本人原创] /// &lt;summary&gt; class KeyboardHook { public event KeyEventHandler KeyDownEvent; public event KeyPressEventHandler KeyPressEvent; public event KeyEventHandler KeyUpEvent; public delegate int HookProc(int nCode, Int32 wParam, IntPtr lParam); static int hKeyboardHook = 0; //声明键盘钩子处理的初始值 //值在Microsoft SDK的Winuser.h里查询 //转载自http://www.bianceng.cn/Programming/csharp/201410/45484.htm public const int WH_KEYBOARD_LL = 13; //线程键盘钩子监听鼠标消息设为2，全局键盘监听鼠标消息设为13 HookProc KeyboardHookProcedure; //声明KeyboardHookProcedure作为HookProc类型 //键盘结构 [StructLayout(LayoutKind.Sequential)] public class KeyboardHookStruct { public int vkCode; //定一个虚拟键码。该代码必须有一个价值的范围1至254 public int scanCode; // 指定的硬件扫描码的关键 public int flags; // 键标志 public int time; // 指定的时间戳记的这个讯息 public int dwExtraInfo; // 指定额外信息相关的信息 } //使用此功能，安装了一个钩子 [DllImport(\"user32.dll\", CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)] public static extern int SetWindowsHookEx(int idHook, HookProc lpfn, IntPtr hInstance, int threadId); //调用此函数卸载钩子 [DllImport(\"user32.dll\", CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)] public static extern bool UnhookWindowsHookEx(int idHook); //使用此功能，通过信息钩子继续下一个钩子 [DllImport(\"user32.dll\", CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)] public static extern int CallNextHookEx(int idHook, int nCode, Int32 wParam, IntPtr lParam); // 取得当前线程编号（线程钩子需要用到） [DllImport(\"kernel32.dll\")] static extern int GetCurrentThreadId(); //使用WINDOWS API函数代替获取当前实例的函数,防止钩子失效 [DllImport(\"kernel32.dll\")] public static extern IntPtr GetModuleHandle(string name); public void Start() { // 安装键盘钩子 if (hKeyboardHook == 0) { KeyboardHookProcedure = new HookProc(KeyboardHookProc); hKeyboardHook = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardHookProcedure, GetModuleHandle(System.Diagnostics.Process.GetCurrentProcess().MainModule.ModuleName), 0); //hKeyboardHook = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardHookProcedure, Marshal.GetHINSTANCE(Assembly.GetExecutingAssembly().GetModules()[0]), 0); //************************************ //键盘线程钩子 //SetWindowsHookEx( 2,KeyboardHookProcedure, IntPtr.Zero, GetCurrentThreadId());//指定要监听的线程idGetCurrentThreadId(), //键盘全局钩子,需要引用空间(using System.Reflection;) //SetWindowsHookEx( 13,MouseHookProcedure,Marshal.GetHINSTANCE(Assembly.GetExecutingAssembly().GetModules()[0]),0); // //关于SetWindowsHookEx (int idHook, HookProc lpfn, IntPtr hInstance, int threadId)函数将钩子加入到钩子链表中，说明一下四个参数： //idHook 钩子类型，即确定钩子监听何种消息，上面的代码中设为2，即监听键盘消息并且是线程钩子，如果是全局钩子监听键盘消息应设为13， //线程钩子监听鼠标消息设为7，全局钩子监听鼠标消息设为14。lpfn 钩子子程的地址指针。如果dwThreadId参数为0 或是一个由别的进程创建的 //线程的标识，lpfn必须指向DLL中的钩子子程。 除此以外，lpfn可以指向当前进程的一段钩子子程代码。钩子函数的入口地址，当钩子钩到任何 //消息后便调用这个函数。hInstance应用程序实例的句柄。标识包含lpfn所指的子程的DLL。如果threadId 标识当前进程创建的一个线程，而且子 //程代码位于当前进程，hInstance必须为NULL。可以很简单的设定其为本应用程序的实例句柄。threaded 与安装的钩子子程相关联的线程的标识符 //如果为0，钩子子程与所有的线程关联，即为全局钩子 //************************************ //如果SetWindowsHookEx失败 if (hKeyboardHook == 0) { Stop(); throw new Exception(\"安装键盘钩子失败\"); } } } public void Stop() { bool retKeyboard = true; if (hKeyboardHook != 0) { retKeyboard = UnhookWindowsHookEx(hKeyboardHook); hKeyboardHook = 0; } if (!(retKeyboard)) throw new Exception(\"卸载钩子失败！\"); } //ToAscii职能的转换指定的虚拟键码和键盘状态的相应字符或字符 [DllImport(\"user32\")] public static extern int ToAscii(int uVirtKey, //[in] 指定虚拟关键代码进行翻译。 int uScanCode, // [in] 指定的硬件扫描码的关键须翻译成英文。高阶位的这个值设定的关键，如果是（不压） byte[] lpbKeyState, // [in] 指针，以256字节数组，包含当前键盘的状态。每个元素（字节）的数组包含状态的一个关键。如果高阶位的字节是一套，关键是下跌（按下）。在低比特，如果设置表明，关键是对切换。在此功能，只有肘位的CAPS LOCK键是相关的。在切换状态的NUM个锁和滚动锁定键被忽略。 byte[] lpwTransKey, // [out] 指针的缓冲区收到翻译字符或字符。 int fuState); // [in] Specifies whether a menu is active. This parameter must be 1 if a menu is active, or 0 otherwise. //获取按键的状态 [DllImport(\"user32\")] public static extern int GetKeyboardState(byte[] pbKeyState); [DllImport(\"user32.dll\", CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)] private static extern short GetKeyState(int vKey); private const int WM_KEYDOWN = 0x100;//KEYDOWN private const int WM_KEYUP = 0x101;//KEYUP private const int WM_SYSKEYDOWN = 0x104;//SYSKEYDOWN private const int WM_SYSKEYUP = 0x105;//SYSKEYUP private int KeyboardHookProc(int nCode, Int32 wParam, IntPtr lParam) { // 侦听键盘事件 if ((nCode &gt;= 0) &amp;&amp; (KeyDownEvent != null || KeyUpEvent != null || KeyPressEvent != null)) { KeyboardHookStruct MyKeyboardHookStruct = (KeyboardHookStruct)Marshal.PtrToStructure(lParam, typeof(KeyboardHookStruct)); // raise KeyDown if (KeyDownEvent != null &amp;&amp; (wParam == WM_KEYDOWN || wParam == WM_SYSKEYDOWN)) { Keys keyData = (Keys)MyKeyboardHookStruct.vkCode; KeyEventArgs e = new KeyEventArgs(keyData); KeyDownEvent(this, e); } //键盘按下 if (KeyPressEvent != null &amp;&amp; wParam == WM_KEYDOWN) { byte[] keyState = new byte[256]; GetKeyboardState(keyState); byte[] inBuffer = new byte[2]; if (ToAscii(MyKeyboardHookStruct.vkCode, MyKeyboardHookStruct.scanCode, keyState, inBuffer, MyKeyboardHookStruct.flags) == 1) { KeyPressEventArgs e = new KeyPressEventArgs((char)inBuffer[0]); KeyPressEvent(this, e); } } // 键盘抬起 if (KeyUpEvent != null &amp;&amp; (wParam == WM_KEYUP || wParam == WM_SYSKEYUP)) { Keys keyData = (Keys)MyKeyboardHookStruct.vkCode; KeyEventArgs e = new KeyEventArgs(keyData); KeyUpEvent(this, e); } } //如果返回1，则结束消息，这个消息到此为止，不再传递。 //如果返回0或调用CallNextHookEx函数则消息出了这个钩子继续往下传递，也就是传给消息真正的接受者 return CallNextHookEx(hKeyboardHook, nCode, wParam, lParam); } ~KeyboardHook() { Stop(); } }} 如何使用上面的工具类？准备工作把上面的工具类添加到项目中 首先导入需要的命名空间12using System.Runtime.InteropServices; //调用WINDOWS API函数时要用到using Microsoft.Win32; //写入注册表时要用到 安装Hook在程序入口中写上下面的代码（本例中用了WinForm，在Form的构造方法中安装Hook即可） 123var k_hook = new KeyboardHook();k_hook.KeyDownEvent += new KeyEventHandler(hook_KeyDown);//钩住键按下k_hook.Start();//安装键盘钩子 判断输入键值（实现KeyDown事件）12345678private void hook_KeyDown(object sender, KeyEventArgs e){ //判断按下的键（Alt + A） if (e.KeyValue == (int)Keys.A &amp;amp;&amp;amp; (int)Control.ModifierKeys == (int)Keys.Alt) { System.Windows.Forms.MessageBox.Show(\"按下了指定快捷键组合\"); }} 注意几种不同的键值判断： 单普通键（例如A） 单控制键+单普通键（例如Ctrl+A） 多控制键+单普通键（例如Ctrl+Alt+A）上面的代码中演示了2，其它情况以此类推，无非就是添几个条件再&amp;&amp;起来就好 搞定！ 需要注意的问在应用程序中使用全局键盘监听，会被360发现，弹窗提示用户“有程序正在监听键盘输入，是否阻止？” 所以如果程序中必须要用Hook，应该告诉用户不会泄露其信息等等，或者直接把程序提交给360进行审核，否则杀软的提示会对用户体验造成极大的影响 P.S：本程序在腾讯管家安装的条件下进行了使用，並未发现提示不良，所以至少腾讯干了件好事，但是360就好说了。 另外一个需要注意的问题，就是程序运行一定时候后，无法使用热键进行呼出，也就是以为这Hook失效了。根据网上的资料，这是Win10的一个机制，可以通过修改注册表，增加Windows卸载LowLevelHook的延时。但是经过这样的修改，Hook依然会失效，关于这个问题，我也在寻找解决的问题。 如果大家想修改，可以去注册表程序中找到相应的位置： HKEY_CURRENT_USER\\Control Panel\\Desktop ，修改数值，单位是毫秒。下图是具体的位置： 我把这个数值修改成了86400000，也就是一天24小时。观察下效果。如果对这个问题有兴趣，可以尝试更改Hook的注入方式，不采用SetWindowsHookEx的方式。 参考资料 C#全局键盘监听（Hook）的使用","link":"/2015/12/10/the_usage_of_hookers_in_key_code_capture_in_c_sharp/"}],"tags":[{"name":"chrome","slug":"chrome","link":"/tags/chrome/"},{"name":"浏览器","slug":"浏览器","link":"/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"插件","slug":"插件","link":"/tags/%E6%8F%92%E4%BB%B6/"},{"name":"快捷键","slug":"快捷键","link":"/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"Vimium","slug":"Vimium","link":"/tags/Vimium/"},{"name":"Vim","slug":"Vim","link":"/tags/Vim/"},{"name":"VSCode","slug":"VSCode","link":"/tags/VSCode/"},{"name":"Visual Studio","slug":"Visual-Studio","link":"/tags/Visual-Studio/"},{"name":"OSX","slug":"OSX","link":"/tags/OSX/"},{"name":"windows10","slug":"windows10","link":"/tags/windows10/"},{"name":"uac","slug":"uac","link":"/tags/uac/"},{"name":"wordpress","slug":"wordpress","link":"/tags/wordpress/"},{"name":"权限","slug":"权限","link":"/tags/%E6%9D%83%E9%99%90/"},{"name":"截图","slug":"截图","link":"/tags/%E6%88%AA%E5%9B%BE/"},{"name":"右键菜单","slug":"右键菜单","link":"/tags/%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/"},{"name":"c#","slug":"c","link":"/tags/c/"},{"name":"键盘模拟","slug":"键盘模拟","link":"/tags/%E9%94%AE%E7%9B%98%E6%A8%A1%E6%8B%9F/"},{"name":"软件使用","slug":"软件使用","link":"/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"置顶","slug":"置顶","link":"/tags/%E7%BD%AE%E9%A1%B6/"},{"name":"微信","slug":"微信","link":"/tags/%E5%BE%AE%E4%BF%A1/"},{"name":"辅助工具","slug":"辅助工具","link":"/tags/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":".net","slug":"net","link":"/tags/net/"},{"name":"查壳","slug":"查壳","link":"/tags/%E6%9F%A5%E5%A3%B3/"},{"name":"反编译","slug":"反编译","link":"/tags/%E5%8F%8D%E7%BC%96%E8%AF%91/"},{"name":"rsa","slug":"rsa","link":"/tags/rsa/"},{"name":"加密","slug":"加密","link":"/tags/%E5%8A%A0%E5%AF%86/"},{"name":"平铺","slug":"平铺","link":"/tags/%E5%B9%B3%E9%93%BA/"},{"name":"桌面","slug":"桌面","link":"/tags/%E6%A1%8C%E9%9D%A2/"},{"name":"窗口","slug":"窗口","link":"/tags/%E7%AA%97%E5%8F%A3/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"WordPress","slug":"WordPress","link":"/tags/WordPress/"},{"name":"迁移","slug":"迁移","link":"/tags/%E8%BF%81%E7%A7%BB/"},{"name":"mac","slug":"mac","link":"/tags/mac/"},{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"node.js","slug":"node-js","link":"/tags/node-js/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"xamarin","slug":"xamarin","link":"/tags/xamarin/"},{"name":"bonjor","slug":"bonjor","link":"/tags/bonjor/"},{"name":"apple","slug":"apple","link":"/tags/apple/"},{"name":"MarkDown","slug":"MarkDown","link":"/tags/MarkDown/"},{"name":"Sublime Text 3","slug":"Sublime-Text-3","link":"/tags/Sublime-Text-3/"},{"name":"错误","slug":"错误","link":"/tags/%E9%94%99%E8%AF%AF/"},{"name":"提速","slug":"提速","link":"/tags/%E6%8F%90%E9%80%9F/"},{"name":"100m宽带","slug":"100m宽带","link":"/tags/100m%E5%AE%BD%E5%B8%A6/"},{"name":"北京联通","slug":"北京联通","link":"/tags/%E5%8C%97%E4%BA%AC%E8%81%94%E9%80%9A/"},{"name":"脚本","slug":"脚本","link":"/tags/%E8%84%9A%E6%9C%AC/"},{"name":"coding.net","slug":"coding-net","link":"/tags/coding-net/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"electon","slug":"electon","link":"/tags/electon/"},{"name":"跨平台","slug":"跨平台","link":"/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"},{"name":"软件","slug":"软件","link":"/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"水印","slug":"水印","link":"/tags/%E6%B0%B4%E5%8D%B0/"},{"name":"键位","slug":"键位","link":"/tags/%E9%94%AE%E4%BD%8D/"},{"name":"英文键盘","slug":"英文键盘","link":"/tags/%E8%8B%B1%E6%96%87%E9%94%AE%E7%9B%98/"},{"name":"日文键盘","slug":"日文键盘","link":"/tags/%E6%97%A5%E6%96%87%E9%94%AE%E7%9B%98/"},{"name":"karabiner","slug":"karabiner","link":"/tags/karabiner/"},{"name":"MAC","slug":"MAC","link":"/tags/MAC/"},{"name":"PC","slug":"PC","link":"/tags/PC/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"移动硬盘","slug":"移动硬盘","link":"/tags/%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/"},{"name":"bitlocker","slug":"bitlocker","link":"/tags/bitlocker/"},{"name":"hfs","slug":"hfs","link":"/tags/hfs/"},{"name":"ext4","slug":"ext4","link":"/tags/ext4/"},{"name":"hfs for Windows","slug":"hfs-for-Windows","link":"/tags/hfs-for-Windows/"},{"name":"progon","slug":"progon","link":"/tags/progon/"},{"name":"M3 bitlocker loader","slug":"M3-bitlocker-loader","link":"/tags/M3-bitlocker-loader/"},{"name":"osx","slug":"osx","link":"/tags/osx/"},{"name":"技巧","slug":"技巧","link":"/tags/%E6%8A%80%E5%B7%A7/"},{"name":"centos","slug":"centos","link":"/tags/centos/"},{"name":"centos7","slug":"centos7","link":"/tags/centos7/"},{"name":"启动","slug":"启动","link":"/tags/%E5%90%AF%E5%8A%A8/"},{"name":"pc","slug":"pc","link":"/tags/pc/"},{"name":"同步","slug":"同步","link":"/tags/%E5%90%8C%E6%AD%A5/"},{"name":"代码","slug":"代码","link":"/tags/%E4%BB%A3%E7%A0%81/"},{"name":"音乐","slug":"音乐","link":"/tags/%E9%9F%B3%E4%B9%90/"},{"name":"单曲循环","slug":"单曲循环","link":"/tags/%E5%8D%95%E6%9B%B2%E5%BE%AA%E7%8E%AF/"},{"name":"树莓派","slug":"树莓派","link":"/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"Raspberry","slug":"Raspberry","link":"/tags/Raspberry/"},{"name":"sketchup","slug":"sketchup","link":"/tags/sketchup/"},{"name":"3D建模","slug":"3D建模","link":"/tags/3D%E5%BB%BA%E6%A8%A1/"},{"name":"autocad","slug":"autocad","link":"/tags/autocad/"},{"name":"RASPBERRY","slug":"RASPBERRY","link":"/tags/RASPBERRY/"},{"name":"IMG","slug":"IMG","link":"/tags/IMG/"},{"name":"烧录","slug":"烧录","link":"/tags/%E7%83%A7%E5%BD%95/"},{"name":"raspberry","slug":"raspberry","link":"/tags/raspberry/"},{"name":"bt sync","slug":"bt-sync","link":"/tags/bt-sync/"},{"name":"花生壳","slug":"花生壳","link":"/tags/%E8%8A%B1%E7%94%9F%E5%A3%B3/"},{"name":"站内链接","slug":"站内链接","link":"/tags/%E7%AB%99%E5%86%85%E9%93%BE%E6%8E%A5/"},{"name":"永久链接","slug":"永久链接","link":"/tags/%E6%B0%B8%E4%B9%85%E9%93%BE%E6%8E%A5/"},{"name":"oh-my-zsh","slug":"oh-my-zsh","link":"/tags/oh-my-zsh/"},{"name":"bash","slug":"bash","link":"/tags/bash/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"用户管理","slug":"用户管理","link":"/tags/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"name":"vim","slug":"vim","link":"/tags/vim/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"xdebug","slug":"xdebug","link":"/tags/xdebug/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"aliyun","slug":"aliyun","link":"/tags/aliyun/"},{"name":"homebrew","slug":"homebrew","link":"/tags/homebrew/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"php-fpm","slug":"php-fpm","link":"/tags/php-fpm/"},{"name":"rhel","slug":"rhel","link":"/tags/rhel/"},{"name":"redhat","slug":"redhat","link":"/tags/redhat/"},{"name":"rpm","slug":"rpm","link":"/tags/rpm/"},{"name":"yum","slug":"yum","link":"/tags/yum/"},{"name":"repo","slug":"repo","link":"/tags/repo/"},{"name":"responsity","slug":"responsity","link":"/tags/responsity/"},{"name":"brew","slug":"brew","link":"/tags/brew/"},{"name":"安装","slug":"安装","link":"/tags/%E5%AE%89%E8%A3%85/"},{"name":"opernwrt","slug":"opernwrt","link":"/tags/opernwrt/"},{"name":"dropbear","slug":"dropbear","link":"/tags/dropbear/"},{"name":"分类","slug":"分类","link":"/tags/%E5%88%86%E7%B1%BB/"},{"name":"wifi","slug":"wifi","link":"/tags/wifi/"},{"name":"蓝牙","slug":"蓝牙","link":"/tags/%E8%93%9D%E7%89%99/"},{"name":"openvpn","slug":"openvpn","link":"/tags/openvpn/"},{"name":"vpn","slug":"vpn","link":"/tags/vpn/"},{"name":"ghost","slug":"ghost","link":"/tags/ghost/"},{"name":"FTP","slug":"FTP","link":"/tags/FTP/"},{"name":"raspbian","slug":"raspbian","link":"/tags/raspbian/"},{"name":"目录","slug":"目录","link":"/tags/%E7%9B%AE%E5%BD%95/"},{"name":"搬瓦工","slug":"搬瓦工","link":"/tags/%E6%90%AC%E7%93%A6%E5%B7%A5/"},{"name":"shadowsocks","slug":"shadowsocks","link":"/tags/shadowsocks/"},{"name":"科学上网","slug":"科学上网","link":"/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"raspberry pi","slug":"raspberry-pi","link":"/tags/raspberry-pi/"},{"name":"btsync","slug":"btsync","link":"/tags/btsync/"},{"name":"resiliosync","slug":"resiliosync","link":"/tags/resiliosync/"},{"name":"emergency mode","slug":"emergency-mode","link":"/tags/emergency-mode/"},{"name":"紧急模式","slug":"紧急模式","link":"/tags/%E7%B4%A7%E6%80%A5%E6%A8%A1%E5%BC%8F/"},{"name":"launchagents","slug":"launchagents","link":"/tags/launchagents/"},{"name":"syncthing","slug":"syncthing","link":"/tags/syncthing/"},{"name":"cron","slug":"cron","link":"/tags/cron/"},{"name":"crontab","slug":"crontab","link":"/tags/crontab/"},{"name":"rapsberry","slug":"rapsberry","link":"/tags/rapsberry/"},{"name":"系统","slug":"系统","link":"/tags/%E7%B3%BB%E7%BB%9F/"},{"name":"deploy","slug":"deploy","link":"/tags/deploy/"},{"name":"rm","slug":"rm","link":"/tags/rm/"},{"name":"mv","slug":"mv","link":"/tags/mv/"},{"name":"cp","slug":"cp","link":"/tags/cp/"},{"name":"synergy","slug":"synergy","link":"/tags/synergy/"},{"name":"共享","slug":"共享","link":"/tags/%E5%85%B1%E4%BA%AB/"},{"name":"鼠标","slug":"鼠标","link":"/tags/%E9%BC%A0%E6%A0%87/"},{"name":"键盘","slug":"键盘","link":"/tags/%E9%94%AE%E7%9B%98/"},{"name":"Xamarin","slug":"Xamarin","link":"/tags/Xamarin/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"cygwin","slug":"cygwin","link":"/tags/cygwin/"},{"name":"赚钱宝","slug":"赚钱宝","link":"/tags/%E8%B5%9A%E9%92%B1%E5%AE%9D/"},{"name":"firewall","slug":"firewall","link":"/tags/firewall/"},{"name":"防火墙","slug":"防火墙","link":"/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"},{"name":"resilio sync","slug":"resilio-sync","link":"/tags/resilio-sync/"},{"name":"tar","slug":"tar","link":"/tags/tar/"},{"name":"gz","slug":"gz","link":"/tags/gz/"},{"name":"开发","slug":"开发","link":"/tags/%E5%BC%80%E5%8F%91/"},{"name":"xampp","slug":"xampp","link":"/tags/xampp/"},{"name":"apache","slug":"apache","link":"/tags/apache/"},{"name":"cow","slug":"cow","link":"/tags/cow/"},{"name":"socks5","slug":"socks5","link":"/tags/socks5/"},{"name":"ie","slug":"ie","link":"/tags/ie/"},{"name":"edge","slug":"edge","link":"/tags/edge/"},{"name":"thinkphp","slug":"thinkphp","link":"/tags/thinkphp/"},{"name":".net core","slug":"net-core","link":"/tags/net-core/"},{"name":"斗鱼","slug":"斗鱼","link":"/tags/%E6%96%97%E9%B1%BC/"},{"name":"弹幕","slug":"弹幕","link":"/tags/%E5%BC%B9%E5%B9%95/"},{"name":"symlink","slug":"symlink","link":"/tags/symlink/"},{"name":"ln","slug":"ln","link":"/tags/ln/"},{"name":"launchdaemon","slug":"launchdaemon","link":"/tags/launchdaemon/"},{"name":"macOS","slug":"macOS","link":"/tags/macOS/"},{"name":"formula","slug":"formula","link":"/tags/formula/"},{"name":"bower","slug":"bower","link":"/tags/bower/"},{"name":"wireshark","slug":"wireshark","link":"/tags/wireshark/"},{"name":"抓包","slug":"抓包","link":"/tags/%E6%8A%93%E5%8C%85/"},{"name":"shortcuts","slug":"shortcuts","link":"/tags/shortcuts/"},{"name":"windows 10","slug":"windows-10","link":"/tags/windows-10/"},{"name":"mouse","slug":"mouse","link":"/tags/mouse/"},{"name":"升级","slug":"升级","link":"/tags/%E5%8D%87%E7%BA%A7/"},{"name":"mklink","slug":"mklink","link":"/tags/mklink/"},{"name":"screen","slug":"screen","link":"/tags/screen/"},{"name":"ngrok","slug":"ngrok","link":"/tags/ngrok/"},{"name":"反向代理","slug":"反向代理","link":"/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"},{"name":"内网穿透","slug":"内网穿透","link":"/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"name":"404","slug":"404","link":"/tags/404/"},{"name":"华为","slug":"华为","link":"/tags/%E5%8D%8E%E4%B8%BA/"},{"name":"光纤","slug":"光纤","link":"/tags/%E5%85%89%E7%BA%A4/"},{"name":"光猫","slug":"光猫","link":"/tags/%E5%85%89%E7%8C%AB/"},{"name":"dotnetcore","slug":"dotnetcore","link":"/tags/dotnetcore/"},{"name":"runtime","slug":"runtime","link":"/tags/runtime/"},{"name":"sdk","slug":"sdk","link":"/tags/sdk/"},{"name":"vs","slug":"vs","link":"/tags/vs/"},{"name":"Winform","slug":"Winform","link":"/tags/Winform/"},{"name":"csharp","slug":"csharp","link":"/tags/csharp/"},{"name":"双击","slug":"双击","link":"/tags/%E5%8F%8C%E5%87%BB/"},{"name":"最小化","slug":"最小化","link":"/tags/%E6%9C%80%E5%B0%8F%E5%8C%96/"},{"name":"winform","slug":"winform","link":"/tags/winform/"},{"name":"Resilio Sync","slug":"Resilio-Sync","link":"/tags/Resilio-Sync/"},{"name":"GPT","slug":"GPT","link":"/tags/GPT/"},{"name":"MBR","slug":"MBR","link":"/tags/MBR/"},{"name":"明月永在","slug":"明月永在","link":"/tags/%E6%98%8E%E6%9C%88%E6%B0%B8%E5%9C%A8/"},{"name":"openwrt","slug":"openwrt","link":"/tags/openwrt/"},{"name":"WD","slug":"WD","link":"/tags/WD/"},{"name":"饥荒","slug":"饥荒","link":"/tags/%E9%A5%A5%E8%8D%92/"},{"name":"游戏","slug":"游戏","link":"/tags/%E6%B8%B8%E6%88%8F/"},{"name":"低落","slug":"低落","link":"/tags/%E4%BD%8E%E8%90%BD/"},{"name":"随笔","slug":"随笔","link":"/tags/%E9%9A%8F%E7%AC%94/"},{"name":"喝酒","slug":"喝酒","link":"/tags/%E5%96%9D%E9%85%92/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"远程","slug":"远程","link":"/tags/%E8%BF%9C%E7%A8%8B/"},{"name":"调试","slug":"调试","link":"/tags/%E8%B0%83%E8%AF%95/"},{"name":"作业","slug":"作业","link":"/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"word","slug":"word","link":"/tags/word/"},{"name":"vba","slug":"vba","link":"/tags/vba/"},{"name":"博客","slug":"博客","link":"/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"office","slug":"office","link":"/tags/office/"},{"name":"visio","slug":"visio","link":"/tags/visio/"},{"name":"msi","slug":"msi","link":"/tags/msi/"},{"name":"Word","slug":"Word","link":"/tags/Word/"},{"name":"图片","slug":"图片","link":"/tags/%E5%9B%BE%E7%89%87/"},{"name":"visual studio","slug":"visual-studio","link":"/tags/visual-studio/"},{"name":"hook","slug":"hook","link":"/tags/hook/"},{"name":"监听","slug":"监听","link":"/tags/%E7%9B%91%E5%90%AC/"}],"categories":[{"name":"折腾","slug":"折腾","link":"/categories/%E6%8A%98%E8%85%BE/"},{"name":"编程","slug":"编程","link":"/categories/%E7%BC%96%E7%A8%8B/"},{"name":"效率","slug":"效率","link":"/categories/%E6%95%88%E7%8E%87/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"基础","slug":"Hexo/基础","link":"/categories/Hexo/%E5%9F%BA%E7%A1%80/"},{"name":"CentOS","slug":"CentOS","link":"/categories/CentOS/"},{"name":"树莓派","slug":"树莓派","link":"/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"入门","slug":"树莓派/入门","link":"/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/%E5%85%A5%E9%97%A8/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"日常使用","slug":"日常使用","link":"/categories/%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8/"},{"name":"MacOS","slug":"MacOS","link":"/categories/MacOS/"}]}